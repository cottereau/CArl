/*
 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "CArlFreeFemMacros.idp"

// --- Program

// - Preamble

// Define system constants
real tgv = 10^30;
real alphaEps = 10^-2;		// alpha epsilon constant

// LATIN parameters
int			LATINIters = 10^6;
real		LATINTol = 1e-2;
real		LATINRelax = 0.8;
real[int]	LATINIndex(LATINIters);

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("-meshA","");
string InputB = getARGV("-meshB","");
string InputIntersection = getARGV("-meshInter","");

// Create mesh objects
mesh ThA = readmesh(InputA);
mesh ThB = readmesh(InputB);
mesh ThI = readmesh(InputIntersection);

// Create the functional spaces
fespace VhA(ThA,[P1,P1]);	// Model A
fespace VhB(ThB,[P1,P1]);	// Model B

VhA [uxA,uyA],[vxA,vyA];
VhB [uxB,uyB],[vxB,vyB];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;

func fBX = 0;
func fBY = 0;

// Boundary conditions
int  boundAIdx1 = 10;
func boundAX1   = 0;
func boundAY1   = 0;

int  boundBIdx1 = 10;
func boundBX1   = 0.038625*y;
func boundBY1   = -0.0061125*(y);

// Physical constants
real lambdaA = 1;
real muA = 1;

real lambdaB = 1;
real muB = 1;

// - Create the alpha mask
string InputAlphaMask = getARGV("-alphaMask","");
mesh ThAlpha = readmesh(InputAlphaMask);
fespace VhAlpha(ThAlpha,P0);

/*
 *		Create a "reg" function that returns, for a given point, the geometric
 * 	region defined in the "InputAlphaMask" file.
 */
VhAlpha reg=region; // Remember, it's a P0 function!

/*
 * 		Identify the region indices.
 */
int idxA =reg(0.5,0.5);
int idxB =reg(2.5,0.5);
int idxI =reg(1.5,0.5);

/*
 * 		Region identifying functions
 */
VhAlpha isInA = (region==idxA);
VhAlpha isInB = (region==idxB);
VhAlpha isInI = (region==idxI);

func alphaA		= 0 + (1 - alphaEps)*isInA + 0.5*isInI + alphaEps*isInB;
func alphaB		= 0 + alphaEps*isInA + 0.5*isInI + (1 - alphaEps)*isInB;

// - Main models

// Set up weak formulations
/*
 * 		Note: 	when using "varf" and "matrix" to build the matrices, the first
 * 				argument is associated to the solution, while the second defines
 * 				the functional space of the test functions.
 */

// Matrices
// Using the LamÃ©'s system definition given by FreeFem++ docs
varf vStiffA([uxA,uyA],[vxA,vyA]) = int2d(ThA)(
						alphaA*2*muA*Stiffness2D(uxA,uyA,vxA,vyA)
						+ alphaA*lambdaA*Div2D(uxA,uyA)*Div2D(vxA,vyA)
						)
						+ on(10,uxA=boundAX1,uyA=boundAY1);

varf vStiffB([uxB,uyB],[vxB,vyB]) = int2d(ThB)(
						alphaB*2*muB*Stiffness2D(uxB,uyB,vxB,vyB)
						+ alphaB*lambdaB*Div2D(uxB,uyB)*Div2D(vxB,vyB)
						)
						+ on(10,uxB=boundBX1,uyB=boundBY1);

matrix MA = vStiffA(VhA,VhA,tgv=tgv);
matrix MB = vStiffB(VhB,VhB,tgv=tgv);

// Vectors
varf vForceA([dummyX,dummyY],[vx,vy]) =
						- int2d(ThA)( fAX*vx + fAY*vy)
						+ on(10,dummyX=boundAX1,dummyY=boundAY1);

varf vForceB([dummyX,dummyY],[vx,vy]) =
						- int2d(ThB)( fBX*vx + fBY*vy)
						+ on(10,dummyX=boundBX1,dummyY=boundBY1);

real[int] FA = vForceA(0,VhA,tgv=tgv);
real[int] FB = vForceB(0,VhB,tgv=tgv);

// - Couplings

// Set up constants
real kappa = 1;
real eee   = 1;

// Set up weak formulations
varf vCoupling([ux,uy],[vx,vy]) = int2d(ThI)
	( kappa/(eee*eee)*Mass2D(ux,uy,vx,vy) + kappa*Stiffness2D(ux,uy,vx,vy) );

// Build the coupling matrices
matrix CA = vCoupling(VhA,VhA,tgv=tgv);
matrix CB = vCoupling(VhB,VhA,tgv=tgv);

CompactLines(CA);
CompactLines(CB);
// - Projections

// Set up weak formulations
varf vProject([ux,uy],[vx,vy]) = int2d(ThI)
	( kappa/(eee*eee)*Mass2D(ux,uy,vx,vy) + kappa*Stiffness2D(ux,uy,vx,vy) );

// Mediator space coupling
matrix CI = vProject(VhA,VhA,tgv=tgv);

CompactLines(CI);
CompactCols(CI);

// - LATIN !
// Do some asserts (just to be sure)
assert(MA.n==MA.m);
assert(MB.n==MB.m);
assert(CI.n==CI.m);

assert(CA.n==CI.n);
assert(CA.m==MA.m);

assert(CB.n==CI.n);
assert(CB.m==MB.m);

// Dimension constants (for ease of use)
int nA = MA.n;
int nB = MB.n;
int nI = CI.n;

// Projectors (using partial lumping method)
matrix invCI;

BlockLumpingInvCI(CI,invCI);

matrix PA = invCI*CA;
matrix PB = invCI*CB;

//// Projectors (using full lumping method)
//matrix PA = CA;
//matrix PB = CB;
//real[int]	lumpedCI(nI);
//
//FullLumpingCI(CI,lumpedCI);
//FullLumpingProjection(lumpedCI,PA);
//FullLumpingProjection(lumpedCI,PB);

// Search constants
real k = 2.5;
real kuA = k; real kuB = k; real kdA = k; real kdB = k;

// Vectors
real[int] solA(nA);		// solutions
real[int] solB(nB);		//

real[int] wA(nI);    	// projections
real[int] wB(nI);   	//

real[int] auxA(nI);    	// auxiliar vectors
real[int] auxB(nI);   	//

real[int] phiA(nI); 	// Lagrange multiplier fields
real[int] phiB(nI);  	//

real[int] forceA(nA);	// external forces
real[int] forceB(nB);	//

real[int] solAOld(nA);		// old versions
real[int] solBOld(nB);		//
real[int] phiAOld(nI); 		//
real[int] phiBOld(nI);  	//

real[int] phiADiff(nI);		//
real[int] phiBDiff(nI);		//
real[int] phiASum(nI);		//
real[int] phiBSum(nI);		//

// Matrices
matrix HA = (CA'*PA);
       HA = kdA*HA + MA;

matrix HB = (CB'*PB);
       HB = kdB*HB + MB;

set(HA,solver=UMFPACK);
set(HB,solver=UMFPACK);

// Initializations
forceA = FA;
forceB = FB;

solA = HA^-1*forceA;
solB = HB^-1*forceB;

wA = PA*solA;
wB = PB*solB;

phiA = -kdA*wA;
phiB = -kdB*wB;

// Iterate!
int iterCount = -1;
real LATINConv = 1 + LATINTol;

while ( LATINConv > LATINTol && iterCount < LATINIters)
{
	++iterCount;

	// Coupled stage
	auxA = kuA*wA - phiA;
	auxB = kuB*wB - phiB;

	wA = auxA + auxB;
	wA = 1/(kuA+kuB)*wA;
	wB = wA;

	phiA = kuA*wA - auxA;
	phiB = kuB*wB - auxB;

	// Uncoupled stage
	auxA = - kdA*wA - phiA;
	auxB = - kdB*wB - phiB;

	solAOld = solA;
	solBOld = solB;

	forceA = CA'*auxA;
	forceA = FA - forceA;

	forceB = CB'*auxB;
	forceB = FB - forceB;

	solA = HA^-1*forceA;
	solB = HB^-1*forceB;

	wA = PA*solA;
	wB = PB*solB;

	phiAOld = phiA;
	phiBOld = phiB;

	phiA = - kdA*wA - auxA;
	phiB = - kdB*wB - auxB;

	// Relaxation
	solA = LATINRelax*solA + (1 - LATINRelax)*solAOld;
	solB = LATINRelax*solB + (1 - LATINRelax)*solBOld;

	// Convergence
	phiADiff = phiA - phiAOld;
	phiBDiff = phiB - phiBOld;

	phiASum = phiA + phiAOld;
	phiBSum = phiB + phiBOld;
	LATINConv = 2*sqrt(pow(phiADiff.l2,2) + pow(phiBDiff.l2,2)) /
			      sqrt(pow(phiASum.l2,2)  + pow(phiBSum.l2,2));

	LATINIndex[iterCount] = LATINConv;
}

// Print solution!

/*		!!!	The two expressions below are NOT equivalent (i.e. uxA[] != uyA[])
 * 			It seems like FreeFem++ overloads the 'operator=' for vectorial
 * 			F.E. spaces. [uxA,uyA] are linked by their declaration, and the
 * 			operations 'uxA[] = solA' and 'uyA[] = solA' projects the X and Y
 * 			elements of the solutions onto uxA and uyA;
 */

uxA[] = solA;
uyA[] = solA;

uxB[] = solB;
uyB[] = solB;

// Prepare to plot
real coef = 10e-155;
//real coef = 10;

//mesh ThASol = movemesh(ThA,[x+coef*uxA,y+coef*uyA]);
//mesh ThBSol = movemesh(ThB,[x+coef*uxB,y+coef*uyB]);

// Plot deformed mesh
plot(ThA,ThB,wait=true,ps="FE2DLatin_originalMesh.eps");
//plot(ThASol,ThBSol,wait=true,ps="FE2DLatin_deformedMeshl_block_2.eps");
plot(ThA,ThB,[uxA,uyA],[uxB,uyB],wait=true,ps="FE2DLatin_deformedMeshl_block_2.eps");

// Plot tolerance
ofstream toleranceFile("FE2DLatin_tol_block_2.dat");
for (int iii = 0; iii <= iterCount; iii++)
{
	toleranceFile <<  iii + 1 << " " << LATINIndex[iii] << endl;
}

ofstream gnuplotFile("FE2DLatin_tol.gplot");
gnuplotFile	<< "set term eps" << endl
			<< "set output \"CArl_toll_block_2.eps\" " << endl
			<< "set title \"LATIN tolerance (inverse)\"" << endl
			<< "set xrange [1:]" << endl
		    << "set xlabel \"Iteration\"" << endl
			<< "set ylabel \"Tolerance\"" << endl
			<< "plot \"FE2DLatin_tol.dat\" w lp lc 1 notitle" << endl
			<< "quit" << endl;
