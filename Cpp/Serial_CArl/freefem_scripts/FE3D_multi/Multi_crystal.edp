/*
 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "../CArlFreeFemMacros.idp"

// --- "Defines" for the boundary conditions
int BoundIDMinZ = 1;
int BoundIDMinY = 2;
int BoundIDMaxX = 3;
int BoundIDMaxY = 4;
int BoundIDMinX = 5;
int BoundIDMaxZ = 6;

// --- Program

// - Preamble

// Define system constants
real tgv = 10^30;

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("--mesh","meshes/test__w_0_1__p_100.mesh");

// Create mesh objects
mesh3 ThA = readmesh3(InputA);

// Create the functional spaces
fespace VhA(ThA,[P1,P1,P1]);	// Model A

VhA [uxA,uyA,uzA],[vxA,vyA,vzA];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;
func fAZ = 0;

// Boundary conditions

func boundAX1   = 0;
func boundAY1   = 0;
func boundAZ1   = 0;

func boundAX2   = 0.2;
func boundAY2   = 0.99984769515639123916*y+0.01745240643728351282*z - y;
func boundAZ2   = -0.01745240643728351282*y+0.99984769515639123916*z - z;

// Physical constant mask
string crystalMask = getARGV("--centers","meshes/test__w_0_1__p_100_centers.dat");
string physicalParamsFile = getARGV("--parameters","meshes/test__w_0_1__p_100_physical.dat");

cout << " --> Files: " << endl;
cout << "   > " << InputA << endl;
cout << "   > " << crystalMask << endl;
cout << "   > " << physicalParamsFile << endl;
ifstream crystalCenters(crystalMask);
ifstream physicalParams(physicalParamsFile);

int nbOfCrystals = -1;
int nbOfParams = -1;
int dummyId = -1;

crystalCenters >> nbOfCrystals;
physicalParams >> nbOfParams;

assert(nbOfCrystals == nbOfParams);

real[int] crystalX(nbOfCrystals);
real[int] crystalY(nbOfCrystals);
real[int] crystalZ(nbOfCrystals);
int[int]  crystalIdx(nbOfCrystals);

real[int] lambdaVector(nbOfCrystals);
real[int] youngVector(nbOfCrystals);
real[int] muVector(nbOfCrystals);
real youngTemp = 0;

fespace VhCrystalDomains(ThA,P0);

cout << endl;
cout << " --> Reading crystal centers file ...";
for(int iii = 0; iii < nbOfCrystals; ++iii)
{
	crystalCenters >> crystalX[iii];
	crystalCenters >> crystalY[iii];
	crystalCenters >> crystalZ[iii];
	crystalCenters >> crystalIdx[iii];
}
cout << " finished!" << endl;

cout << " --> Reading parameters file ...";
for(int iii = 0; iii < nbOfCrystals; ++iii)
{
	physicalParams >> youngVector[iii];
	physicalParams >> muVector[iii];
	physicalParams >> dummyId;
}
cout << " finished!" << endl;

VhCrystalDomains reg=region;
VhCrystalDomains[int] crystalRegions(nbOfCrystals);

VhCrystalDomains tempRandomLambda;
VhCrystalDomains tempRandomMu;

cout << " --> Generating region functions ... " << endl;
cout << "   > Idx / Mu     / E      / Lambda 1" << endl;

for(int iii = 0; iii < nbOfCrystals; ++iii)
{
	lambdaVector[iii] = lambdaF(youngVector[iii],muVector[iii]);

	crystalRegions[iii] = (region == reg(crystalX[iii],crystalY[iii],crystalZ[iii]));

	tempRandomLambda = tempRandomLambda + lambdaVector[iii]*crystalRegions[iii];
	tempRandomMu = tempRandomMu + muVector[iii]*crystalRegions[iii];

	cout << "   > " << crystalIdx[iii] << " " << muVector[iii] << " "
			<< youngVector[iii] << " " << lambdaVector[iii] << endl;
}
func randomLambda = tempRandomLambda;
func randomMu = tempRandomMu;
cout << " --> Generating region functions ... finished!" << endl;

//for(int iii = 0; iii < nbOfCrystals; ++iii)
//{
//	muVector[iii] = muMean + (2*randreal1() - 1) * muAmpl;
//	youngTemp = youngMean + (2*randreal1() - 1) * youngAmpl;
//	lambdaVector[iii] = lambdaF(youngTemp,muVector[iii]);
//
//	crystalRegions[iii] = (region == reg(crystalX[iii],crystalY[iii],crystalZ[iii]));
//
//	tempRandomLambda = tempRandomLambda + lambdaVector[iii]*crystalRegions[iii];
//	tempRandomMu = tempRandomMu + muVector[iii]*crystalRegions[iii];
//
//	cout << muVector[iii] << " " << lambdaVector[iii] << " " << crystalIdx[iii] << endl;
//}

cout << " --> Building matrices ... ";
varf vStiff([uxA,uyA,uzA],[vxA,vyA,vzA]) = int3d(ThA)(
						2*randomMu*Stiffness3D(uxA,uyA,uzA,vxA,vyA,vzA)
						+ randomLambda*Div3D(uxA,uyA,uzA)*Div3D(vxA,vyA,vzA)
						)
						+ on(BoundIDMinX,uxA=boundAX1,uyA=boundAY1,uzA=boundAZ1)
						+ on(BoundIDMaxX,uxA=boundAX2,uyA=boundAY2,uzA=boundAZ2);

varf vForce([dummyAX,dummyAY,dummyAZ],[vxA,vyA,vzA]) =
						- int3d(ThA)( fAX*vxA + fAY*vyA + fAZ*vzA)
						+ on(BoundIDMinX,dummyAX=boundAX1,dummyAY=boundAY1,dummyAZ=boundAZ1)
						+ on(BoundIDMaxX,dummyAX=boundAX2,dummyAY=boundAY2,dummyAZ=boundAZ2);


matrix M = vStiff(VhA,VhA,tgv=tgv);

real[int] F = vForce(0,VhA,tgv=tgv);
cout << " finished!" << endl;

cout << " --> Solving ... ";
real[int] sol = M^-1*F;
cout << " finished!" << endl;

uxA[] = sol;
uyA[] = sol;
uzA[] = sol;

real coef = 15;

mesh3 ThASol = movemesh3(ThA,transfo=[x+coef*uxA,y+coef*uyA,z+coef*uzA]);

string meshOutput = getARGV("--output","meshes/deformed_test__w_0_1__p_100.mesh");

savemesh(ThASol,meshOutput);
