/*
 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "../CArlFreeFemMacros.idp"

// --- Program

// - Preamble

// Define system constants
real tgv = 10^30;
real alphaEps = 10^-2;		// alpha epsilon constant

// LATIN parameters
int			LATINIters = 10^4;
real		LATINTol = 1e-2;
real		LATINRelax = 0.8;
real[int]	LATINIndex(LATINIters);

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("-meshA","");

// Create mesh objects
mesh3 ThA = readmesh3(InputA);

// Create the functional spaces
fespace VhA(ThA,[P1,P1,P1]);	// Model A

VhA [uxA,uyA,uzA],[vxA,vyA,vzA];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;
func fAZ = 0;

// Boundary conditions
int  boundAIdx1 = 100;
func boundAX1   = 0;
func boundAY1   = 0;
func boundAZ1   = 0;

int  boundBIdx1 = 300;
func boundBX1   = 0;
func boundBY1   = 0.05 * (z - 0.5);
func boundBZ1   = -0.05 * (y - 0.5);
//func boundBX1	= 0.038625*z;
//func boundBY1	= 0;
//func boundBZ1 	= -0.0061125*z;

// Physical constants
real lambdaA = 1;
real muA = 1;

// - Main models

// Set up weak formulations
/*
 * 		Note: 	when using "varf" and "matrix" to build the matrices, the first
 * 				argument is associated to the solution, while the second defines
 * 				the functional space of the test functions.
 */

// Matrices
// Using the Lam√©'s system definition given by FreeFem++ docs
varf vStiffA([uxA,uyA,uzA],[vxA,vyA,vzA]) = int3d(ThA)(
						2*muA*Stiffness3D(uxA,uyA,uzA,vxA,vyA,vzA)
						+ lambdaA*Div3D(uxA,uyA,uzA)*Div3D(vxA,vyA,vzA)
						)
						+ on(boundBIdx1,uxA=boundBX1,uyA=boundBY1,uzA=boundBZ1)
						+ on(boundAIdx1,uxA=boundAX1,uyA=boundAY1,uzA=boundAZ1);

matrix MA = vStiffA(VhA,VhA,tgv=tgv);

// Vectors
varf vForceA([dummyX,dummyY,dummyZ],[vx,vy,vz]) =
						- int3d(ThA)( fAX*vx + fAY*vy + fAZ*vz)
						+ on(boundBIdx1,dummyX=boundBX1,dummyY=boundBY1,dummyZ=boundBZ1)
						+ on(boundAIdx1,dummyX=boundAX1,dummyY=boundAY1,dummyZ=boundAZ1);

real[int] FA = vForceA(0,VhA,tgv=tgv);

real[int] solA(MA.n);		// solutions

solA = MA^-1*FA;

uxA[] = solA;
uyA[] = solA;
uzA[] = solA;

// Prepare to plot
real coef = 10;

mesh3 ThASol = movemesh3(ThA,transfo=[x+coef*uxA,y+coef*uyA,z+coef*uzA]);

// Plot deformed mesh
//plot(ThA,wait=true,ps="FE3DLatin_originalMesh.eps");
plot(ThA,ThASol,wait=true,ps="FE3DLatin_mono_deformedMesh.eps");
