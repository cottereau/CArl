/**
\file cpp_usage.dox
   
\page cpp_usage Usage and implementation

\section sec_cpp_usage Usage

The C++ implementation of the Arlequin method follows the algorithms presented in [[[REF]]], and it is roughly divided into three parts:

1. the mesh intersection search,
2. the coupling matrices assembly,
3. and the coupled system solver.

The first two steps are implemented in the \ref CArl_build_intersections.cpp "CArl_build_intersections" and \ref CArl_assemble_coupling.cpp "CArl_assemble_coupling", respectivelly. Their corresponding pages contain the documentation of the input parameters.

The coupled system solver uses the FETI method [[[REF]]] to calculate the coupled solutions of the two systems. To allow the usage of external solvers in a non-intrusive way, the implementation is broken down into several `CArl_FETI_***` binaries. If the user is using a scheduler program such as PBS, he only has to configure and launch the \ref CArl_FETI_setup_init.cpp "CArl_FETI_setup_init" binary (see note \ref note_1 "1").

Before calling the coupled system solver, though, the user has to do any preliminary operations involving the external solvers, including preparing their input parameter files. The output of the coupled system solver is a vector in the PETSc binary format.

The figure below presents a workflow for using the C++ version of CArl. The page \ref cpp_examples shows, in detailed steps, how to run a simple test case using external solvers based on the libMesh library. Finally, a more detailed description of the role of each `CArl_FETI_***` binaries is presented in the following section.

\image html CArl_FETI_structure_slide_reduced.png

\section sec_cpp_implementation Implementation of the FETI solver

This section enters in some details of the implementation of the FETI solver, and as such reading the references [[[REF]]] and [[[REF]]] beforehand is highly recommended.

As said above, our implementation of the FETI algortihm is broken down into several `CArl_FETI_***` binaries. The "break points" correspont to the operations of the FETI algorithm where the solutions of the external solvers are needed. Before closing, each one of these binaries executes a script which first submits the jobs for the external solver, and then calls the appropriate `CArl_FETI_***` binary to continue the algortihm.

This approach allows a non-intrusive usaage of the external solvers: the user only has to worry to save the data to be sent from the `CArl_FETI_***` binaries and the external solvers in the appropriate format (see note \ref note_2 "2"). It also avoids wasting cluster resources with idling jobs.

The figure below shows the structure of the FETI solver. It proceeds in the following manner:

1. **Setup**:
   1. \ref CArl_FETI_setup_init.cpp "CArl_FETI_setup_init" generates the input parameter files for the other binaries, and the three execution scripts: `init_script.sh`, `iter_script.sh` and `sol_script.sh`. It then starts the setup of conjugate gradient method (CG) used by the coupled solver to calculate the Lagrange multipliers, and finally executes the `init_script.sh` script.
   2. The `init_script.sh` script runs the external solvers for the uncoupled solutions \f$u_{m,0}\f$ (\f$m = 1,2\f$), and the initial auxiliary vectors \f$x_m(0)\f$ (if needed). After these solvers are finished, the script launches \ref CArl_FETI_setup_finish.cpp "CArl_FETI_setup_finish".
   3. \ref CArl_FETI_setup_finish.cpp "CArl_FETI_setup_finish" finishes the CG solver setup, and executes `iter_script.sh`.
2. **Iterate**
   1. The `iter_script.sh` script runs the external solvers for the \f$iii\f$-th auxiliary vectors \f$x_m(iii)\f$. After these solvers are finished, the script launches \ref CArl_FETI_iterate.cpp "CArl_FETI_iterate"
   2. \ref CArl_FETI_iterate.cpp "CArl_FETI_iterate" all the other operations involved in the CG solver iteration, and checks the convergence parameters:
     - If the CG solver neither converged or diverged, it executes `iter_script.sh` again.
     - If the CG solver converged, it executes `sol_script.sh`.
	 - If the CG solver diverged, it stops the algorithm.
3. **Solution**
   1. The `sol_script.sh` runs the external solvers for the final auxiliary vectors \f$x_m(FINAL)\f$, used to calculate the coupling effects on the models' solutions. After these solvers are finished, the script launches \ref CArl_FETI_set_sol.cpp "CArl_FETI_set_sol", which assembles and exports the coupled system solutions \f$u_{m}\f$.
   
As said above, this process is completely automated if a scheduling software, such as PBS, is used: the user only has to configure and execute the `CArl_FETI_setup_init` binary. Details about the input parameters of each binary can be found at its documentation page (linked above).

\image html CArl_FETI_structure_slide_feti_solver.png



\section cpp_usage_refs Notes and references

\anchor note_1 1. If the user is not using a scheduler, the \ref CArl_FETI_setup_init.cpp "CArl_FETI_setup_init" binary will still take care of preparing the other binaries input files, but the user will have to launch them by hand! Each binary will still return the command that the user has to run, but due to this limitation, the usage of a scheduler is highly recomended.

\anchor note_2 2. At the moment, the binaries are capable of reading and writing vectors and matrices in the PETSc binary vectors and matrices. Details of their usage can be found at the documentation of each executable.

*/