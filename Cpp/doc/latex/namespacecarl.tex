\hypertarget{namespacecarl}{}\section{carl Namespace Reference}
\label{namespacecarl}\index{carl@{carl}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classcarl_1_1assemble__coupling__matrices}{assemble\+\_\+coupling\+\_\+matrices}
\item 
struct \hyperlink{structcarl_1_1carl__mult__coupling__input__params}{carl\+\_\+mult\+\_\+coupling\+\_\+input\+\_\+params}
\item 
struct \hyperlink{structcarl_1_1coupling__assemble__coupling__input__params}{coupling\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params}
\begin{DoxyCompactList}\small\item\em Structure containing the parameters for the construction of the coupling matrices. \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1coupling__matrices__3}{coupling\+\_\+matrices\+\_\+3}
\item 
struct \hyperlink{structcarl_1_1feti__iterate__params}{feti\+\_\+iterate\+\_\+params}
\begin{DoxyCompactList}\small\item\em Structure containing the parameters for the setup initialization of the F\+E\+T\+I solver. \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1_f_e_t_i___operations}{F\+E\+T\+I\+\_\+\+Operations}
\begin{DoxyCompactList}\small\item\em Class containing the operations needed for the F\+E\+T\+I solver. \end{DoxyCompactList}\item 
struct \hyperlink{structcarl_1_1feti__set__sol__params}{feti\+\_\+set\+\_\+sol\+\_\+params}
\begin{DoxyCompactList}\small\item\em Structure containing the parameters for the setup initialization of the F\+E\+T\+I solver. \end{DoxyCompactList}\item 
struct \hyperlink{structcarl_1_1feti__setup__finish__params}{feti\+\_\+setup\+\_\+finish\+\_\+params}
\begin{DoxyCompactList}\small\item\em Structure containing the parameters for the setup initialization of the F\+E\+T\+I solver. \end{DoxyCompactList}\item 
struct \hyperlink{structcarl_1_1feti__setup__init__params}{feti\+\_\+setup\+\_\+init\+\_\+params}
\begin{DoxyCompactList}\small\item\em Structure containing the parameters for the setup initialization of the F\+E\+T\+I solver. \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1_intersection___search}{Intersection\+\_\+\+Search}
\begin{DoxyCompactList}\small\item\em Class containing the structure needed to find all the intersections between two meshes, inside the coupling region mesh. \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1_intersection___tools}{Intersection\+\_\+\+Tools}
\begin{DoxyCompactList}\small\item\em Class with a series of methods to find the intersections between lib\+Mesh\textquotesingle{}s elements, using C\+G\+A\+L internally. \end{DoxyCompactList}\item 
struct \hyperlink{structcarl_1_1_intersection_data}{Intersection\+Data}
\item 
struct \hyperlink{structcarl_1_1libmesh__apply__solution__input__params}{libmesh\+\_\+apply\+\_\+solution\+\_\+input\+\_\+params}
\item 
class \hyperlink{classcarl_1_1lib_mesh__fe__addresses__3}{lib\+Mesh\+\_\+fe\+\_\+addresses\+\_\+3}
\item 
struct \hyperlink{structcarl_1_1libmesh__solve__linear__system__input__params}{libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params}
\item 
class \hyperlink{classcarl_1_1_mesh___intersection}{Mesh\+\_\+\+Intersection}
\begin{DoxyCompactList}\small\item\em Class used to construct the intersection meshes. \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1_mesh__restriction}{Mesh\+\_\+restriction}
\begin{DoxyCompactList}\small\item\em Class used to build a restriction of a parent mesh to the coupling region. \end{DoxyCompactList}\item 
struct \hyperlink{structcarl_1_1parallel__intersection__params}{parallel\+\_\+intersection\+\_\+params}
\begin{DoxyCompactList}\small\item\em Structure containing the parameters for the parallel intersection search test program (source\+: \hyperlink{_c_arl__build__intersections_8cpp}{C\+Arl\+\_\+build\+\_\+intersections.\+cpp}) \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1_patch__construction}{Patch\+\_\+construction}
\begin{DoxyCompactList}\small\item\em Class used to build a mesh patch from a parent mesh and an coupling mesh element. \end{DoxyCompactList}\item 
struct \hyperlink{structcarl_1_1_point_hash__3_d}{Point\+Hash\+\_\+3\+D}
\item 
struct \hyperlink{structcarl_1_1_point_hash__3_d___equal}{Point\+Hash\+\_\+3\+D\+\_\+\+Equal}
\item 
class \hyperlink{classcarl_1_1_solver___files___setup}{Solver\+\_\+\+Files\+\_\+\+Setup}
\item 
class \hyperlink{classcarl_1_1_stitch___meshes}{Stitch\+\_\+\+Meshes}
\begin{DoxyCompactList}\small\item\em Class used to stitch together different meshes. \end{DoxyCompactList}\item 
class \hyperlink{classcarl_1_1weight__parameter__function}{weight\+\_\+parameter\+\_\+function}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1}{Cluster\+Scheduler\+Type} \{ \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{L\+O\+C\+A\+L} = 0, 
\hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{P\+B\+S} = 1, 
\hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{S\+L\+U\+R\+M} = 2
 \}
\item 
enum \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08}{Ext\+Solver\+Type} \{ \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}{L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R} = 0, 
\hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08ad129ac6d9556cbd33f5ed9828309b941}{D\+U\+M\+M\+Y} = 1
 \}
\item 
enum \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718e}{Mediator\+Type} \{ \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eae0a6a4791f68baefa4702e4f053b2817}{U\+S\+E\+\_\+\+M\+A\+C\+R\+O} = 0, 
\hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eaaeaede2dff7ae7d5633a316f0fbc3151}{U\+S\+E\+\_\+\+M\+I\+C\+R\+O} = 1, 
\hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718ea844f8756d38d977d6db2f10c3d3bb7c6}{U\+S\+E\+\_\+\+E\+X\+T\+E\+R\+N\+A\+L} = 2
 \}
\item 
enum \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8}{Base\+C\+G\+Precond\+Type} \{ \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{N\+O\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+O\+N\+E\+R} = 0, 
\hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R} = 1, 
\hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+J\+A\+C\+O\+B\+I} = 2
 \}
\item 
enum \hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccb}{Iteration\+Status} \{ \hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccbace49062f1507d7b0433fc456c23e4756}{I\+T\+E\+R\+A\+T\+I\+N\+G} = 0, 
\hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccba2c1bef9620cec3d07740e836d7f8f595}{D\+I\+V\+E\+R\+G\+E\+D} = 1, 
\hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccba46a5716c46e8a291122aa4f547eeded7}{C\+O\+N\+V\+E\+R\+G\+E\+D} = 2
 \}
\item 
enum \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cf}{Intersection\+Meshing\+Method} \{ \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa0a91b3dbac7fab7e5efa6f804aab8f58}{L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N} = 0, 
\hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa509162a828acac7eaad1fc369696a3b1}{C\+G\+A\+L} = 1
 \}
\item 
enum \hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7}{Search\+Method} \{ \hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a795a195e14566a465c90e47e4f389447}{B\+R\+U\+T\+E} = 0, 
\hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7af5458c8a9b1cd8aa10c970b4d4853bbb}{F\+R\+O\+N\+T} = 1, 
\hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a627ddde9718f452847bda05968663a7c}{B\+O\+T\+H} = 2
 \}
\item 
enum \hyperlink{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44}{R\+B\+Modes\+System} \{ \hyperlink{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44a89dfe28eb7e2ec6f69d9225e76e5d693}{M\+A\+C\+R\+O} = 0, 
\hyperlink{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44aa02bb02d7913ce277be19729cb0ec1d6}{M\+I\+C\+R\+O} = 1
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespacecarl_aba5c04efa5a0abae78d3efd00ae694e3}{get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1coupling__assemble__coupling__input__params}{coupling\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the construction of the coupling matrices. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_a902f88f3c52c6fc9c974bc99832e78a7}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1feti__iterate__params}{feti\+\_\+iterate\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the coupled solver test programs. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_a177d464e2a8ca02ee332afc410ec061d}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1feti__set__sol__params}{feti\+\_\+set\+\_\+sol\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the coupled solver test programs. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_afe02e73d82d3c09395afe0e786840369}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1feti__setup__finish__params}{feti\+\_\+setup\+\_\+finish\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the coupled solver test programs. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_a35e71784d7728be3e70e52362caeb2e2}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1feti__setup__init__params}{feti\+\_\+setup\+\_\+init\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the coupled solver test programs. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_aebc298614cba13aa318064e3ad08bc10}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1carl__mult__coupling__input__params}{carl\+\_\+mult\+\_\+coupling\+\_\+input\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the coupling matrix multiplication operation. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_ab80eec3eb20ff6a403ad01bafa649df2}{get\+\_\+intersection\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1parallel__intersection__params}{parallel\+\_\+intersection\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the parallel intersection search program (source\+: \hyperlink{_c_arl__build__intersections_8cpp}{C\+Arl\+\_\+build\+\_\+intersections.\+cpp}) \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_a2b7d0a416cdffe9589a3912c1f4ef20b}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1libmesh__solve__linear__system__input__params}{libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for the coupled solver test programs. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_ada1b77b2d0f0c7274a9457ba20e16a68}{print\+\_\+input\+\_\+params} (const std\+::string \&output\+\_\+filename, \hyperlink{structcarl_1_1libmesh__solve__linear__system__input__params}{libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Function used to generate a solver input file from \char`\"{}input\+\_\+params\char`\"{}. \end{DoxyCompactList}\item 
void \hyperlink{namespacecarl_a3e93400b1873e44916865a36944134fa}{get\+\_\+input\+\_\+params} (Get\+Pot \&field\+\_\+parser, \hyperlink{structcarl_1_1libmesh__apply__solution__input__params}{libmesh\+\_\+apply\+\_\+solution\+\_\+input\+\_\+params} \&input\+\_\+params)
\begin{DoxyCompactList}\small\item\em Parser function for mesh deformation (apply solution) programs. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacecarl_a855a8c682ef0ee0a35f987e051d2bbf2}{Cluster\+Scheduler\+Type\+\_\+to\+\_\+string} (\hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1}{Cluster\+Scheduler\+Type} input)
\item 
std\+::string \hyperlink{namespacecarl_ae4298594b456c7d030d5be6868d6dc63}{Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string} (\hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8}{Base\+C\+G\+Precond\+Type} input)
\item 
std\+::string \hyperlink{namespacecarl_a2df653606e38410b38a938470c3b7fd3}{Ext\+Solver\+Type\+\_\+to\+\_\+string} (\hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08}{Ext\+Solver\+Type} input)
\item 
std\+::string \hyperlink{namespacecarl_a54249fee021b3d53e1a7ae7208292437}{exec\+\_\+command} (const std\+::string \&cmd)
\item 
void \hyperlink{namespacecarl_a543276bdc1b659a9373b4255892b7174}{invert\+\_\+index\+\_\+unordered\+\_\+map} (const std\+::unordered\+\_\+map$<$ int, int $>$ \&input\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&output\+\_\+map)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacecarl_a48bf9a2c641710d703991550fc480884}{jump\+\_\+lines} (T \&filestream, unsigned int number\+Of\+Lines=1)
\item 
int \hyperlink{namespacecarl_a3e28e30c4315c39fbddd46af79018d51}{voigt\+\_\+index\+\_\+converter} (int aaa, int bbb)
\item 
void \hyperlink{namespacecarl_a87ce5fcb102a26f69dbef740667eb08b}{print\+\_\+stats\+\_\+to\+\_\+file} (std\+::vector$<$ double $>$ \&vec\+\_\+data, const std\+::string filename)
\item 
{\footnotesize template$<$typename Sys $>$ }\\void \hyperlink{namespacecarl_a8b8d75f4ab54390f3e7c607ed4f0cf19}{reduced\+\_\+system\+\_\+init} (Sys \&system\+\_\+input)
\item 
void \hyperlink{namespacecarl_aab1c0aca80d848937579e63a21c9a270}{set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx} (std\+::string \&filename, int \&domain\+\_\+\+Idx\+\_\+\+B\+I\+G, int \&nb\+\_\+of\+\_\+domain\+\_\+\+Idx\+\_\+micro, std\+::vector$<$ int $>$ \&domain\+\_\+\+Idx\+\_\+micro, std\+::vector$<$ int $>$ \&domain\+\_\+\+Idx\+\_\+coupling)
\item 
void \hyperlink{namespacecarl_ada178344184a369ba2db2926999a7446}{build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const std\+::string \&intersection\+\_\+full\+\_\+table\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, std\+::vector$<$ \hyperlink{structcarl_1_1_intersection_data}{carl\+::\+Intersection\+Data} $>$ \&intersection\+\_\+full\+\_\+table, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+A\+\_\+to\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+B\+\_\+to\+\_\+\+B)
\item 
void \hyperlink{namespacecarl_a8aedfd6e81c99d9651093ff26b9c5a55}{generate\+\_\+intersection\+\_\+tables\+\_\+partial} (std\+::string \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B\+\_\+\+Filename, std\+::string \&intersection\+\_\+table\+\_\+\+I\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+restrict\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+micro\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+inter\+\_\+\+Elem\+Map, std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&intersection\+\_\+table\+\_\+\+I)
\item 
void \hyperlink{namespacecarl_ac207572d2bb1b2f6558bbb96bfa89edc}{generate\+\_\+intersection\+\_\+tables\+\_\+full} (std\+::string \&equivalence\+\_\+table\+\_\+restrict\+\_\+\+A\+\_\+\+Filename, std\+::string \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B\+\_\+\+Filename, std\+::string \&intersection\+\_\+table\+\_\+\+I\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+restrict\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+micro\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+\+B\+I\+G\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+inter\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+restrict\+\_\+\+A, std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&intersection\+\_\+table\+\_\+\+I)
\item 
void \hyperlink{namespacecarl_a995bb6a3c01d8cede8268c2f39ce0768}{set\+\_\+equivalence\+\_\+tables} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+A\+\_\+to\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+B\+\_\+to\+\_\+\+B)
\item 
void \hyperlink{namespacecarl_a17eb70b3f2c2574e7b3085108205e38c}{set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table} (const std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+pairs\+\_\+map, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map)
\item 
void \hyperlink{namespacecarl_a0fef8616ca5e61709ef9a013c8a2ee43}{set\+\_\+full\+\_\+intersection\+\_\+tables} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const std\+::string \&intersection\+\_\+full\+\_\+table\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&full\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)
\item 
void \hyperlink{namespacecarl_a880bd07cae964f085e21e5ac75ede10d}{set\+\_\+intersection\+\_\+tables} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const lib\+Mesh\+::\+Mesh \&mesh\+\_\+intersection, const std\+::string \&intersection\+\_\+full\+\_\+table\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)
\item 
void \hyperlink{namespacecarl_aeceaf9a878847b9ea2f623aa51e3b392}{read\+\_\+local\+\_\+intersection\+\_\+tables} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const std\+::string \&intersection\+\_\+local\+\_\+table\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)
\item 
void \hyperlink{namespacecarl_a8d1c90daac3238ed5d53465740e072b3}{set\+\_\+local\+\_\+intersection\+\_\+tables} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const lib\+Mesh\+::\+Mesh \&mesh\+\_\+intersection, const std\+::string \&intersection\+\_\+local\+\_\+table\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)
\item 
void \hyperlink{namespacecarl_ab4df2c3a7c53c68fc2628569f4b4bd17}{set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, const std\+::string \&intersection\+\_\+global\+\_\+table\+\_\+\+Filename, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+system\+\_\+to\+\_\+mediator, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+mediator\+\_\+to\+\_\+system, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&inter\+\_\+mediator\+\_\+\+A, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&inter\+\_\+mediator\+\_\+\+B)
\item 
void \hyperlink{namespacecarl_ad1869df8fcc16b806a4c0b262922672f}{repartition\+\_\+system\+\_\+meshes} (const lib\+Mesh\+::\+Parallel\+::\+Communicator \&World\+Comm, lib\+Mesh\+::\+Mesh \&mesh\+\_\+input, lib\+Mesh\+::\+Mesh \&mesh\+\_\+intersect, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+pairs\+\_\+map, bool b\+Use\+Second=true)
\item 
void \hyperlink{namespacecarl_a9709628dd76d2b74384c5f82d77b3dda}{broadcast\+\_\+index\+\_\+unordered\+\_\+map} (std\+::unordered\+\_\+map$<$ int, int $>$ \&index\+\_\+map, const lib\+Mesh\+::\+Parallel\+::\+Communicator \&Comm\+Comm, int origin\+\_\+rank=0)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{namespacecarl_a461e9a455e02d991c920b4b56390f326}{M\+P\+I\+\_\+reduce\+\_\+vector} (std\+::vector$<$ T $>$ \&r, int root, const lib\+Mesh\+::\+Parallel\+::\+Communicator \&Comm)
\item 
void \hyperlink{namespacecarl_a21d667c7247b6c0f71917b99c39c50e6}{lump\+\_\+matrix} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Input, lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Output)
\item 
void \hyperlink{namespacecarl_a22f4ac1dab8f592b86201d3fec77b7f7}{lump\+\_\+matrix\+\_\+and\+\_\+invert} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Input, lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Output)
\item 
void \hyperlink{namespacecarl_aeb8a38b6b56135f6099cce3470494b23}{lump\+\_\+matrix\+\_\+and\+\_\+invert} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Input, lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&vec\+Output)
\item 
void \hyperlink{namespacecarl_acf412e8527bfd67e81b80b71bf3bb479}{print\+\_\+matrix} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&Coupling\+Test\+Matrix)
\item 
void \hyperlink{namespacecarl_a8ab4aecb3273c14a472f00cc892f95a0}{print\+\_\+matrix\+\_\+dim} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&Coupling\+Test\+Matrix, bool b\+Detailed=false)
\item 
void \hyperlink{namespacecarl_a090760429d54397a47cdf55a73dcf078}{print\+\_\+matrix\+\_\+info} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&Input\+Matrix, std\+::ostream \&os=lib\+Mesh\+::out)
\item 
void \hyperlink{namespacecarl_a074f0090ce9738ac74ffc852f11f9126}{print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&Coupling\+Test\+Matrix, const std\+::string name\+\_\+base)
\item 
void \hyperlink{namespacecarl_a3c2be3b1f2d9ee68d43525da24e1751b}{print\+\_\+matrix\+\_\+matlab} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&Coupling\+Test\+Matrix, const std\+::string name\+\_\+base)
\item 
void \hyperlink{namespacecarl_a728a8e1963352c97d71b9c3dec0c2244}{solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&A, lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&b, lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&x, K\+S\+P \&ksp, P\+C \&pc)
\item 
void \hyperlink{namespacecarl_a2a42a81e2c9cc6e97c90f5960e5f1048}{check\+\_\+coupling\+\_\+matrix} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&Coupling\+Test\+Matrix, lib\+Mesh\+::\+Mesh \&Intersection\+Mesh, lib\+Mesh\+::\+Real Coupling\+Scale, const std\+::string matrixtype, int n\+\_\+var=3)
\item 
void \hyperlink{namespacecarl_a1632084ec1f296b63559648cc9c2047f}{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector} (lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+vec, const std\+::string \&filename, int dim=1)
\item 
void \hyperlink{namespacecarl_a4d0e2c60b0765dc8182c95362c5d329a}{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector} (lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+vec, const std\+::string \&filename)
\item 
void \hyperlink{namespacecarl_a2405b7b44a0806d66bced8d0905dcb04}{print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector} (lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+vec, const std\+::string \&filename)
\item 
void \hyperlink{namespacecarl_a228d257ed2972e42a0468d2d82eb93f9}{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector} (Vec input\+\_\+vec, const std\+::string \&filename, int rank, M\+P\+I\+\_\+\+Comm comm=P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D, int dim=1)
\item 
void \hyperlink{namespacecarl_afa5184a7f34cda31fcafd0bae53a17bd}{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector} (Vec input\+\_\+vec, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)
\item 
void \hyperlink{namespacecarl_a431936850bf5712121d8399ddbd76aa8}{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix} (Mat input\+\_\+mat, const std\+::string \&filename, int rank, M\+P\+I\+\_\+\+Comm comm=P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D, int dim=1)
\item 
void \hyperlink{namespacecarl_aa6ac21d50301de8b7b50b23b4e4600e3}{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+mat, const std\+::string \&filename, int dim=1)
\item 
void \hyperlink{namespacecarl_ac9086ba3b6072efdbafaaa5ae53927de}{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix} (Mat input\+\_\+mat, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)
\item 
void \hyperlink{namespacecarl_ade169f15d51d4644e74276d155002f22}{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+mat, const std\+::string \&filename)
\item 
void \hyperlink{namespacecarl_a25d36e4c1615382a1832d73c716599db}{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B} (Vec input\+\_\+vec, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)
\item 
void \hyperlink{namespacecarl_a1f15b2a953f4af7763e81b5f86505d6d}{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B} (Mat input\+\_\+mat, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)
\item 
void \hyperlink{namespacecarl_ab3dd1aab6c2bea1fcbb086eb6aff4d16}{attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors} (lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&mat\+\_\+sys, const std\+::string \&filename\+\_\+base, int nb\+\_\+of\+\_\+vecs, int dimension)
\item 
void \hyperlink{namespacecarl_a40b4ba8a31197c1df5e1aa3438a46852}{create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors} (const Vec $\ast$vecs\+\_\+in, int nb\+\_\+vecs, Mat \&matrix\+\_\+out)
\item 
void \hyperlink{namespacecarl_aa3e9c0c8132625807ce645c290edf17f}{P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix} (Mat \&matrix\+\_\+in, Mat \&matrix\+\_\+out)
\item 
void \hyperlink{namespacecarl_a561696085e75f9b5013bf61e2ef3de9f}{P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast} (Mat mat\+\_\+seq, Vec vec\+\_\+seq\+\_\+in, Vec vec\+\_\+seq\+\_\+out, double a\+\_\+const)
\end{DoxyCompactItemize}


\subsection{Enumeration Type Documentation}
\hypertarget{namespacecarl_ad52f21755b51ffa926038b59ae194ea8}{}\index{carl@{carl}!Base\+C\+G\+Precond\+Type@{Base\+C\+G\+Precond\+Type}}
\index{Base\+C\+G\+Precond\+Type@{Base\+C\+G\+Precond\+Type}!carl@{carl}}
\subsubsection[{Base\+C\+G\+Precond\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Base\+C\+G\+Precond\+Type}}\label{namespacecarl_ad52f21755b51ffa926038b59ae194ea8}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+O\+N\+E\+R@{N\+O\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+O\+N\+E\+R}!carl@{carl}}\index{carl@{carl}!N\+O\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+O\+N\+E\+R@{N\+O\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+O\+N\+E\+R}}\item[{\em 
\hypertarget{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{}N\+O\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+O\+N\+E\+R\label{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}
}]\index{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R@{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R}!carl@{carl}}\index{carl@{carl}!C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R@{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R}}\item[{\em 
\hypertarget{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{}C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+O\+P\+E\+R\+A\+T\+O\+R\label{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}
}]\index{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+J\+A\+C\+O\+B\+I@{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+J\+A\+C\+O\+B\+I}!carl@{carl}}\index{carl@{carl}!C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+J\+A\+C\+O\+B\+I@{C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+J\+A\+C\+O\+B\+I}}\item[{\em 
\hypertarget{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{}C\+O\+U\+P\+L\+I\+N\+G\+\_\+\+J\+A\+C\+O\+B\+I\label{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}
}]\end{description}
\end{Desc}


Definition at line 35 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
35                        \{
36     \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{NO\_PRECONDITIONER} = 0, \textcolor{comment}{// Identity matrix}
37     \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{COUPLING\_OPERATOR} = 1, \textcolor{comment}{// C\_RR}
38     \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{COUPLING\_JACOBI} = 2 \textcolor{comment}{// diagonal(C\_RR)}
39 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1}{}\index{carl@{carl}!Cluster\+Scheduler\+Type@{Cluster\+Scheduler\+Type}}
\index{Cluster\+Scheduler\+Type@{Cluster\+Scheduler\+Type}!carl@{carl}}
\subsubsection[{Cluster\+Scheduler\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Cluster\+Scheduler\+Type}}\label{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{L\+O\+C\+A\+L@{L\+O\+C\+A\+L}!carl@{carl}}\index{carl@{carl}!L\+O\+C\+A\+L@{L\+O\+C\+A\+L}}\item[{\em 
\hypertarget{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{}L\+O\+C\+A\+L\label{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}
}]\index{P\+B\+S@{P\+B\+S}!carl@{carl}}\index{carl@{carl}!P\+B\+S@{P\+B\+S}}\item[{\em 
\hypertarget{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{}P\+B\+S\label{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}
}]\index{S\+L\+U\+R\+M@{S\+L\+U\+R\+M}!carl@{carl}}\index{carl@{carl}!S\+L\+U\+R\+M@{S\+L\+U\+R\+M}}\item[{\em 
\hypertarget{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{}S\+L\+U\+R\+M\label{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}
}]\end{description}
\end{Desc}


Definition at line 14 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
14                           \{
15     \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{LOCAL} = 0, \textcolor{comment}{// No scheduler present, will use carl::exec\_command}
16     \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{PBS} = 1, \textcolor{comment}{// PBS / Torque}
17     \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{SLURM} = 2 \textcolor{comment}{// SLURM, not implemented right now}
18 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a384c8e69965cba9e6e52667c8cefff08}{}\index{carl@{carl}!Ext\+Solver\+Type@{Ext\+Solver\+Type}}
\index{Ext\+Solver\+Type@{Ext\+Solver\+Type}!carl@{carl}}
\subsubsection[{Ext\+Solver\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Ext\+Solver\+Type}}\label{namespacecarl_a384c8e69965cba9e6e52667c8cefff08}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R@{L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R}!carl@{carl}}\index{carl@{carl}!L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R@{L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R}}\item[{\em 
\hypertarget{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}{}L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R\label{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}
}]\index{D\+U\+M\+M\+Y@{D\+U\+M\+M\+Y}!carl@{carl}}\index{carl@{carl}!D\+U\+M\+M\+Y@{D\+U\+M\+M\+Y}}\item[{\em 
\hypertarget{namespacecarl_a384c8e69965cba9e6e52667c8cefff08ad129ac6d9556cbd33f5ed9828309b941}{}D\+U\+M\+M\+Y\label{namespacecarl_a384c8e69965cba9e6e52667c8cefff08ad129ac6d9556cbd33f5ed9828309b941}
}]\end{description}
\end{Desc}


Definition at line 22 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
22                    \{
23     \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}{LIBMESH\_LINEAR} = 0,
24     \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08ad129ac6d9556cbd33f5ed9828309b941}{DUMMY} = 1
25 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cf}{}\index{carl@{carl}!Intersection\+Meshing\+Method@{Intersection\+Meshing\+Method}}
\index{Intersection\+Meshing\+Method@{Intersection\+Meshing\+Method}!carl@{carl}}
\subsubsection[{Intersection\+Meshing\+Method}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Intersection\+Meshing\+Method}}\label{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cf}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N@{L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N}!carl@{carl}}\index{carl@{carl}!L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N@{L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N}}\item[{\em 
\hypertarget{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa0a91b3dbac7fab7e5efa6f804aab8f58}{}L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N\label{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa0a91b3dbac7fab7e5efa6f804aab8f58}
}]\index{C\+G\+A\+L@{C\+G\+A\+L}!carl@{carl}}\index{carl@{carl}!C\+G\+A\+L@{C\+G\+A\+L}}\item[{\em 
\hypertarget{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa509162a828acac7eaad1fc369696a3b1}{}C\+G\+A\+L\label{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa509162a828acac7eaad1fc369696a3b1}
}]\end{description}
\end{Desc}


Definition at line 47 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
47                                \{
48     \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa0a91b3dbac7fab7e5efa6f804aab8f58}{LIBMESH\_TETGEN} = 0, \textcolor{comment}{// libMesh Tetgen algorithm, problematic with}
49                         \textcolor{comment}{// Intel compilers}
50     \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa509162a828acac7eaad1fc369696a3b1}{CGAL} = 1            \textcolor{comment}{// Intersection meshing algorithm using}
51                         \textcolor{comment}{// CGAL's Triangulation\_3}
52 \};
\end{DoxyCode}
\hypertarget{namespacecarl_aa16a7148474e795cb6fea24b9159dccb}{}\index{carl@{carl}!Iteration\+Status@{Iteration\+Status}}
\index{Iteration\+Status@{Iteration\+Status}!carl@{carl}}
\subsubsection[{Iteration\+Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Iteration\+Status}}\label{namespacecarl_aa16a7148474e795cb6fea24b9159dccb}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{I\+T\+E\+R\+A\+T\+I\+N\+G@{I\+T\+E\+R\+A\+T\+I\+N\+G}!carl@{carl}}\index{carl@{carl}!I\+T\+E\+R\+A\+T\+I\+N\+G@{I\+T\+E\+R\+A\+T\+I\+N\+G}}\item[{\em 
\hypertarget{namespacecarl_aa16a7148474e795cb6fea24b9159dccbace49062f1507d7b0433fc456c23e4756}{}I\+T\+E\+R\+A\+T\+I\+N\+G\label{namespacecarl_aa16a7148474e795cb6fea24b9159dccbace49062f1507d7b0433fc456c23e4756}
}]\index{D\+I\+V\+E\+R\+G\+E\+D@{D\+I\+V\+E\+R\+G\+E\+D}!carl@{carl}}\index{carl@{carl}!D\+I\+V\+E\+R\+G\+E\+D@{D\+I\+V\+E\+R\+G\+E\+D}}\item[{\em 
\hypertarget{namespacecarl_aa16a7148474e795cb6fea24b9159dccba2c1bef9620cec3d07740e836d7f8f595}{}D\+I\+V\+E\+R\+G\+E\+D\label{namespacecarl_aa16a7148474e795cb6fea24b9159dccba2c1bef9620cec3d07740e836d7f8f595}
}]\index{C\+O\+N\+V\+E\+R\+G\+E\+D@{C\+O\+N\+V\+E\+R\+G\+E\+D}!carl@{carl}}\index{carl@{carl}!C\+O\+N\+V\+E\+R\+G\+E\+D@{C\+O\+N\+V\+E\+R\+G\+E\+D}}\item[{\em 
\hypertarget{namespacecarl_aa16a7148474e795cb6fea24b9159dccba46a5716c46e8a291122aa4f547eeded7}{}C\+O\+N\+V\+E\+R\+G\+E\+D\label{namespacecarl_aa16a7148474e795cb6fea24b9159dccba46a5716c46e8a291122aa4f547eeded7}
}]\end{description}
\end{Desc}


Definition at line 41 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
41                      \{
42     \hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccbace49062f1507d7b0433fc456c23e4756}{ITERATING} = 0,
43     \hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccba2c1bef9620cec3d07740e836d7f8f595}{DIVERGED} = 1,
44     \hyperlink{namespacecarl_aa16a7148474e795cb6fea24b9159dccba46a5716c46e8a291122aa4f547eeded7}{CONVERGED} = 2
45 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ab4549821791d976a4bb9a3460fe1718e}{}\index{carl@{carl}!Mediator\+Type@{Mediator\+Type}}
\index{Mediator\+Type@{Mediator\+Type}!carl@{carl}}
\subsubsection[{Mediator\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Mediator\+Type}}\label{namespacecarl_ab4549821791d976a4bb9a3460fe1718e}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{U\+S\+E\+\_\+\+M\+A\+C\+R\+O@{U\+S\+E\+\_\+\+M\+A\+C\+R\+O}!carl@{carl}}\index{carl@{carl}!U\+S\+E\+\_\+\+M\+A\+C\+R\+O@{U\+S\+E\+\_\+\+M\+A\+C\+R\+O}}\item[{\em 
\hypertarget{namespacecarl_ab4549821791d976a4bb9a3460fe1718eae0a6a4791f68baefa4702e4f053b2817}{}U\+S\+E\+\_\+\+M\+A\+C\+R\+O\label{namespacecarl_ab4549821791d976a4bb9a3460fe1718eae0a6a4791f68baefa4702e4f053b2817}
}]\index{U\+S\+E\+\_\+\+M\+I\+C\+R\+O@{U\+S\+E\+\_\+\+M\+I\+C\+R\+O}!carl@{carl}}\index{carl@{carl}!U\+S\+E\+\_\+\+M\+I\+C\+R\+O@{U\+S\+E\+\_\+\+M\+I\+C\+R\+O}}\item[{\em 
\hypertarget{namespacecarl_ab4549821791d976a4bb9a3460fe1718eaaeaede2dff7ae7d5633a316f0fbc3151}{}U\+S\+E\+\_\+\+M\+I\+C\+R\+O\label{namespacecarl_ab4549821791d976a4bb9a3460fe1718eaaeaede2dff7ae7d5633a316f0fbc3151}
}]\index{U\+S\+E\+\_\+\+E\+X\+T\+E\+R\+N\+A\+L@{U\+S\+E\+\_\+\+E\+X\+T\+E\+R\+N\+A\+L}!carl@{carl}}\index{carl@{carl}!U\+S\+E\+\_\+\+E\+X\+T\+E\+R\+N\+A\+L@{U\+S\+E\+\_\+\+E\+X\+T\+E\+R\+N\+A\+L}}\item[{\em 
\hypertarget{namespacecarl_ab4549821791d976a4bb9a3460fe1718ea844f8756d38d977d6db2f10c3d3bb7c6}{}U\+S\+E\+\_\+\+E\+X\+T\+E\+R\+N\+A\+L\label{namespacecarl_ab4549821791d976a4bb9a3460fe1718ea844f8756d38d977d6db2f10c3d3bb7c6}
}]\end{description}
\end{Desc}


Definition at line 28 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
28                   \{
29     \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eae0a6a4791f68baefa4702e4f053b2817}{USE\_MACRO} = 0,
30     \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eaaeaede2dff7ae7d5633a316f0fbc3151}{USE\_MICRO} = 1,
31     \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718ea844f8756d38d977d6db2f10c3d3bb7c6}{USE\_EXTERNAL} = 2
32 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44}{}\index{carl@{carl}!R\+B\+Modes\+System@{R\+B\+Modes\+System}}
\index{R\+B\+Modes\+System@{R\+B\+Modes\+System}!carl@{carl}}
\subsubsection[{R\+B\+Modes\+System}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+R\+B\+Modes\+System}}\label{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{M\+A\+C\+R\+O@{M\+A\+C\+R\+O}!carl@{carl}}\index{carl@{carl}!M\+A\+C\+R\+O@{M\+A\+C\+R\+O}}\item[{\em 
\hypertarget{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44a89dfe28eb7e2ec6f69d9225e76e5d693}{}M\+A\+C\+R\+O\label{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44a89dfe28eb7e2ec6f69d9225e76e5d693}
}]\index{M\+I\+C\+R\+O@{M\+I\+C\+R\+O}!carl@{carl}}\index{carl@{carl}!M\+I\+C\+R\+O@{M\+I\+C\+R\+O}}\item[{\em 
\hypertarget{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44aa02bb02d7913ce277be19729cb0ec1d6}{}M\+I\+C\+R\+O\label{namespacecarl_a356b58f8ae262a4fd4359f513c1aaf44aa02bb02d7913ce277be19729cb0ec1d6}
}]\end{description}
\end{Desc}


Definition at line 61 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
61                    \{
62     \hyperlink{ext__solver__libmesh__enums_8h_acc44f45992a493fb31c90d260d4ab83fa3d1738a931468da77c233f1126436b81}{MACRO} = 0,
63     \hyperlink{ext__solver__libmesh__enums_8h_acc44f45992a493fb31c90d260d4ab83fa44fead913cf8397fe4cf15b7c8962a8f}{MICRO} = 1
64 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7}{}\index{carl@{carl}!Search\+Method@{Search\+Method}}
\index{Search\+Method@{Search\+Method}!carl@{carl}}
\subsubsection[{Search\+Method}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf carl\+::\+Search\+Method}}\label{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{B\+R\+U\+T\+E@{B\+R\+U\+T\+E}!carl@{carl}}\index{carl@{carl}!B\+R\+U\+T\+E@{B\+R\+U\+T\+E}}\item[{\em 
\hypertarget{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a795a195e14566a465c90e47e4f389447}{}B\+R\+U\+T\+E\label{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a795a195e14566a465c90e47e4f389447}
}]\index{F\+R\+O\+N\+T@{F\+R\+O\+N\+T}!carl@{carl}}\index{carl@{carl}!F\+R\+O\+N\+T@{F\+R\+O\+N\+T}}\item[{\em 
\hypertarget{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7af5458c8a9b1cd8aa10c970b4d4853bbb}{}F\+R\+O\+N\+T\label{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7af5458c8a9b1cd8aa10c970b4d4853bbb}
}]\index{B\+O\+T\+H@{B\+O\+T\+H}!carl@{carl}}\index{carl@{carl}!B\+O\+T\+H@{B\+O\+T\+H}}\item[{\em 
\hypertarget{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a627ddde9718f452847bda05968663a7c}{}B\+O\+T\+H\label{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a627ddde9718f452847bda05968663a7c}
}]\end{description}
\end{Desc}


Definition at line 54 of file common\+\_\+enums.\+h.


\begin{DoxyCode}
55 \{
56     \hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a795a195e14566a465c90e47e4f389447}{BRUTE} = 0,
57     \hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7af5458c8a9b1cd8aa10c970b4d4853bbb}{FRONT} = 1,
58     \hyperlink{namespacecarl_a2c9d0282cb533624e034ccc1d7b629c7a627ddde9718f452847bda05968663a7c}{BOTH} = 2
59 \};
\end{DoxyCode}


\subsection{Function Documentation}
\hypertarget{namespacecarl_ab3dd1aab6c2bea1fcbb086eb6aff4d16}{}\index{carl@{carl}!attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors@{attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors}}
\index{attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors@{attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors}!carl@{carl}}
\subsubsection[{attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&mat\+\_\+sys, const std\+::string \&filename\+\_\+base, int nb\+\_\+of\+\_\+vecs, int dimension)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::attach\+\_\+rigid\+\_\+body\+\_\+mode\+\_\+vectors (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{mat\+\_\+sys, }
\item[{const std\+::string \&}]{filename\+\_\+base, }
\item[{int}]{nb\+\_\+of\+\_\+vecs, }
\item[{int}]{dimension}
\end{DoxyParamCaption}
)}\label{namespacecarl_ab3dd1aab6c2bea1fcbb086eb6aff4d16}


Definition at line 383 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
385 \{
386     \textcolor{comment}{// Read the dummy vector}
387     Vec rb\_vecs[6];
388 
389     PetscInt local\_N;
390     MatGetLocalSize(mat\_sys.mat(),NULL,&local\_N);
391 
392     std::string vector\_path;
393 
394     \textcolor{comment}{// Read the vectors}
395     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nb\_of\_vecs; ++iii)
396     \{
397         VecCreate(mat\_sys.comm().get(),&rb\_vecs[iii]);
398         VecSetSizes(rb\_vecs[iii],local\_N,mat\_sys.n());
399 
400         vector\_path = filename\_base + \textcolor{stringliteral}{"\_"} + std::to\_string(iii) + \textcolor{stringliteral}{"\_n\_"} + std::to\_string(nb\_of\_vecs) + \textcolor{stringliteral}{"
      .petscvec"};
401         \hyperlink{namespacecarl_a4d0e2c60b0765dc8182c95362c5d329a}{read\_PETSC\_vector}(rb\_vecs[iii],vector\_path,mat\_sys.comm().get());
402     \}
403 
404     MatNullSpace nullsp\_sys;
405     MatNullSpaceCreate(mat\_sys.comm().get(), PETSC\_FALSE, nb\_of\_vecs, rb\_vecs, &nullsp\_sys);
406     MatSetNullSpace(mat\_sys.mat(),nullsp\_sys);
407 
408     MatNullSpaceDestroy(&nullsp\_sys);
409     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nb\_of\_vecs; ++iii)
410     \{
411         VecDestroy(&rb\_vecs[iii]);
412     \}
413 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ae4298594b456c7d030d5be6868d6dc63}{}\index{carl@{carl}!Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string@{Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string}}
\index{Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string@{Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string}!carl@{carl}}
\subsubsection[{Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string(\+Base\+C\+G\+Precond\+Type input)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string carl\+::\+Base\+C\+G\+Precond\+Type\+\_\+to\+\_\+string (
\begin{DoxyParamCaption}
\item[{{\bf Base\+C\+G\+Precond\+Type}}]{input}
\end{DoxyParamCaption}
)}\label{namespacecarl_ae4298594b456c7d030d5be6868d6dc63}


Definition at line 27 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
28 \{
29     \textcolor{keywordflow}{switch} (input)
30     \{
31         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{BaseCGPrecondType::NO\_PRECONDITIONER} : \textcolor{keywordflow}{return} \textcolor{stringliteral}{"NONE"};
32                         \textcolor{keywordflow}{break};
33 
34         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{BaseCGPrecondType::COUPLING\_OPERATOR} : \textcolor{keywordflow}{return} \textcolor{stringliteral}{"
      Coupling\_operator"};
35                         \textcolor{keywordflow}{break};
36 
37         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{BaseCGPrecondType::COUPLING\_JACOBI} : \textcolor{keywordflow}{return} \textcolor{stringliteral}{"
      Coupling\_operator\_jacobi"};
38                         \textcolor{keywordflow}{break};
39     \}
40 
41     \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid enumerate argument!"});
42     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
43 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a9709628dd76d2b74384c5f82d77b3dda}{}\index{carl@{carl}!broadcast\+\_\+index\+\_\+unordered\+\_\+map@{broadcast\+\_\+index\+\_\+unordered\+\_\+map}}
\index{broadcast\+\_\+index\+\_\+unordered\+\_\+map@{broadcast\+\_\+index\+\_\+unordered\+\_\+map}!carl@{carl}}
\subsubsection[{broadcast\+\_\+index\+\_\+unordered\+\_\+map(std\+::unordered\+\_\+map$<$ int, int $>$ \&index\+\_\+map, const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+Comm\+Comm, int origin\+\_\+rank=0)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::broadcast\+\_\+index\+\_\+unordered\+\_\+map (
\begin{DoxyParamCaption}
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{index\+\_\+map, }
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{Comm\+Comm, }
\item[{int}]{origin\+\_\+rank = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a9709628dd76d2b74384c5f82d77b3dda}


Definition at line 3 of file mpi\+\_\+carl\+\_\+tools.\+cpp.


\begin{DoxyCode}
7 \{
8     \textcolor{keywordtype}{int} rank = CommComm.rank();
9     \textcolor{keywordtype}{int} dummy\_vector\_size = -1;
10     std::vector<int> dummy\_vector;
11 
12     \textcolor{keywordflow}{if}(rank == origin\_rank)
13     \{
14         dummy\_vector\_size = index\_map.size();
15         dummy\_vector.resize(2*dummy\_vector\_size);
16 
17         std::unordered\_map<int,int>::iterator mapIt = index\_map.begin();
18         std::unordered\_map<int,int>::iterator end\_mapIt = index\_map.end();
19         \textcolor{keywordtype}{int} dummy\_iii = 0;
20         \textcolor{keywordflow}{for}( ; mapIt != end\_mapIt; ++mapIt)
21         \{
22             dummy\_vector[2*dummy\_iii] = mapIt->first;
23             dummy\_vector[2*dummy\_iii + 1] = mapIt->second;
24             ++dummy\_iii;
25         \}
26     \}
27 
28     CommComm.barrier();
29     CommComm.broadcast(dummy\_vector\_size,origin\_rank);
30 
31     \textcolor{keywordflow}{if}( rank != origin\_rank )
32     \{
33         dummy\_vector.resize(2*dummy\_vector\_size);
34     \}
35     CommComm.broadcast(dummy\_vector,origin\_rank);
36 
37     \textcolor{keywordflow}{if}( rank != origin\_rank)
38     \{
39         index\_map.reserve(dummy\_vector\_size);
40         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < dummy\_vector\_size; ++iii)
41         \{
42             index\_map[dummy\_vector[2*iii]] = dummy\_vector[2*iii+1];
43         \}
44     \}
45 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ada178344184a369ba2db2926999a7446}{}\index{carl@{carl}!build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables@{build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables}}
\index{build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables@{build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables}!carl@{carl}}
\subsubsection[{build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const std\+::string \&intersection\+\_\+full\+\_\+table\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, std\+::vector$<$ carl\+::\+Intersection\+Data $>$ \&intersection\+\_\+full\+\_\+table, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+A\+\_\+to\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+B\+\_\+to\+\_\+\+B)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::build\+\_\+intersection\+\_\+and\+\_\+restriction\+\_\+tables (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const std\+::string \&}]{intersection\+\_\+full\+\_\+table\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, }
\item[{std\+::vector$<$ {\bf carl\+::\+Intersection\+Data} $>$ \&}]{intersection\+\_\+full\+\_\+table, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+R\+\_\+\+A\+\_\+to\+\_\+\+A, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+R\+\_\+\+B\+\_\+to\+\_\+\+B}
\end{DoxyParamCaption}
)}\label{namespacecarl_ada178344184a369ba2db2926999a7446}


Definition at line 182 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
193 \{
194     \textcolor{keywordtype}{int} rank = WorldComm.rank();
195 
196     \textcolor{comment}{//  While the equivalence tables are saved as unordered maps, it's easier to}
197     \textcolor{comment}{// save them as vectors at first, broadcast them, and them reconvert to maps}
198     std::vector<int> dummy\_equivalence\_table\_A;
199     std::vector<int> dummy\_equivalence\_table\_B;
200     std::vector<int> dummy\_intersection\_full\_table;
201 
202     \textcolor{keywordtype}{int} nbOfIntersections = -1;
203     \textcolor{keywordtype}{int} nbOfInterElems = -1;
204     \textcolor{keywordtype}{int} nbOfRestricted\_A\_Elems = -1;
205     \textcolor{keywordtype}{int} nbOfRestricted\_B\_Elems = -1;
206 
207     \textcolor{comment}{// Do the file reading job on proc 0}
208     \textcolor{keywordflow}{if}(rank == 0)
209     \{
210         std::ifstream intersection\_full\_file(intersection\_full\_table\_Filename);
211 
212         intersection\_full\_file >> nbOfIntersections >> nbOfInterElems;
213         dummy\_intersection\_full\_table.resize(4*nbOfInterElems);
214 
215         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfInterElems; ++iii)
216         \{
217             intersection\_full\_file
218                 >> dummy\_intersection\_full\_table[4*iii]
219                 >> dummy\_intersection\_full\_table[4*iii + 1]
220                 >> dummy\_intersection\_full\_table[4*iii + 2]
221                 >> dummy\_intersection\_full\_table[4*iii + 3];
222         \}
223         intersection\_full\_file.close();
224 
225         std::ifstream equivalence\_A\_file(equivalence\_table\_A\_Filename);
226 
227         equivalence\_A\_file >> nbOfRestricted\_A\_Elems;
228         dummy\_equivalence\_table\_A.resize(2*nbOfRestricted\_A\_Elems);
229 
230         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_A\_Elems; ++iii)
231         \{
232             equivalence\_A\_file  >> dummy\_equivalence\_table\_A[2*iii]
233                                 >> dummy\_equivalence\_table\_A[2*iii + 1];
234         \}
235         equivalence\_A\_file.close();
236 
237         std::ifstream equivalence\_B\_file(equivalence\_table\_B\_Filename);
238 
239         equivalence\_B\_file >> nbOfRestricted\_B\_Elems;
240         dummy\_equivalence\_table\_B.resize(2*nbOfRestricted\_B\_Elems);
241 
242         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_B\_Elems; ++iii)
243         \{
244             equivalence\_B\_file  >> dummy\_equivalence\_table\_B[2*iii]
245                                 >> dummy\_equivalence\_table\_B[2*iii + 1];
246         \}
247         equivalence\_B\_file.close();
248     \}
249 
250     \textcolor{comment}{// Broadcast the sizes and resize on other procs}
251     WorldComm.broadcast(nbOfIntersections);
252     WorldComm.broadcast(nbOfInterElems);
253     WorldComm.broadcast(nbOfRestricted\_A\_Elems);
254     WorldComm.broadcast(nbOfRestricted\_B\_Elems);
255 
256     \textcolor{keywordflow}{if}(rank != 0)
257     \{
258         dummy\_intersection\_full\_table.resize(4*nbOfInterElems);
259         dummy\_equivalence\_table\_A.resize(2*nbOfRestricted\_A\_Elems);
260         dummy\_equivalence\_table\_B.resize(2*nbOfRestricted\_B\_Elems);
261     \}
262 
263     WorldComm.barrier();
264 
265     WorldComm.broadcast(dummy\_intersection\_full\_table);
266     WorldComm.broadcast(dummy\_equivalence\_table\_A);
267     WorldComm.broadcast(dummy\_equivalence\_table\_B);
268 
269     \textcolor{comment}{// Convert back to unoredered maps and pair vectors}
270     intersection\_full\_table.resize(nbOfInterElems);
271     equivalence\_table\_A\_to\_R\_A.reserve(nbOfRestricted\_A\_Elems);
272     equivalence\_table\_B\_to\_R\_B.reserve(nbOfRestricted\_B\_Elems);
273 
274     equivalence\_table\_R\_A\_to\_A.reserve(nbOfRestricted\_A\_Elems);
275     equivalence\_table\_R\_B\_to\_B.reserve(nbOfRestricted\_B\_Elems);
276 
277     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfInterElems; ++iii)
278     \{
279         intersection\_full\_table[iii].InterMeshIdx
280                                     = dummy\_intersection\_full\_table[4*iii];
281         intersection\_full\_table[iii].AMeshIdx
282                                     = dummy\_intersection\_full\_table[4*iii + 1];
283         intersection\_full\_table[iii].BMeshIdx
284                                     = dummy\_intersection\_full\_table[4*iii + 2];
285         intersection\_full\_table[iii].IntersectionID
286                                     = dummy\_intersection\_full\_table[4*iii + 3];
287     \}
288 
289     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_A\_Elems; ++iii)
290     \{
291         equivalence\_table\_R\_A\_to\_A[dummy\_equivalence\_table\_A[2*iii]] =
292                 dummy\_equivalence\_table\_A[2*iii + 1];
293         equivalence\_table\_A\_to\_R\_A[dummy\_equivalence\_table\_A[2*iii + 1]] =
294                 dummy\_equivalence\_table\_A[2*iii];
295     \}
296 
297     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_B\_Elems; ++iii)
298     \{
299         equivalence\_table\_R\_B\_to\_B[dummy\_equivalence\_table\_B[2*iii]] =
300                 dummy\_equivalence\_table\_B[2*iii + 1];
301         equivalence\_table\_B\_to\_R\_B[dummy\_equivalence\_table\_B[2*iii + 1]] =
302                 dummy\_equivalence\_table\_B[2*iii];
303     \}
304 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a2a42a81e2c9cc6e97c90f5960e5f1048}{}\index{carl@{carl}!check\+\_\+coupling\+\_\+matrix@{check\+\_\+coupling\+\_\+matrix}}
\index{check\+\_\+coupling\+\_\+matrix@{check\+\_\+coupling\+\_\+matrix}!carl@{carl}}
\subsubsection[{check\+\_\+coupling\+\_\+matrix(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+Coupling\+Test\+Matrix, lib\+Mesh\+::\+Mesh \&\+Intersection\+Mesh, lib\+Mesh\+::\+Real Coupling\+Scale, const std\+::string matrixtype, int n\+\_\+var=3)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::check\+\_\+coupling\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{Coupling\+Test\+Matrix, }
\item[{lib\+Mesh\+::\+Mesh \&}]{Intersection\+Mesh, }
\item[{lib\+Mesh\+::\+Real}]{Coupling\+Scale, }
\item[{const std\+::string}]{matrixtype, }
\item[{int}]{n\+\_\+var = {\ttfamily 3}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a2a42a81e2c9cc6e97c90f5960e5f1048}


Definition at line 284 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
289 \{
290     std::cout << \textcolor{stringliteral}{"| "} << matrixType << std::endl;
291     libMesh::Real accumulator = 0;
292 
293     std::cout << \textcolor{stringliteral}{"| M\_i,j : "} << CouplingTestMatrix.m() << \textcolor{stringliteral}{" x "} << CouplingTestMatrix.n() << std::endl;
294     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < CouplingTestMatrix.m(); ++iii)
295     \{
296         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} jjj = 0; jjj < CouplingTestMatrix.n(); ++jjj)
297         \{
298             accumulator += CouplingTestMatrix(iii,jjj);
299         \}
300     \}
301 
302     libMesh::Real vol = 0;
303     libMesh::Elem* silly\_elem;
304     \textcolor{keywordflow}{for}(libMesh::MeshBase::element\_iterator itBegin = IntersectionMesh.elements\_begin();
305                                             itBegin != IntersectionMesh.elements\_end();
306                                             ++itBegin)
307     \{
308         silly\_elem = *itBegin;
309         vol += silly\_elem->volume();
310     \}
311 
312     libMesh::Real difference = accumulator - n\_var*CouplingScale*vol;
313 
314     std::cout << \textcolor{stringliteral}{"|"} << std::endl;
315     std::cout << \textcolor{stringliteral}{"|    Sum( M\_i,j )   = "} << accumulator << std::endl;
316     std::cout << \textcolor{stringliteral}{"|    n * C * Volume = "} << n\_var*CouplingScale*vol << std::endl;
317     std::cout << \textcolor{stringliteral}{"| >  Difference     = "} << difference << std::endl << std::endl;
318 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a855a8c682ef0ee0a35f987e051d2bbf2}{}\index{carl@{carl}!Cluster\+Scheduler\+Type\+\_\+to\+\_\+string@{Cluster\+Scheduler\+Type\+\_\+to\+\_\+string}}
\index{Cluster\+Scheduler\+Type\+\_\+to\+\_\+string@{Cluster\+Scheduler\+Type\+\_\+to\+\_\+string}!carl@{carl}}
\subsubsection[{Cluster\+Scheduler\+Type\+\_\+to\+\_\+string(\+Cluster\+Scheduler\+Type input)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string carl\+::\+Cluster\+Scheduler\+Type\+\_\+to\+\_\+string (
\begin{DoxyParamCaption}
\item[{{\bf Cluster\+Scheduler\+Type}}]{input}
\end{DoxyParamCaption}
)}\label{namespacecarl_a855a8c682ef0ee0a35f987e051d2bbf2}


Definition at line 9 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
10 \{
11     \textcolor{keywordflow}{switch} (input)
12     \{
13         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{ClusterSchedulerType::LOCAL} :   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"LOCAL"};
14                         \textcolor{keywordflow}{break};
15 
16         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{ClusterSchedulerType::PBS} :   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PBS"};
17                         \textcolor{keywordflow}{break};
18 
19         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{ClusterSchedulerType::SLURM} :   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"SLURM"};
20                         \textcolor{keywordflow}{break};
21     \}
22 
23     \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid enumerate argument!"});
24     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
25 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a40b4ba8a31197c1df5e1aa3438a46852}{}\index{carl@{carl}!create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors@{create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors}}
\index{create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors@{create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors}!carl@{carl}}
\subsubsection[{create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors(const Vec $\ast$vecs\+\_\+in, int nb\+\_\+vecs, Mat \&matrix\+\_\+out)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::create\+\_\+\+P\+E\+T\+S\+C\+\_\+dense\+\_\+matrix\+\_\+from\+\_\+vectors (
\begin{DoxyParamCaption}
\item[{const Vec $\ast$}]{vecs\+\_\+in, }
\item[{int}]{nb\+\_\+vecs, }
\item[{Mat \&}]{matrix\+\_\+out}
\end{DoxyParamCaption}
)}\label{namespacecarl_a40b4ba8a31197c1df5e1aa3438a46852}


Definition at line 456 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
457 \{
458     \textcolor{comment}{// Get the vectors' dimensions and create the matrix}
459     PetscInt M\_local, M;
460     VecGetLocalSize(vecs\_in[0],&M\_local);
461     VecGetSize(vecs\_in[0],&M);
462 
463     MatCreateDense(PETSC\_COMM\_WORLD,M\_local,PETSC\_DECIDE,M,nb\_vecs,NULL,&matrix\_out);
464 
465     \textcolor{comment}{// Get the ownership ranges and the row indexes}
466     PetscInt own\_low, own\_high;
467     VecGetOwnershipRange(vecs\_in[0],&own\_low,&own\_high);
468 
469     std::vector<PetscInt> row(M\_local,0);
470 
471     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < M\_local; ++iii)
472     \{
473         row[iii] = own\_low + iii;
474     \}
475 
476     \textcolor{comment}{// Set the values}
477     PetscScalar* data;
478     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nb\_vecs; ++iii)
479     \{
480         VecGetArray(vecs\_in[iii],&data);
481         MatSetValues(matrix\_out,M\_local,row.data(),1,&iii,data,INSERT\_VALUES);
482         VecRestoreArray(vecs\_in[iii],&data);
483     \}
484 
485     \textcolor{comment}{// Assembly}
486     MatAssemblyBegin(matrix\_out,MAT\_FINAL\_ASSEMBLY);
487     MatAssemblyEnd(matrix\_out,MAT\_FINAL\_ASSEMBLY);
488 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a54249fee021b3d53e1a7ae7208292437}{}\index{carl@{carl}!exec\+\_\+command@{exec\+\_\+command}}
\index{exec\+\_\+command@{exec\+\_\+command}!carl@{carl}}
\subsubsection[{exec\+\_\+command(const std\+::string \&cmd)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string carl\+::exec\+\_\+command (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{cmd}
\end{DoxyParamCaption}
)}\label{namespacecarl_a54249fee021b3d53e1a7ae7208292437}


Definition at line 60 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
60                                                  \{
61     std::array<char, 128> buffer;
62     std::string result;
63     std::shared\_ptr<FILE> pipe(popen(cmd.c\_str(), \textcolor{stringliteral}{"r"}), pclose);
64     \textcolor{keywordflow}{if} (!pipe) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"popen() failed!"});
65     \textcolor{keywordflow}{while} (!feof(pipe.get())) \{
66         \textcolor{keywordflow}{if} (fgets(buffer.data(), 128, pipe.get()) != NULL)
67             result += buffer.data();
68     \}
69     \textcolor{keywordflow}{return} result;
70 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a2df653606e38410b38a938470c3b7fd3}{}\index{carl@{carl}!Ext\+Solver\+Type\+\_\+to\+\_\+string@{Ext\+Solver\+Type\+\_\+to\+\_\+string}}
\index{Ext\+Solver\+Type\+\_\+to\+\_\+string@{Ext\+Solver\+Type\+\_\+to\+\_\+string}!carl@{carl}}
\subsubsection[{Ext\+Solver\+Type\+\_\+to\+\_\+string(\+Ext\+Solver\+Type input)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string carl\+::\+Ext\+Solver\+Type\+\_\+to\+\_\+string (
\begin{DoxyParamCaption}
\item[{{\bf Ext\+Solver\+Type}}]{input}
\end{DoxyParamCaption}
)}\label{namespacecarl_a2df653606e38410b38a938470c3b7fd3}


Definition at line 45 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
46 \{
47     \textcolor{keywordflow}{switch} (input)
48     \{
49         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}{ExtSolverType::LIBMESH\_LINEAR} :   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"LIBMESH\_LINEAR"};
50                         \textcolor{keywordflow}{break};
51 
52         \textcolor{keywordflow}{case} \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08ad129ac6d9556cbd33f5ed9828309b941}{ExtSolverType::DUMMY} : \textcolor{keywordflow}{return} \textcolor{stringliteral}{"DUMMY"};
53                         \textcolor{keywordflow}{break};
54     \}
55 
56     \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid enumerate argument!"});
57     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
58 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ac207572d2bb1b2f6558bbb96bfa89edc}{}\index{carl@{carl}!generate\+\_\+intersection\+\_\+tables\+\_\+full@{generate\+\_\+intersection\+\_\+tables\+\_\+full}}
\index{generate\+\_\+intersection\+\_\+tables\+\_\+full@{generate\+\_\+intersection\+\_\+tables\+\_\+full}!carl@{carl}}
\subsubsection[{generate\+\_\+intersection\+\_\+tables\+\_\+full(std\+::string \&equivalence\+\_\+table\+\_\+restrict\+\_\+\+A\+\_\+\+Filename, std\+::string \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B\+\_\+\+Filename, std\+::string \&intersection\+\_\+table\+\_\+\+I\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+restrict\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+micro\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+\+B\+I\+G\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+inter\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+restrict\+\_\+\+A, std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&intersection\+\_\+table\+\_\+\+I)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::generate\+\_\+intersection\+\_\+tables\+\_\+full (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{equivalence\+\_\+table\+\_\+restrict\+\_\+\+A\+\_\+\+Filename, }
\item[{std\+::string \&}]{intersection\+\_\+table\+\_\+restrict\+\_\+\+B\+\_\+\+Filename, }
\item[{std\+::string \&}]{intersection\+\_\+table\+\_\+\+I\+\_\+\+Filename, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+restrict\+\_\+\+Elem\+Map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+micro\+\_\+\+Elem\+Map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+\+B\+I\+G\+\_\+\+Elem\+Map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+inter\+\_\+\+Elem\+Map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+restrict\+\_\+\+A, }
\item[{std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ \&}]{intersection\+\_\+table\+\_\+restrict\+\_\+\+B, }
\item[{std\+::unordered\+\_\+multimap$<$ int, int $>$ \&}]{intersection\+\_\+table\+\_\+\+I}
\end{DoxyParamCaption}
)}\label{namespacecarl_ac207572d2bb1b2f6558bbb96bfa89edc}


Definition at line 104 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
115 \{
116     std::ifstream table\_restrict\_A\_file(equivalence\_table\_restrict\_A\_Filename);
117     std::ifstream table\_restrict\_B\_file(intersection\_table\_restrict\_B\_Filename);
118     std::ifstream table\_I\_file(intersection\_table\_I\_Filename);
119 
120     \textcolor{keywordtype}{int} nbOfEquivalences\_restrict\_A = -1;
121     \textcolor{keywordtype}{int} nbOfIntersections\_restrict\_B = -1;
122     \textcolor{keywordtype}{int} nbOfIntersectionsI  = -1;
123     \textcolor{keywordtype}{int} nbOfTotalTetrasI  = -1;
124     \textcolor{keywordtype}{int} dummyInt = -1;
125     \textcolor{keywordtype}{int} nbOfTetras = -1;
126     \textcolor{keywordtype}{int} tetraIdx = -1;
127 
128     \textcolor{keywordtype}{int} extIdxA = -1;
129     \textcolor{keywordtype}{int} extIdxB = -1;
130     \textcolor{keywordtype}{int} extIdxI = -1;
131     \textcolor{keywordtype}{int} extIdxR = -1;
132 
133     \textcolor{keywordtype}{int} idxRestrict = -1;
134     \textcolor{keywordtype}{int} idxA = -1;
135 
136     table\_restrict\_A\_file >> nbOfEquivalences\_restrict\_A;
137     std::unordered\_map<int,int> temp\_equivalence\_table\_A\_restrict(nbOfEquivalences\_restrict\_A);
138     equivalence\_table\_restrict\_A.reserve(nbOfEquivalences\_restrict\_A);
139 
140     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfEquivalences\_restrict\_A; ++iii)
141     \{
142         table\_restrict\_A\_file >> extIdxR >> extIdxA;
143 
144         idxA = mesh\_BIG\_ElemMap[extIdxA];
145         idxRestrict = mesh\_restrict\_ElemMap[extIdxR];
146 
147         temp\_equivalence\_table\_A\_restrict[idxA] = idxRestrict;
148         equivalence\_table\_restrict\_A[idxRestrict] = idxA;
149     \}
150 
151     table\_restrict\_B\_file >> nbOfIntersections\_restrict\_B;
152     table\_I\_file >> nbOfIntersectionsI >> nbOfTotalTetrasI;
153 
154     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(nbOfIntersections\_restrict\_B == nbOfIntersectionsI, \textcolor{stringliteral}{"
      Incompatible intersection table files!"});
155 
156     intersection\_table\_restrict\_B.resize(nbOfIntersections\_restrict\_B);
157     intersection\_table\_I.reserve(nbOfTotalTetrasI);
158 
159     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections\_restrict\_B; ++iii)
160     \{
161         table\_restrict\_B\_file >> dummyInt >> extIdxA >> extIdxB;
162 
163         idxA = mesh\_BIG\_ElemMap[extIdxA];
164         intersection\_table\_restrict\_B[iii].first = temp\_equivalence\_table\_A\_restrict[idxA];
165         intersection\_table\_restrict\_B[iii].second = mesh\_micro\_ElemMap[extIdxB];
166 
167         table\_I\_file >> dummyInt >> nbOfTetras;
168         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} jjj = 0; jjj < nbOfTetras; ++jjj)
169         \{
170             table\_I\_file >> extIdxI;
171             tetraIdx = mesh\_inter\_ElemMap[extIdxI];
172             intersection\_table\_I.emplace(dummyInt,tetraIdx);
173         \}
174     \}
175 
176     table\_restrict\_A\_file.close();
177     table\_restrict\_B\_file.close();
178     table\_I\_file.close();
179 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a8aedfd6e81c99d9651093ff26b9c5a55}{}\index{carl@{carl}!generate\+\_\+intersection\+\_\+tables\+\_\+partial@{generate\+\_\+intersection\+\_\+tables\+\_\+partial}}
\index{generate\+\_\+intersection\+\_\+tables\+\_\+partial@{generate\+\_\+intersection\+\_\+tables\+\_\+partial}!carl@{carl}}
\subsubsection[{generate\+\_\+intersection\+\_\+tables\+\_\+partial(std\+::string \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B\+\_\+\+Filename, std\+::string \&intersection\+\_\+table\+\_\+\+I\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+restrict\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+micro\+\_\+\+Elem\+Map, std\+::unordered\+\_\+map$<$ int, int $>$ \&mesh\+\_\+inter\+\_\+\+Elem\+Map, std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ \&intersection\+\_\+table\+\_\+restrict\+\_\+\+B, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&intersection\+\_\+table\+\_\+\+I)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::generate\+\_\+intersection\+\_\+tables\+\_\+partial (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{intersection\+\_\+table\+\_\+restrict\+\_\+\+B\+\_\+\+Filename, }
\item[{std\+::string \&}]{intersection\+\_\+table\+\_\+\+I\+\_\+\+Filename, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+restrict\+\_\+\+Elem\+Map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+micro\+\_\+\+Elem\+Map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{mesh\+\_\+inter\+\_\+\+Elem\+Map, }
\item[{std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ \&}]{intersection\+\_\+table\+\_\+restrict\+\_\+\+B, }
\item[{std\+::unordered\+\_\+multimap$<$ int, int $>$ \&}]{intersection\+\_\+table\+\_\+\+I}
\end{DoxyParamCaption}
)}\label{namespacecarl_a8aedfd6e81c99d9651093ff26b9c5a55}


Definition at line 54 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
62 \{
63     std::ifstream table\_restrict\_B\_file(intersection\_table\_restrict\_B\_Filename);
64     std::ifstream table\_I\_file(intersection\_table\_I\_Filename);
65 
66     \textcolor{keywordtype}{int} nbOfIntersections\_restrict\_B = -1;
67     \textcolor{keywordtype}{int} nbOfIntersectionsI  = -1;
68     \textcolor{keywordtype}{int} nbOfTotalTetrasI  = -1;
69     \textcolor{keywordtype}{int} dummyInt = -1;
70     \textcolor{keywordtype}{int} nbOfTetras = -1;
71     \textcolor{keywordtype}{int} tetraIdx = -1;
72 
73     \textcolor{keywordtype}{int} extIdxA = -1;
74     \textcolor{keywordtype}{int} extIdxB = -1;
75     \textcolor{keywordtype}{int} extIdxI = -1;
76 
77     table\_restrict\_B\_file >> nbOfIntersections\_restrict\_B;
78     table\_I\_file >> nbOfIntersectionsI >> nbOfTotalTetrasI;
79 
80     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(nbOfIntersections\_restrict\_B == nbOfIntersectionsI, \textcolor{stringliteral}{"
      Incompatible intersection table files!"});
81 
82     intersection\_table\_restrict\_B.resize(nbOfIntersections\_restrict\_B);
83     intersection\_table\_I.reserve(2*nbOfTotalTetrasI);
84 
85     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections\_restrict\_B; ++iii)
86     \{
87         table\_restrict\_B\_file >> dummyInt >> extIdxA >> extIdxB;
88         intersection\_table\_restrict\_B[iii].first = mesh\_restrict\_ElemMap[extIdxA];
89         intersection\_table\_restrict\_B[iii].second = mesh\_micro\_ElemMap[extIdxB];
90 
91         table\_I\_file >> dummyInt >> nbOfTetras;
92         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} jjj = 0; jjj < nbOfTetras; ++jjj)
93         \{
94             table\_I\_file >> extIdxI;
95             tetraIdx = mesh\_inter\_ElemMap[extIdxI];
96             intersection\_table\_I.emplace(dummyInt,tetraIdx);
97         \}
98     \}
99 
100     table\_restrict\_B\_file.close();
101     table\_I\_file.close();
102 \};
\end{DoxyCode}
\hypertarget{namespacecarl_aba5c04efa5a0abae78d3efd00ae694e3}{}\index{carl@{carl}!get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params@{get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params}}
\index{get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params@{get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, coupling\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf coupling\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_aba5c04efa5a0abae78d3efd00ae694e3}


Parser function for the construction of the coupling matrices. 

Required parameters\+:
\begin{DoxyItemize}
\item System and intersection meshes\+:
\begin{DoxyItemize}
\item {\ttfamily Mesh\+A}, {\ttfamily -\/m\+A} or {\ttfamily -\/-\/mesh\+A} \+: path to the mesh A.
\item {\ttfamily Mesh\+B}, {\ttfamily -\/m\+B} or {\ttfamily -\/-\/mesh\+B} \+: path to the mesh B.
\item {\ttfamily Inter\+Base}, {\ttfamily -\/m\+I} or {\ttfamily -\/-\/mesh\+I} \+: common path to the intersection meshes and tables.
\end{DoxyItemize}
\item Coupling parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Coupling\+Width} or {\ttfamily -\/-\/ce} \+: width of the coupling region (same unit as the meshes, $e$ in the $L_2$ coupling term).
\item {\ttfamily Coupling\+Rigidity} or {\ttfamily -\/-\/ck} \+: rigidity used for the coupling matrix (in M\+Pa, if mm was used for the meshes, $\kappa$ in both the $L_2$ and $H_1$ terms).
\end{DoxyItemize}
\end{DoxyItemize}

Optional parameters\+:
\begin{DoxyItemize}
\item Output\+:
\begin{DoxyItemize}
\item {\ttfamily Output\+Folder} or {\ttfamily -\/-\/output} \+: base of the output folder. {\itshape Default}\+: \char`\"{}\char`\"{}.
\end{DoxyItemize}
\item Restriction meshes and tables\+:
\begin{DoxyItemize}
\item {\ttfamily Mesh\+\_\+\+A\+\_\+\+Restriction}, {\ttfamily -\/m\+A\+R} or {\ttfamily -\/-\/mesh\+A\+R} \+: path to the restricted mesh A (formed by elements of the mesh A intersecting the coupling region). {\itshape Default}\+: {\ttfamily \mbox{[}Inter\+Base\mbox{]}\+\_\+\+A\+\_\+restriction.\+msh}.
\item {\ttfamily Mesh\+\_\+\+B\+\_\+\+Restriction}, {\ttfamily -\/m\+B\+R} or {\ttfamily -\/-\/mesh\+B\+R} \+: path to the restricted mesh B (formed by elements of the mesh A intersecting the coupling region). {\itshape Default}\+: {\ttfamily \mbox{[}Inter\+Base\mbox{]}\+\_\+\+B\+\_\+restriction.\+msh}.
\item {\ttfamily Mesh\+\_\+\+A\+\_\+\+Restriction\+Equivalence\+Table} or {\ttfamily -\/-\/table\+R\+A} \+: path to the equivalence table between the mesh A and its restriction. {\itshape Default}\+: {\ttfamily \mbox{[}Inter\+Base\mbox{]}\+\_\+\+A\+\_\+restriction\+\_\+restrict.\+dat}.
\item {\ttfamily Mesh\+\_\+\+B\+\_\+\+Restriction\+Equivalence\+Table} or {\ttfamily -\/-\/table\+R\+B} \+: path to the equivalence table between the mesh B and its restriction. {\itshape Default}\+: {\ttfamily \mbox{[}Inter\+Base\mbox{]}\+\_\+\+B\+\_\+restriction\+\_\+restrict.\+dat}.
\end{DoxyItemize}
\item Mediator mesh\+:
\begin{DoxyItemize}
\item {\ttfamily Mediator\+Mesh} \+: choice of the mediator mesh. {\itshape Values}\+: {\ttfamily Use\+Restricted\+\_\+\+A} or {\ttfamily Use\+Restricted\+\_\+\+B}. {\itshape Default}\+: {\ttfamily Use\+Restricted\+\_\+\+A}. 
\end{DoxyItemize}
\end{DoxyItemize}

Definition at line 13 of file carl\+\_\+assemble\+\_\+coupling\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
14                                                                \{
15 
16     \textcolor{comment}{// Set mesh files}
17     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshA"}, \textcolor{stringliteral}{"-mA"}, \textcolor{stringliteral}{"MeshA"})) \{
18         input\_params.mesh\_BIG\_file = field\_parser.next(
19                 input\_params.mesh\_BIG\_file);
20     \} \textcolor{keywordflow}{else} \{
21         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the A mesh file!"});
22     \}
23 
24     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshB"}, \textcolor{stringliteral}{"-mB"}, \textcolor{stringliteral}{"MeshB"})) \{
25         input\_params.mesh\_micro\_file = field\_parser.next(
26                 input\_params.mesh\_micro\_file);
27     \} \textcolor{keywordflow}{else} \{
28         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the B mesh file!"});
29     \}
30 
31     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshI"}, \textcolor{stringliteral}{"-mI"}, \textcolor{stringliteral}{"InterBase"})) \{
32         input\_params.common\_inter\_file = field\_parser.next(
33                 input\_params.common\_inter\_file);
34     \} \textcolor{keywordflow}{else} \{
35         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the path to the intersection files!"});
36     \}
37 
38     \textcolor{comment}{// Set coupling parameters}
39     \textcolor{keywordflow}{if}( field\_parser.search(2, \textcolor{stringliteral}{"--ce"},\textcolor{stringliteral}{"CouplingWidth"}) )
40     \{
41         input\_params.coupling\_width = field\_parser.next(input\_params.coupling\_width);
42     \} \textcolor{keywordflow}{else} \{
43         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling region width!"});
44     \}
45 
46     \textcolor{keywordflow}{if}( field\_parser.search(2, \textcolor{stringliteral}{"--ck"},\textcolor{stringliteral}{"CouplingRigidity"}) )
47     \{
48         input\_params.coupling\_rigidity = field\_parser.next(input\_params.coupling\_rigidity);
49     \} \textcolor{keywordflow}{else} \{
50         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling rigidity!"});
51     \}
52 
53     \textcolor{comment}{// Output}
54     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--output"}, \textcolor{stringliteral}{"-mO"}, \textcolor{stringliteral}{"OutputFolder"}))
55     \{
56         input\_params.output\_folder = field\_parser.next(
57             input\_params.output\_folder);
58     \} \textcolor{keywordflow}{else} \{
59         input\_params.output\_folder = \textcolor{stringliteral}{""};
60     \}
61 
62     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshAR"}, \textcolor{stringliteral}{"-mAR"}, \textcolor{stringliteral}{"Mesh\_A\_Restriction"})) \{
63         input\_params.mesh\_restrict\_BIG\_file = field\_parser.next(
64                 input\_params.mesh\_restrict\_BIG\_file);
65     \} \textcolor{keywordflow}{else} \{
66         input\_params.mesh\_restrict\_BIG\_file = input\_params.common\_inter\_file + \textcolor{stringliteral}{"\_A\_restriction.msh"};
67     \}
68 
69     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshBR"}, \textcolor{stringliteral}{"-mBR"}, \textcolor{stringliteral}{"Mesh\_B\_Restriction"})) \{
70         input\_params.mesh\_restrict\_micro\_file = field\_parser.next(
71                 input\_params.mesh\_restrict\_micro\_file);
72     \} \textcolor{keywordflow}{else} \{
73         input\_params.mesh\_restrict\_micro\_file = input\_params.common\_inter\_file + \textcolor{stringliteral}{"\_B\_restriction.msh"};
74     \}
75 
76     \textcolor{comment}{// Set the equivalence tables}
77     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"--tableRA"}, \textcolor{stringliteral}{"Mesh\_A\_RestrictionEquivalenceTable"})) \{
78         input\_params.equivalence\_table\_restrict\_BIG\_file = field\_parser.next(
79                 input\_params.equivalence\_table\_restrict\_BIG\_file);
80     \} \textcolor{keywordflow}{else} \{
81         input\_params.equivalence\_table\_restrict\_BIG\_file = input\_params.common\_inter\_file + \textcolor{stringliteral}{"
      \_A\_restriction\_restrict.dat"};
82     \}
83 
84     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"--tableRB"}, \textcolor{stringliteral}{"Mesh\_B\_RestrictionEquivalenceTable"})) \{
85         input\_params.equivalence\_table\_restrict\_micro\_file = field\_parser.next(
86                 input\_params.equivalence\_table\_restrict\_micro\_file);
87     \} \textcolor{keywordflow}{else} \{
88         input\_params.equivalence\_table\_restrict\_micro\_file = input\_params.common\_inter\_file + \textcolor{stringliteral}{"
      \_B\_restriction\_restrict.dat"};
89     \}
90 
91     \textcolor{comment}{// Set the mediator mesh}
92     input\_params.mediator\_type = \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eae0a6a4791f68baefa4702e4f053b2817}{carl::MediatorType::USE\_MACRO};
93     input\_params.mesh\_mediator\_file = input\_params.mesh\_restrict\_BIG\_file;
94 
95     std::string mediator\_type;
96     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"MediatorMesh"}))
97     \{
98         mediator\_type = field\_parser.next(mediator\_type);
99 
100         \textcolor{keywordflow}{if}(mediator\_type == \textcolor{stringliteral}{"UseRestricted\_A"})
101         \{
102             input\_params.mediator\_type = \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eae0a6a4791f68baefa4702e4f053b2817}{carl::MediatorType::USE\_MACRO};
103             input\_params.mesh\_mediator\_file = input\_params.mesh\_restrict\_BIG\_file;
104         \}
105         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mediator\_type == \textcolor{stringliteral}{"UseRestricted\_B"})
106         \{
107             input\_params.mediator\_type = \hyperlink{namespacecarl_ab4549821791d976a4bb9a3460fe1718eaaeaede2dff7ae7d5633a316f0fbc3151}{carl::MediatorType::USE\_MICRO};
108             input\_params.mesh\_mediator\_file = input\_params.mesh\_restrict\_micro\_file;
109         \}
110     \}
111 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a2b7d0a416cdffe9589a3912c1f4ef20b}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_a2b7d0a416cdffe9589a3912c1f4ef20b}


Parser function for the coupled solver test programs. 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Sys\+Matrix} \+: path to the system matrix file.
\item {\ttfamily Sys\+R\+H\+S\+Vector} \+: path to the system R\+H\+S vector file.
\item {\ttfamily Output\+Base} \+: output filename base.
\end{DoxyItemize}

Optional parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Sys\+Eps} \+: relative convergence parameter. {\itshape Default}\+: 1e-\/5.
\item {\ttfamily Sys\+Iter\+Div} \+: maximum number of iterations. {\itshape Default}\+: 1e3.
\item {\ttfamily R\+B\+Vector\+Base} \+: filename base to the rigid body mode vectors. The program expects that these vectors will be named as {\ttfamily \mbox{[}R\+B\+Vector\+Base\mbox{]}\+\_\+rb\+\_\+vector\+\_\+\+X\+Y\+Z\+\_\+n\+\_\+\mbox{[}Nb\+Of\+R\+B\+Vectors\mbox{]}.petscvec}, where {\ttfamily X\+Y\+Z} is an integer index going from {\ttfamily 0} to {\ttfamily Nb\+Of\+R\+B\+Vectors -\/ 1}. Setting this parameter sets {\ttfamily b\+Use\+R\+B\+Vectors} to {\ttfamily true} -\/ else, it is set to {\ttfamily false}.
\item {\ttfamily Nb\+Of\+R\+B\+Vectors} \+: number of R\+B mode vectors. {\itshape Default}\+: 6. 
\end{DoxyItemize}

Definition at line 12 of file libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
13                                                                 \{
14 
15     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"SysMatrix"})) \{
16         input\_params.sys\_matrix\_file = field\_parser.next(
17                 input\_params.sys\_matrix\_file);
18     \} \textcolor{keywordflow}{else} \{
19         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the system matrix file!"});
20     \}
21 
22     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"SysRHSVector"})) \{
23         input\_params.sys\_rhs\_vec\_file = field\_parser.next(
24                 input\_params.sys\_rhs\_vec\_file);
25     \} \textcolor{keywordflow}{else} \{
26         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the system RHS vector file!"});
27     \}
28 
29     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"OutputBase"})) \{
30         input\_params.output\_base = field\_parser.next(
31                 input\_params.output\_base);
32     \} \textcolor{keywordflow}{else} \{
33         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the output filename base!"});
34     \}
35 
36     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"SysEps"})) \{
37         input\_params.sys\_eps = field\_parser.next(
38                 input\_params.sys\_eps);
39     \} \textcolor{keywordflow}{else} \{
40         input\_params.sys\_eps = 1e-5;
41     \}
42 
43     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"SysIterDiv"})) \{
44         input\_params.sys\_iter\_div = field\_parser.next(
45                 input\_params.sys\_iter\_div);
46     \} \textcolor{keywordflow}{else} \{
47         input\_params.sys\_iter\_div = 1000;
48     \}
49 
50     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"RBVectorBase"})) \{
51         input\_params.path\_to\_rb\_vectors = field\_parser.next(
52                 input\_params.path\_to\_rb\_vectors);
53         input\_params.bUseRBVectors = \textcolor{keyword}{true};
54 
55         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"NbOfRBVectors"})) \{
56             input\_params.nb\_of\_rb\_vectors = field\_parser.next(
57                     input\_params.nb\_of\_rb\_vectors);
58         \} \textcolor{keywordflow}{else} \{
59             input\_params.nb\_of\_rb\_vectors = 6;
60         \}
61 
62     \} \textcolor{keywordflow}{else} \{
63         input\_params.bUseRBVectors = \textcolor{keyword}{false};
64     \}
65 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a902f88f3c52c6fc9c974bc99832e78a7}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, feti\+\_\+iterate\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf feti\+\_\+iterate\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_a902f88f3c52c6fc9c974bc99832e78a7}


Parser function for the coupled solver test programs. 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Cluster\+Scheduler\+Type} \+: scheduler type. {\itshape Values}\+: L\+O\+C\+A\+L, P\+B\+S or S\+L\+U\+R\+M (code not implemented for the later yet, {\ttfamily L\+O\+C\+A\+L} runs the code without a scheduler).
\item {\ttfamily Scratch\+Folder\+Path} \+: path to the folder where the temporary files used by the coupled solver will be saved.
\item {\ttfamily Coupling\+Matrices\+Folder} \+: path to the folder containing the coupling matrices.
\end{DoxyItemize}

Boolean flags\+:
\begin{DoxyItemize}
\item {\ttfamily Use\+Rigid\+Body\+Modes\+B} \+: use the rigid body modes for system B.
\end{DoxyItemize}

Rigid body mode parameters (only read if {\ttfamily Use\+Rigid\+Body\+Modes\+B} is used)\+:
\begin{DoxyItemize}
\item {\ttfamily Ext\+Force\+System\+B} \+: path to the vector containing the external forces for the system B.
\item {\ttfamily R\+B\+Vector\+Base} \+: filename base of the rigid body modes vectors.
\end{DoxyItemize}

Optional parameters\+:
\begin{DoxyItemize}
\item F\+E\+T\+I / C\+G optional parameters\+:
\begin{DoxyItemize}
\item {\ttfamily C\+G\+Preconditioner\+Type} \+: C\+G preconditioner type. {\itshape Values}\+: \char`\"{}\+N\+O\+N\+E\char`\"{}, \char`\"{}\+Coupling\+\_\+operator\char`\"{} or \char`\"{}\+Coupling\+\_\+operator\+\_\+jacobi\char`\"{}. {\itshape Default}\+: \char`\"{}\+Coupling\+\_\+operator\char`\"{}.
\item {\ttfamily Coupled\+Conv\+Abs} \+: C\+G absolute convergence on the residual. {\itshape Default}\+: 1e-\/20.
\item {\ttfamily Coupled\+Conv\+Rel} \+: C\+G relative convergence on the residual. {\itshape Default}\+: 1e-\/5.
\item {\ttfamily Coupled\+Corr\+Conv\+Rel} \+: C\+G relative convergence on the rigid body corrections. {\itshape Default}\+: 1e-\/6.
\item {\ttfamily Coupled\+Div} \+: C\+G residual divergence parameter. {\itshape Default}\+: 100000.
\item {\ttfamily Coupled\+Iter\+Max} \+: C\+G maximum number of iterations. {\itshape Default}\+: 1000. 
\end{DoxyItemize}
\end{DoxyItemize}

Definition at line 13 of file carl\+\_\+feti\+\_\+iterate\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
14                                            \{
15 
16     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ClusterSchedulerType"})) \{
17         std::string cluster\_scheduler\_type;
18         cluster\_scheduler\_type = field\_parser.next(cluster\_scheduler\_type);
19         \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"LOCAL"})
20         \{
21             std::cout << \textcolor{stringliteral}{" !!! WARNING: "} << std::endl;
22             std::cout << \textcolor{stringliteral}{"        Using the LOCAL job 'scheduler'. You will have to launch each script"} << 
      std::endl;
23             std::cout << \textcolor{stringliteral}{"     MANUALLY!!! Reason: MPI does not support recursive 'mpirun' calls"} << 
      std::endl;
24             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{carl::ClusterSchedulerType::LOCAL};
25         \}
26         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"PBS"})
27             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{carl::ClusterSchedulerType::PBS};
28         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"SLURM"})
29             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{carl::ClusterSchedulerType::SLURM};
30         \textcolor{keywordflow}{else}
31             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid scheduler type!"});
32     \} \textcolor{keywordflow}{else} \{
33         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the scheduler type!"});
34     \}
35 
36     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ScratchFolderPath"})) \{
37         input\_params.scratch\_folder\_path = field\_parser.next(
38                 input\_params.scratch\_folder\_path);
39     \} \textcolor{keywordflow}{else} \{
40         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external scratch folder path!"});
41     \}
42 
43     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"CouplingMatricesFolder"})) \{
44         input\_params.coupling\_folder\_path = field\_parser.next(
45                 input\_params.coupling\_folder\_path);
46     \} \textcolor{keywordflow}{else} \{
47         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling matrices path!"});
48     \}
49 
50     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"UseRigidBodyModesB"}))
51     \{
52         input\_params.bUseRigidBodyModes = \textcolor{keyword}{true};
53         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"RBVectorBase"})) \{
54             input\_params.RB\_vectors\_base = field\_parser.next(
55                     input\_params.RB\_vectors\_base);
56         \} \textcolor{keywordflow}{else} \{
57             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the system B's rigid body mode vectors!"});
58         \}
59                 
60         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"NbOfRBVectors"})) \{
61             input\_params.nb\_of\_rb\_vectors = field\_parser.next(
62                     input\_params.nb\_of\_rb\_vectors);
63         \} \textcolor{keywordflow}{else} \{
64             input\_params.nb\_of\_rb\_vectors = 6;
65         \}
66     \}
67     \textcolor{keywordflow}{else}
68     \{
69         input\_params.bUseRigidBodyModes = \textcolor{keyword}{false};
70     \}
71 
72     \textcolor{comment}{// Set CG coupling solver convergence}
73     input\_params.CG\_coupled\_conv\_abs = 1e-20;
74     input\_params.CG\_coupled\_conv\_rel = 1e-5;
75     input\_params.CG\_coupled\_div = 1e5;
76     input\_params.CG\_coupled\_conv\_max = 1e4;
77     input\_params.CG\_coupled\_conv\_corr =1e-5;
78 
79     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledConvAbs"}) )
80     \{
81         input\_params.CG\_coupled\_conv\_abs = field\_parser.next(input\_params.CG\_coupled\_conv\_abs);
82     \}
83     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledConvRel"}) )
84     \{
85         input\_params.CG\_coupled\_conv\_rel = field\_parser.next(input\_params.CG\_coupled\_conv\_rel);
86     \}
87     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledCorrConvRel"}) )
88     \{
89         input\_params.CG\_coupled\_conv\_corr = field\_parser.next(input\_params.CG\_coupled\_conv\_corr);
90     \}
91     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledDiv"}) )
92     \{
93         input\_params.CG\_coupled\_div = field\_parser.next(input\_params.CG\_coupled\_div);
94     \}
95     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledIterMax"}) )
96     \{
97         input\_params.CG\_coupled\_conv\_max = field\_parser.next(input\_params.CG\_coupled\_conv\_max);
98     \}
99 
100     \textcolor{keywordflow}{if} ( field\_parser.search(1, \textcolor{stringliteral}{"CGPreconditionerType"}) )
101     \{
102         std::string CG\_precond\_type\_string = field\_parser.next(CG\_precond\_type\_string);
103         \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"NONE"})
104             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{carl::BaseCGPrecondType::NO\_PRECONDITIONER};
105         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"Coupling\_operator"})
106             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{carl::BaseCGPrecondType::COUPLING\_OPERATOR};
107         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"Coupling\_operator\_jacobi"})
108             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{carl::BaseCGPrecondType::COUPLING\_JACOBI};
109         \textcolor{keywordflow}{else}
110             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid preconditionner type!"});
111     \} \textcolor{keywordflow}{else} \{
112         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing preconditionner type!"});
113     \}
114 \};
\end{DoxyCode}
\hypertarget{namespacecarl_afe02e73d82d3c09395afe0e786840369}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, feti\+\_\+setup\+\_\+finish\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf feti\+\_\+setup\+\_\+finish\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_afe02e73d82d3c09395afe0e786840369}


Parser function for the coupled solver test programs. 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Cluster\+Scheduler\+Type} \+: scheduler type. {\itshape Values}\+: L\+O\+C\+A\+L, P\+B\+S or S\+L\+U\+R\+M (code not implemented for the later yet, {\ttfamily L\+O\+C\+A\+L} runs the code without a scheduler).
\item {\ttfamily Scratch\+Folder\+Path} \+: path to the folder where the temporary files used by the coupled solver will be saved.
\item {\ttfamily Coupling\+Matrices\+Folder} \+: path to the folder containing the coupling matrices.
\end{DoxyItemize}

F\+E\+T\+I / C\+G optional parameters\+:
\begin{DoxyItemize}
\item {\ttfamily C\+G\+Preconditioner\+Type} \+: C\+G preconditioner type. {\itshape Values}\+: \char`\"{}\+N\+O\+N\+E\char`\"{}, \char`\"{}\+Coupling\+\_\+operator\char`\"{} or \char`\"{}\+Coupling\+\_\+operator\+\_\+jacobi\char`\"{}.
\end{DoxyItemize}

Boolean flags\+:
\begin{DoxyItemize}
\item {\ttfamily Use\+Rigid\+Body\+Modes\+B} \+: use the rigid body modes for system B.
\end{DoxyItemize}

Rigid body mode parameters (only read if {\ttfamily Use\+Rigid\+Body\+Modes\+B} is used)\+:
\begin{DoxyItemize}
\item {\ttfamily R\+B\+Vector\+Base} \+: filename base of the rigid body modes vectors.
\item {\ttfamily Nb\+Of\+R\+B\+Vectors} \+: number of R\+B mode vectors. {\itshape Default}\+: 6. 
\end{DoxyItemize}

Definition at line 13 of file carl\+\_\+feti\+\_\+setup\+\_\+finish\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
14                                                 \{
15 
16     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ClusterSchedulerType"})) \{
17         std::string cluster\_scheduler\_type;
18         cluster\_scheduler\_type = field\_parser.next(cluster\_scheduler\_type);
19         \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"LOCAL"})
20         \{
21             std::cout << \textcolor{stringliteral}{" !!! WARNING: "} << std::endl;
22             std::cout << \textcolor{stringliteral}{"        Using the LOCAL job 'scheduler'. You will have to launch each script"} << 
      std::endl;
23             std::cout << \textcolor{stringliteral}{"     MANUALLY!!! Reason: MPI does not support recursive 'mpirun' calls"} << 
      std::endl;
24             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{carl::ClusterSchedulerType::LOCAL};
25         \}
26         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"PBS"})
27             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{carl::ClusterSchedulerType::PBS};
28         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"SLURM"})
29             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{carl::ClusterSchedulerType::SLURM};
30         \textcolor{keywordflow}{else}
31             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid scheduler type!"});
32     \} \textcolor{keywordflow}{else} \{
33         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the scheduler type!"});
34     \}
35 
36     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ScratchFolderPath"})) \{
37         input\_params.scratch\_folder\_path = field\_parser.next(
38                 input\_params.scratch\_folder\_path);
39     \} \textcolor{keywordflow}{else} \{
40         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external scratch folder path!"});
41     \}
42 
43     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"CouplingMatricesFolder"})) \{
44         input\_params.coupling\_folder\_path = field\_parser.next(
45                 input\_params.coupling\_folder\_path);
46     \} \textcolor{keywordflow}{else} \{
47         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling matrices path!"});
48     \}
49 
50     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"UseRigidBodyModesB"}))
51     \{
52         input\_params.bUseRigidBodyModes = \textcolor{keyword}{true};
53         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"RBVectorBase"})) \{
54             input\_params.RB\_vectors\_base = field\_parser.next(
55                     input\_params.RB\_vectors\_base);
56         \} \textcolor{keywordflow}{else} \{
57             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the system B's rigid body mode vectors!"});
58         \}
59         
60         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"NbOfRBVectors"})) \{
61             input\_params.nb\_of\_rb\_vectors = field\_parser.next(
62                     input\_params.nb\_of\_rb\_vectors);
63         \} \textcolor{keywordflow}{else} \{
64             input\_params.nb\_of\_rb\_vectors = 6;
65         \}
66     \} \textcolor{keywordflow}{else} \{
67         input\_params.bUseRigidBodyModes = \textcolor{keyword}{false};
68     \}
69 
70     \textcolor{keywordflow}{if} ( field\_parser.search(1, \textcolor{stringliteral}{"CGPreconditionerType"}) )
71     \{
72         std::string CG\_precond\_type\_string = field\_parser.next(CG\_precond\_type\_string);
73         \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"NONE"})
74             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{carl::BaseCGPrecondType::NO\_PRECONDITIONER};
75         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"Coupling\_operator"})
76             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{carl::BaseCGPrecondType::COUPLING\_OPERATOR};
77         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"Coupling\_operator\_jacobi"})
78             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{carl::BaseCGPrecondType::COUPLING\_JACOBI};
79         \textcolor{keywordflow}{else}
80             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid preconditionner type!"});
81     \} \textcolor{keywordflow}{else} \{
82         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing preconditionner type!"});
83     \}
84 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a35e71784d7728be3e70e52362caeb2e2}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, feti\+\_\+setup\+\_\+init\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf feti\+\_\+setup\+\_\+init\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_a35e71784d7728be3e70e52362caeb2e2}


Parser function for the coupled solver test programs. 

Required parameters\+:
\begin{DoxyItemize}
\item External solvers
\begin{DoxyItemize}
\item {\ttfamily Cluster\+Scheduler\+Type} \+: scheduler type. {\itshape Values}\+: L\+O\+C\+A\+L, P\+B\+S or S\+L\+U\+R\+M (code not implemented for the later yet, {\ttfamily L\+O\+C\+A\+L} runs the code without a scheduler).
\item {\ttfamily Ext\+Solver\+A} \+: command line for the external solver for system A.
\item {\ttfamily Ext\+Solver\+B} \+: command line for the external solver for system B.
\item {\ttfamily Ext\+Solver\+A\+Type} \+: type of external solver used for system A. {\itshape Values}\+: {\ttfamily L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R}.
\item {\ttfamily Ext\+Solver\+B\+Type} \+: type of external solver used for system B. {\itshape Values}\+: {\ttfamily L\+I\+B\+M\+E\+S\+H\+\_\+\+L\+I\+N\+E\+A\+R}.
\item {\ttfamily Ext\+Solver\+A\+Input} \+: path to a file containing the input parameters of the external solve for system A.
\item {\ttfamily Ext\+Solver\+B\+Input} \+: path to a file containing the input parameters of the external solve for system B.
\end{DoxyItemize}
\end{DoxyItemize}

Coupled solver
\begin{DoxyItemize}
\item {\ttfamily Scratch\+Folder\+Path} \+: path to the folder where the temporary files used by the coupled solver will be saved.
\item {\ttfamily Script\+File} \+: path to the file used to generate the scripts.
\item {\ttfamily Coupling\+Matrices\+Folder} \+: path to the folder containing the coupling matrices.
\item {\ttfamily Output\+Folder} \+: path to the coupled solution folder.
\end{DoxyItemize}

Boolean flags\+:
\begin{DoxyItemize}
\item {\ttfamily Use\+Rigid\+Body\+Modes\+B} \+: use the rigid body modes for system B.
\end{DoxyItemize}

Rigid body mode parameters (only read if {\ttfamily Use\+Rigid\+Body\+Modes\+B} is used)\+:
\begin{DoxyItemize}
\item {\ttfamily Ext\+Force\+System\+B} \+: path to the vector containing the external forces for the system B.
\item {\ttfamily R\+B\+Vector\+Base} \+: filename base of the rigid body modes vectors.
\item {\ttfamily Nb\+Of\+R\+B\+Vectors} \+: number of R\+B mode vectors. {\itshape Default}\+: 6.
\end{DoxyItemize}

Optional parameters\+:
\begin{DoxyItemize}
\item F\+E\+T\+I / C\+G optional parameters\+:
\begin{DoxyItemize}
\item {\ttfamily C\+G\+Preconditioner\+Type} \+: C\+G preconditioner type. {\itshape Values}\+: \char`\"{}\+N\+O\+N\+E\char`\"{}, \char`\"{}\+Coupling\+\_\+operator\char`\"{} or \char`\"{}\+Coupling\+\_\+operator\+\_\+jacobi\char`\"{}. {\itshape Default}\+: \char`\"{}\+Coupling\+\_\+operator\char`\"{}.
\item {\ttfamily Coupled\+Conv\+Abs} \+: C\+G absolute convergence on the residual. {\itshape Default}\+: 1e-\/20.
\item {\ttfamily Coupled\+Conv\+Rel} \+: C\+G relative convergence on the residual. {\itshape Default}\+: 1e-\/5.
\item {\ttfamily Coupled\+Corr\+Conv\+Rel} \+: C\+G relative convergence on the rigid body corrections. {\itshape Default}\+: 1e-\/6.
\item {\ttfamily Coupled\+Div} \+: C\+G residual divergence parameter. {\itshape Default}\+: 100000.
\item {\ttfamily Coupled\+Iter\+Max} \+: C\+G maximum number of iterations. {\itshape Default}\+: 1000. 
\end{DoxyItemize}
\end{DoxyItemize}

Definition at line 13 of file carl\+\_\+feti\+\_\+setup\+\_\+init\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
14                                               \{
15 
16     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ClusterSchedulerType"})) \{
17         std::string cluster\_scheduler\_type;
18         cluster\_scheduler\_type = field\_parser.next(cluster\_scheduler\_type);
19         \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"LOCAL"})
20         \{
21             std::cout << \textcolor{stringliteral}{" !!! WARNING: "} << std::endl;
22             std::cout << \textcolor{stringliteral}{"        The LOCAL 'scheduler' type is only intended for small and fast test cases
      "} << std::endl;
23             std::cout << \textcolor{stringliteral}{"     on computers without a job scheduler (PBS, SLURM). You will have to launch"} 
      << std::endl;
24             std::cout << \textcolor{stringliteral}{"     each script MANUALLY!!! Reason: MPI does not support recursive 'mpirun'
       calls"} << std::endl;
25             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a2bec097bc495ac4aacc355d3283f4b93}{carl::ClusterSchedulerType::LOCAL};
26         \}
27         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"PBS"})
28             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1adc92b93f87f72ed91ac097d8c15da06e}{carl::ClusterSchedulerType::PBS};
29         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cluster\_scheduler\_type == \textcolor{stringliteral}{"SLURM"})
30             input\_params.scheduler = \hyperlink{namespacecarl_a67066fdf35a0c326f5147098c0cf45d1a07a7582870a2087891d8eeaddf964ba0}{carl::ClusterSchedulerType::SLURM};
31         \textcolor{keywordflow}{else}
32             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid scheduler type!"});
33     \} \textcolor{keywordflow}{else} \{
34         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the scheduler type!"});
35     \}
36 
37     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtSolverA"})) \{
38         input\_params.ext\_solver\_BIG = field\_parser.next(
39                 input\_params.ext\_solver\_BIG);
40         std::cout << input\_params.ext\_solver\_BIG << std::endl;
41     \} \textcolor{keywordflow}{else} \{
42         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external solver A command line!"});
43     \}
44 
45     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtSolverB"})) \{
46         input\_params.ext\_solver\_micro = field\_parser.next(
47                 input\_params.ext\_solver\_micro);
48         std::cout << input\_params.ext\_solver\_micro << std::endl;
49     \} \textcolor{keywordflow}{else} \{
50         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external solver B command line!"});
51     \}
52 
53     std::string ext\_solver\_type;
54     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtSolverAType"})) \{
55         ext\_solver\_type = field\_parser.next(
56                 ext\_solver\_type);
57         std::cout << ext\_solver\_type << std::endl;
58         \textcolor{keywordflow}{if}(ext\_solver\_type == \textcolor{stringliteral}{"LIBMESH\_LINEAR"})
59         \{
60             input\_params.ext\_solver\_BIG\_type = 
      \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}{carl::ExtSolverType::LIBMESH\_LINEAR};
61         \} \textcolor{keywordflow}{else} \{ 
62             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid external solver A type!"});
63         \}
64     \} \textcolor{keywordflow}{else} \{
65         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external solver A type!"});
66     \}
67 
68     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtSolverBType"})) \{
69         ext\_solver\_type = field\_parser.next(
70                 ext\_solver\_type);
71         std::cout << ext\_solver\_type << std::endl;
72         \textcolor{keywordflow}{if}(ext\_solver\_type == \textcolor{stringliteral}{"LIBMESH\_LINEAR"})
73         \{
74             input\_params.ext\_solver\_BIG\_type = 
      \hyperlink{namespacecarl_a384c8e69965cba9e6e52667c8cefff08a47a0d1839c47dee4ea3610e710d7abaa}{carl::ExtSolverType::LIBMESH\_LINEAR};
75         \} \textcolor{keywordflow}{else} \{ 
76             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Invalid external solver B type!"});
77         \}
78     \} \textcolor{keywordflow}{else} \{
79         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external solver B type!"});
80     \}
81 
82     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtSolverAInput"})) \{
83         input\_params.ext\_solver\_BIG\_input = field\_parser.next(
84                 input\_params.ext\_solver\_BIG\_input);
85         std::cout << input\_params.ext\_solver\_BIG\_input << std::endl;
86     \} \textcolor{keywordflow}{else} \{
87         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the input file for the external solver A!"});
88     \}
89 
90     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtSolverBInput"})) \{
91         input\_params.ext\_solver\_micro\_input = field\_parser.next(
92                 input\_params.ext\_solver\_micro\_input);
93         std::cout << input\_params.ext\_solver\_micro\_input << std::endl;
94     \} \textcolor{keywordflow}{else} \{
95         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the input file for the external solver B!"});
96     \}
97 
98     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ScratchFolderPath"})) \{
99         input\_params.scratch\_folder\_path = field\_parser.next(
100                 input\_params.scratch\_folder\_path);
101         std::cout << input\_params.scratch\_folder\_path << std::endl;
102     \} \textcolor{keywordflow}{else} \{
103         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external scratch folder path!"});
104     \}
105 
106     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ScriptFile"})) \{
107         input\_params.script\_filename = field\_parser.next(
108                 input\_params.script\_filename);
109         std::cout << input\_params.script\_filename << std::endl;
110     \} \textcolor{keywordflow}{else} \{
111         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the script file!"});
112     \}
113 
114     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"CouplingMatricesFolder"})) \{
115         input\_params.coupling\_folder\_path = field\_parser.next(
116                 input\_params.coupling\_folder\_path);
117         std::cout << input\_params.coupling\_folder\_path << std::endl;
118     \} \textcolor{keywordflow}{else} \{
119         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling matrices path!"});
120     \}
121 
122     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"UseRigidBodyModesB"}))
123     \{
124         input\_params.bUseRigidBodyModes = \textcolor{keyword}{true};
125         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ExtForceSystemB"})) \{
126             input\_params.force\_micro\_path = field\_parser.next(
127                     input\_params.force\_micro\_path);
128             std::cout << input\_params.force\_micro\_path << std::endl;
129         \} \textcolor{keywordflow}{else} \{
130             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the system B's external force file path!"});
131         \}
132 
133         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"RBVectorBase"})) \{
134             input\_params.RB\_vectors\_base = field\_parser.next(
135                     input\_params.RB\_vectors\_base);
136             std::cout << input\_params.RB\_vectors\_base << std::endl;
137         \} \textcolor{keywordflow}{else} \{
138             \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the system B's rigid body mode vectors!"});
139         \}
140         
141         \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"NbOfRBVectors"})) \{
142             input\_params.nb\_of\_rb\_vectors = field\_parser.next(
143                     input\_params.nb\_of\_rb\_vectors);
144         \} \textcolor{keywordflow}{else} \{
145             input\_params.nb\_of\_rb\_vectors = 6;
146         \}
147     \}
148     \textcolor{keywordflow}{else}
149     \{
150         input\_params.bUseRigidBodyModes = \textcolor{keyword}{false};
151     \}
152 
153     \textcolor{comment}{// Set CG coupling solver convergence}
154     input\_params.CG\_coupled\_conv\_abs = 1e-20;
155     input\_params.CG\_coupled\_conv\_rel = 1e-5;
156     input\_params.CG\_coupled\_div = 1e5;
157     input\_params.CG\_coupled\_conv\_max = 1e4;
158     input\_params.CG\_coupled\_conv\_corr =1e-5;
159 
160     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledConvAbs"}) )
161     \{
162         input\_params.CG\_coupled\_conv\_abs = field\_parser.next(input\_params.CG\_coupled\_conv\_abs);
163     \}
164     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledConvRel"}) )
165     \{
166         input\_params.CG\_coupled\_conv\_rel = field\_parser.next(input\_params.CG\_coupled\_conv\_rel);
167     \}
168     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledCorrConvRel"}) )
169     \{
170         input\_params.CG\_coupled\_conv\_corr = field\_parser.next(input\_params.CG\_coupled\_conv\_corr);
171     \}
172     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledDiv"}) )
173     \{
174         input\_params.CG\_coupled\_div = field\_parser.next(input\_params.CG\_coupled\_div);
175     \}
176     \textcolor{keywordflow}{if}( field\_parser.search(1,\textcolor{stringliteral}{"CoupledIterMax"}) )
177     \{
178         input\_params.CG\_coupled\_conv\_max = field\_parser.next(input\_params.CG\_coupled\_conv\_max);
179     \}
180     
181     input\_params.CG\_precond\_type = \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{carl::BaseCGPrecondType::COUPLING\_OPERATOR}
      ;
182     \textcolor{keywordflow}{if} ( field\_parser.search(1, \textcolor{stringliteral}{"CGPreconditionerType"}) )
183     \{
184         std::string CG\_precond\_type\_string = field\_parser.next(CG\_precond\_type\_string);
185         \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"NONE"})
186             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8ad142a27fc7dfef6e36c5d01689880cc4}{carl::BaseCGPrecondType::NO\_PRECONDITIONER};
187         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"Coupling\_operator"})
188             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a0bdc3f2b24ccb8a7783e5cc3845f66f4}{carl::BaseCGPrecondType::COUPLING\_OPERATOR};
189         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(CG\_precond\_type\_string == \textcolor{stringliteral}{"Coupling\_operator\_jacobi"})
190             input\_params.CG\_precond\_type = 
      \hyperlink{namespacecarl_ad52f21755b51ffa926038b59ae194ea8a9e4642aac714757473ea34db75279a99}{carl::BaseCGPrecondType::COUPLING\_JACOBI};
191     \}
192 
193     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"OutputFolder"})) \{
194         input\_params.output\_folder = field\_parser.next(
195                 input\_params.output\_folder);
196     \} \textcolor{keywordflow}{else} \{
197         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the output filename base!"});
198     \}
199 \};
\end{DoxyCode}
\hypertarget{namespacecarl_aebc298614cba13aa318064e3ad08bc10}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, carl\+\_\+mult\+\_\+coupling\+\_\+input\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf carl\+\_\+mult\+\_\+coupling\+\_\+input\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_aebc298614cba13aa318064e3ad08bc10}


Parser function for the coupling matrix multiplication operation. 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Coupl\+Matrix} or {\ttfamily -\/m\+C}\+: path to the coupling matrix file.
\item {\ttfamily Input\+Vector} or {\ttfamily -\/v\+I}\+: path to the input vector file.
\item {\ttfamily Output\+Base} or {\ttfamily -\/o}\+: output filename base. 
\end{DoxyItemize}

Definition at line 13 of file carl\+\_\+mult\+\_\+coupling\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
14                                                        \{
15 
16     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"CouplMatrix"}, \textcolor{stringliteral}{"-mC"})) \{
17         input\_params.coupl\_matrix\_file = field\_parser.next(
18                 input\_params.coupl\_matrix\_file);
19     \} \textcolor{keywordflow}{else} \{
20         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling matrix file!"});
21     \}
22 
23     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"InputVector"}, \textcolor{stringliteral}{"-vI"})) \{
24         input\_params.input\_vec\_file = field\_parser.next(
25                 input\_params.input\_vec\_file);
26     \} \textcolor{keywordflow}{else} \{
27         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the input vector file!"});
28     \}
29 
30     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"OutputBase"}, \textcolor{stringliteral}{"-o"})) \{
31         input\_params.output\_base = field\_parser.next(
32                 input\_params.output\_base);
33     \} \textcolor{keywordflow}{else} \{
34         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the output filename base!"});
35     \}
36 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a177d464e2a8ca02ee332afc410ec061d}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, feti\+\_\+set\+\_\+sol\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf feti\+\_\+set\+\_\+sol\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_a177d464e2a8ca02ee332afc410ec061d}


Parser function for the coupled solver test programs. 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Scratch\+Folder\+Path} \+: path to the folder where the temporary files used by the coupled solver will be saved.
\item {\ttfamily Output\+Folder} \+: path to the coupled outup folder.
\end{DoxyItemize}

Boolean flags\+:
\begin{DoxyItemize}
\item {\ttfamily Use\+Rigid\+Body\+Modes\+B} \+: use the rigid body modes for system B. 
\end{DoxyItemize}

Definition at line 14 of file carl\+\_\+feti\+\_\+set\+\_\+sol\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
15                                            \{
16 
17     \textcolor{keywordflow}{if} (field\_parser.search(1, \textcolor{stringliteral}{"ScratchFolderPath"})) \{
18         input\_params.scratch\_folder\_path = field\_parser.next(
19                 input\_params.scratch\_folder\_path);
20     \} \textcolor{keywordflow}{else} \{
21         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the external scratch folder path!"});
22     \}
23 
24     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"UseRigidBodyModesB"}))
25     \{
26         input\_params.bUseRigidBodyModes = \textcolor{keyword}{true};
27     \} \textcolor{keywordflow}{else} \{
28         input\_params.bUseRigidBodyModes = \textcolor{keyword}{false};
29     \}
30 
31     \textcolor{keywordflow}{if} (field\_parser.search(1,\textcolor{stringliteral}{"OutputFolder"})) \{
32         input\_params.output\_folder = field\_parser.next(
33                 input\_params.output\_folder);
34     \} \textcolor{keywordflow}{else} \{
35         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the output filename base!"});
36     \}
37 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a3e93400b1873e44916865a36944134fa}{}\index{carl@{carl}!get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}}
\index{get\+\_\+input\+\_\+params@{get\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, libmesh\+\_\+apply\+\_\+solution\+\_\+input\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf libmesh\+\_\+apply\+\_\+solution\+\_\+input\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_a3e93400b1873e44916865a36944134fa}


Parser function for mesh deformation (apply solution) programs. 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Input\+Vector} or {\ttfamily -\/-\/input-\/vec}\+: path to the input vector containing the displacements.
\item {\ttfamily Input\+Mesh} or {\ttfamily -\/-\/input-\/mesh}\+: path to the mesh that will be deformed.
\item {\ttfamily Physical\+Parameters} or {\ttfamily -\/-\/physical-\/params}\+: physical parameters file.
\item {\ttfamily Output\+Mesh} or {\ttfamily -\/-\/output-\/mesh}\+: path to the output mesh. 
\end{DoxyItemize}

Definition at line 12 of file libmesh\+\_\+apply\+\_\+solution\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
13                                                            \{
14 
15     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"InputVector"}, \textcolor{stringliteral}{"--input-vec"} )) \{
16         input\_params.input\_vector = field\_parser.next(
17                 input\_params.input\_vector);
18     \} \textcolor{keywordflow}{else} \{
19         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the displacement field vector!"});
20     \}
21 
22     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"InputMesh"}, \textcolor{stringliteral}{"--input-mesh"})) \{
23         input\_params.input\_mesh = field\_parser.next(
24                 input\_params.input\_mesh);
25     \} \textcolor{keywordflow}{else} \{
26         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the input mesh!"});
27     \}
28 
29     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"PhysicalParameters"}, \textcolor{stringliteral}{"--physical-params"})) \{
30         input\_params.physical\_params\_file = field\_parser.next(
31                 input\_params.physical\_params\_file);
32     \} \textcolor{keywordflow}{else} \{
33         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the physical params file!"});
34     \}
35 
36     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"OutputMesh"}, \textcolor{stringliteral}{"--output-mesh"})) \{
37         input\_params.output\_mesh = field\_parser.next(
38                 input\_params.output\_mesh);
39     \} \textcolor{keywordflow}{else} \{
40         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the output mesh path!"});
41     \}
42 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ab80eec3eb20ff6a403ad01bafa649df2}{}\index{carl@{carl}!get\+\_\+intersection\+\_\+input\+\_\+params@{get\+\_\+intersection\+\_\+input\+\_\+params}}
\index{get\+\_\+intersection\+\_\+input\+\_\+params@{get\+\_\+intersection\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{get\+\_\+intersection\+\_\+input\+\_\+params(\+Get\+Pot \&field\+\_\+parser, parallel\+\_\+intersection\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::get\+\_\+intersection\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{Get\+Pot \&}]{field\+\_\+parser, }
\item[{{\bf parallel\+\_\+intersection\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_ab80eec3eb20ff6a403ad01bafa649df2}


Parser function for the parallel intersection search program (source\+: \hyperlink{_c_arl__build__intersections_8cpp}{C\+Arl\+\_\+build\+\_\+intersections.\+cpp}) 

Required parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Mesh\+A}, {\ttfamily -\/m\+A} or {\ttfamily -\/-\/mesh\+A} \+: path to the mesh A.
\item {\ttfamily Mesh\+B}, {\ttfamily -\/m\+B} or {\ttfamily -\/-\/mesh\+B} \+: path to the mesh B.
\item {\ttfamily Mesh\+C}, {\ttfamily -\/m\+C} or {\ttfamily -\/-\/mesh\+C} \+: path to the coupling mesh C.
\end{DoxyItemize}

Optional parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Output\+Base}, {\ttfamily -\/m\+O} or {\ttfamily -\/-\/output} \+: base of the output files (including folders). {\itshape Default}\+: {\ttfamily test\+\_\+inter}.
\item {\ttfamily Meshing\+Method} or {\ttfamily -\/-\/meshing\+Method\+Type} \+: intersection meshing method. {\itshape Values}\+: {\ttfamily C\+G\+A\+L} or {\ttfamily L\+I\+B\+M\+E\+S\+H\+\_\+\+T\+E\+T\+G\+E\+N}. {\itshape Default}\+: {\ttfamily C\+G\+A\+L}.
\end{DoxyItemize}

Boolean flags\+:
\begin{DoxyItemize}
\item {\ttfamily Stitch\+Inter\+Meshes} \+: do not stich together the intersection meshes.
\item {\ttfamily Verbose\+Output} or {\ttfamily -\/-\/verbose} \+: print some extra information, such as the coupling mesh partitioning. 
\end{DoxyItemize}

Definition at line 12 of file intersection\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
13                                                     \{
14 
15     \textcolor{comment}{// Set mesh files}
16     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshA"}, \textcolor{stringliteral}{"-mA"}, \textcolor{stringliteral}{"MeshA"})) \{
17         input\_params.mesh\_A = field\_parser.next(
18                 input\_params.mesh\_A);
19     \} \textcolor{keywordflow}{else} \{
20         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing mesh A!"}); 
21     \}
22 
23     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshB"}, \textcolor{stringliteral}{"-mB"}, \textcolor{stringliteral}{"MeshB"})) \{
24         input\_params.mesh\_B = field\_parser.next(
25                 input\_params.mesh\_B);
26     \} \textcolor{keywordflow}{else} \{
27         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing mesh B!"}); 
28     \}
29 
30     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--meshC"}, \textcolor{stringliteral}{"-mC"}, \textcolor{stringliteral}{"MeshC"})) \{
31         input\_params.mesh\_C = field\_parser.next(
32                 input\_params.mesh\_C);
33     \} \textcolor{keywordflow}{else} \{
34         \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{"Missing the coupling mesh C!"}); 
35     \}
36 
37     \textcolor{keywordflow}{if} (field\_parser.search(3, \textcolor{stringliteral}{"--output"}, \textcolor{stringliteral}{"-mO"}, \textcolor{stringliteral}{"OutputBase"})) \{
38         input\_params.output\_base = field\_parser.next(
39                 input\_params.output\_base);
40     \} \textcolor{keywordflow}{else} \{
41         input\_params.output\_base = \textcolor{stringliteral}{"inter\_search"};
42     \}
43 
44     std::string meshing\_method;
45     input\_params.inter\_meshing\_method = \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa509162a828acac7eaad1fc369696a3b1}{carl::IntersectionMeshingMethod::CGAL}
      ;
46     \textcolor{keywordflow}{if} (field\_parser.search(2, \textcolor{stringliteral}{"--meshingMethodType"}, \textcolor{stringliteral}{"MeshingMethod"})) \{
47         meshing\_method = field\_parser.next(
48                 meshing\_method);
49         \textcolor{keywordflow}{if}(meshing\_method == \textcolor{stringliteral}{"CGAL"})
50         \{
51             input\_params.inter\_meshing\_method = 
      \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa509162a828acac7eaad1fc369696a3b1}{carl::IntersectionMeshingMethod::CGAL};
52         \}
53         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(meshing\_method == \textcolor{stringliteral}{"TETGEN"} )
54         \{
55             input\_params.inter\_meshing\_method = 
      \hyperlink{namespacecarl_a4f72fd25137b97ac1ca1276ec549e5cfa0a91b3dbac7fab7e5efa6f804aab8f58}{carl::IntersectionMeshingMethod::LIBMESH\_TETGEN};
56         \}
57     \}
58 
59     \textcolor{keywordflow}{if}(field\_parser.search(1,\textcolor{stringliteral}{"StitchInterMeshes"})) \{
60         input\_params.bStitchInterMeshes = \textcolor{keyword}{true};
61     \}
62     \textcolor{keywordflow}{else}
63     \{
64         input\_params.bStitchInterMeshes = \textcolor{keyword}{false};
65     \}
66 
67     \textcolor{keywordflow}{if}(field\_parser.search(2,\textcolor{stringliteral}{"VerboseOutput"}, \textcolor{stringliteral}{"--verbose"})) \{
68         input\_params.bVerbose = \textcolor{keyword}{true};
69     \}
70     \textcolor{keywordflow}{else}
71     \{
72         input\_params.bVerbose = \textcolor{keyword}{false};
73     \}
74 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a543276bdc1b659a9373b4255892b7174}{}\index{carl@{carl}!invert\+\_\+index\+\_\+unordered\+\_\+map@{invert\+\_\+index\+\_\+unordered\+\_\+map}}
\index{invert\+\_\+index\+\_\+unordered\+\_\+map@{invert\+\_\+index\+\_\+unordered\+\_\+map}!carl@{carl}}
\subsubsection[{invert\+\_\+index\+\_\+unordered\+\_\+map(const std\+::unordered\+\_\+map$<$ int, int $>$ \&input\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&output\+\_\+map)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::invert\+\_\+index\+\_\+unordered\+\_\+map (
\begin{DoxyParamCaption}
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{input\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{output\+\_\+map}
\end{DoxyParamCaption}
)}\label{namespacecarl_a543276bdc1b659a9373b4255892b7174}


Definition at line 72 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
75 \{
76     \textcolor{keywordtype}{int} map\_length = input\_map.size();
77     output\_map.reserve(map\_length);
78 
79     std::unordered\_map<int,int>::const\_iterator mapIt = input\_map.begin();
80     std::unordered\_map<int,int>::const\_iterator end\_mapIt = input\_map.end();
81 
82     \textcolor{keywordflow}{for}( ; mapIt != end\_mapIt; ++mapIt)
83     \{
84         output\_map[mapIt->second] = mapIt->first;
85     \}
86 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a48bf9a2c641710d703991550fc480884}{}\index{carl@{carl}!jump\+\_\+lines@{jump\+\_\+lines}}
\index{jump\+\_\+lines@{jump\+\_\+lines}!carl@{carl}}
\subsubsection[{jump\+\_\+lines(\+T \&filestream, unsigned int number\+Of\+Lines=1)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void carl\+::jump\+\_\+lines (
\begin{DoxyParamCaption}
\item[{T \&}]{filestream, }
\item[{unsigned int}]{number\+Of\+Lines = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a48bf9a2c641710d703991550fc480884}


Definition at line 33 of file common\+\_\+functions.\+h.


\begin{DoxyCode}
34 \{
35     std::string dummy;
36     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < numberOfLines; ++iii)
37         std::getline(filestream,dummy);
38 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a21d667c7247b6c0f71917b99c39c50e6}{}\index{carl@{carl}!lump\+\_\+matrix@{lump\+\_\+matrix}}
\index{lump\+\_\+matrix@{lump\+\_\+matrix}!carl@{carl}}
\subsubsection[{lump\+\_\+matrix(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Input, lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Output)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::lump\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{matrix\+Input, }
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{matrix\+Output}
\end{DoxyParamCaption}
)}\label{namespacecarl_a21d667c7247b6c0f71917b99c39c50e6}


Definition at line 3 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
5 \{
6     \textcolor{keywordflow}{if}(matrixOutput.initialized())
7     \{
8         matrixOutput.clear();
9     \}
10 
11     \textcolor{keywordtype}{int} M = matrixInput.m();
12     \textcolor{keywordtype}{int} N = matrixInput.n();
13 
14     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(M == N, \textcolor{stringliteral}{"Lumping: the matrix must be a square matrix"});
15 
16     PetscInt local\_M, local\_N;
17 
18     MatGetLocalSize(matrixInput.mat(),&local\_M,&local\_N);
19 
20     \textcolor{comment}{// It will be a diagonal matrix, so no need of a heavy preallocation}
21     matrixOutput.init(M,N,local\_M,local\_N,1,0);
22 
23     libMesh::PetscVector<libMesh::Number> UnityVec(matrixInput.comm(),M,local\_M);
24     libMesh::PetscVector<libMesh::Number> DummyVector(matrixInput.comm(),M,local\_M);
25 
26     VecSet(UnityVec.vec(),1);
27 
28     UnityVec.close();
29 
30     matrixInput.vector\_mult(DummyVector,UnityVec);
31 
32     MatDiagonalSet(matrixOutput.mat(),DummyVector.vec(),INSERT\_VALUES);
33 
34     matrixOutput.close();
35 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a22f4ac1dab8f592b86201d3fec77b7f7}{}\index{carl@{carl}!lump\+\_\+matrix\+\_\+and\+\_\+invert@{lump\+\_\+matrix\+\_\+and\+\_\+invert}}
\index{lump\+\_\+matrix\+\_\+and\+\_\+invert@{lump\+\_\+matrix\+\_\+and\+\_\+invert}!carl@{carl}}
\subsubsection[{lump\+\_\+matrix\+\_\+and\+\_\+invert(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Input, lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Output)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::lump\+\_\+matrix\+\_\+and\+\_\+invert (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{matrix\+Input, }
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{matrix\+Output}
\end{DoxyParamCaption}
)}\label{namespacecarl_a22f4ac1dab8f592b86201d3fec77b7f7}


Definition at line 37 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
39 \{
40     \textcolor{keywordflow}{if}(matrixOutput.initialized())
41     \{
42         matrixOutput.clear();
43     \}
44 
45     \textcolor{keywordtype}{int} M = matrixInput.m();
46     \textcolor{keywordtype}{int} N = matrixInput.n();
47 
48     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(M == N, \textcolor{stringliteral}{"Lumping: the matrix must be a square matrix"});
49 
50     PetscInt local\_M, local\_N;
51 
52     MatGetLocalSize(matrixInput.mat(),&local\_M,&local\_N);
53 
54     \textcolor{comment}{// It will be a diagonal matrix, so no need of a heavy preallocation}
55     matrixOutput.init(M,N,local\_M,local\_N,1,0);
56 
57     libMesh::PetscVector<libMesh::Number> UnityVec(matrixInput.comm(),M,local\_M);
58     libMesh::PetscVector<libMesh::Number> DummyVector(matrixInput.comm(),M,local\_M);
59 
60     VecSet(UnityVec.vec(),1);
61 
62     UnityVec.close();
63 
64     matrixInput.vector\_mult(DummyVector,UnityVec);
65 
66     DummyVector.reciprocal();
67 
68     MatDiagonalSet(matrixOutput.mat(),DummyVector.vec(),INSERT\_VALUES);
69 
70     matrixOutput.close();
71 \}
\end{DoxyCode}
\hypertarget{namespacecarl_aeb8a38b6b56135f6099cce3470494b23}{}\index{carl@{carl}!lump\+\_\+matrix\+\_\+and\+\_\+invert@{lump\+\_\+matrix\+\_\+and\+\_\+invert}}
\index{lump\+\_\+matrix\+\_\+and\+\_\+invert@{lump\+\_\+matrix\+\_\+and\+\_\+invert}!carl@{carl}}
\subsubsection[{lump\+\_\+matrix\+\_\+and\+\_\+invert(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&matrix\+Input, lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&vec\+Output)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::lump\+\_\+matrix\+\_\+and\+\_\+invert (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{matrix\+Input, }
\item[{lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&}]{vec\+Output}
\end{DoxyParamCaption}
)}\label{namespacecarl_aeb8a38b6b56135f6099cce3470494b23}


Definition at line 73 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
75 \{
76     \textcolor{keywordflow}{if}(vecOutput.initialized())
77     \{
78         vecOutput.clear();
79     \}
80 
81     \textcolor{keywordtype}{int} M = matrixInput.m();
82     \textcolor{keywordtype}{int} N = matrixInput.n();
83 
84     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(M == N, \textcolor{stringliteral}{"Lumping: the matrix must be a square matrix"});
85 
86     PetscInt local\_M, local\_N;
87 
88     MatGetLocalSize(matrixInput.mat(),&local\_M,&local\_N);
89 
90     \textcolor{comment}{// It will be a diagonal matrix, so no need of a heavy preallocation}
91     vecOutput.init(M,local\_M,\textcolor{keyword}{false});
92 
93     libMesh::PetscVector<libMesh::Number> UnityVec(matrixInput.comm(),M,local\_M);
94 
95     VecSet(UnityVec.vec(),1);
96 
97     UnityVec.close();
98 
99     matrixInput.vector\_mult(vecOutput,UnityVec);
100 
101     vecOutput.reciprocal();
102 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a461e9a455e02d991c920b4b56390f326}{}\index{carl@{carl}!M\+P\+I\+\_\+reduce\+\_\+vector@{M\+P\+I\+\_\+reduce\+\_\+vector}}
\index{M\+P\+I\+\_\+reduce\+\_\+vector@{M\+P\+I\+\_\+reduce\+\_\+vector}!carl@{carl}}
\subsubsection[{M\+P\+I\+\_\+reduce\+\_\+vector(std\+::vector$<$ T $>$ \&r, int root, const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+Comm)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void carl\+::\+M\+P\+I\+\_\+reduce\+\_\+vector (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ T $>$ \&}]{r, }
\item[{int}]{root, }
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{Comm}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespacecarl_a461e9a455e02d991c920b4b56390f326}


Definition at line 22 of file mpi\+\_\+carl\+\_\+tools.\+h.


\begin{DoxyCode}
23 \{
24     \textcolor{keywordflow}{if} (Comm.size() > 1 && !r.empty())
25         \{
26             libmesh\_assert(Comm.verify(r.size()));
27 
28             std::vector<T> temp(r);
29             MPI\_Reduce(&temp[0], &r[0], libMesh::cast\_int<int>(r.size()),
30                         libMesh::Parallel::StandardType<T>(&temp[0]), MPI\_SUM, root,
31                         Comm.get());
32         \}
33     \}
\end{DoxyCode}
\hypertarget{namespacecarl_aa3e9c0c8132625807ce645c290edf17f}{}\index{carl@{carl}!P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix@{P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix}}
\index{P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix@{P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix}!carl@{carl}}
\subsubsection[{P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix(\+Mat \&matrix\+\_\+in, Mat \&matrix\+\_\+out)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::\+P\+E\+T\+S\+C\+\_\+invert\+\_\+dense\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{Mat \&}]{matrix\+\_\+in, }
\item[{Mat \&}]{matrix\+\_\+out}
\end{DoxyParamCaption}
)}\label{namespacecarl_aa3e9c0c8132625807ce645c290edf17f}


Definition at line 490 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
491 \{
492     \textcolor{comment}{// WARNING: this operation is extremely expensive for large systems !!!}
493     \textcolor{comment}{//          Only use this for small matrices (example: the 6x6 or 3x3}
494     \textcolor{comment}{//          or 3x3 matrices from the null space projectors,}
495 
496     Mat             Id\_mat;
497     MatFactorInfo   factor\_info;
498     IS              rperm, cperm;
499 
500     \textcolor{comment}{// Duplicate matrix data structures}
501     MatDuplicate(matrix\_in,MAT\_DO\_NOT\_COPY\_VALUES,&matrix\_out);
502     MatDuplicate(matrix\_in,MAT\_DO\_NOT\_COPY\_VALUES,&Id\_mat);
503 
504     \textcolor{comment}{// Create identity}
505     MatZeroEntries(Id\_mat);
506     MatShift(Id\_mat,1);
507 
508     \textcolor{comment}{// Factor input matrix}
509     MatGetOrdering(matrix\_in,MATORDERINGNATURAL,  &rperm,  &cperm);
510     MatFactorInfoInitialize(&factor\_info);
511     MatLUFactor(matrix\_in,rperm,cperm,&factor\_info);
512 
513     \textcolor{comment}{// Calculate inverse}
514     MatMatSolve(matrix\_in,Id\_mat,matrix\_out);
515 
516     \textcolor{comment}{// Reset input's factoring}
517     MatSetUnfactored(matrix\_in);
518 
519     \textcolor{comment}{// Cleanup}
520     MatDestroy(&Id\_mat);
521 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a561696085e75f9b5013bf61e2ef3de9f}{}\index{carl@{carl}!P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast@{P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast}}
\index{P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast@{P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast}!carl@{carl}}
\subsubsection[{P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast(\+Mat mat\+\_\+seq, Vec vec\+\_\+seq\+\_\+in, Vec vec\+\_\+seq\+\_\+out, double a\+\_\+const)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::\+P\+E\+T\+S\+C\+\_\+\+Mat\+Mult\+Scale\+\_\+\+Bcast (
\begin{DoxyParamCaption}
\item[{Mat}]{mat\+\_\+seq, }
\item[{Vec}]{vec\+\_\+seq\+\_\+in, }
\item[{Vec}]{vec\+\_\+seq\+\_\+out, }
\item[{double}]{a\+\_\+const}
\end{DoxyParamCaption}
)}\label{namespacecarl_a561696085e75f9b5013bf61e2ef3de9f}


Definition at line 523 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
524 \{
525     \textcolor{comment}{// Calculate the product vec\_seq\_out = a\_const * (mat\_seq * vec\_seq\_in)}
526     \textcolor{comment}{// on the first processor, and then sync the result}
527     
528     \textcolor{comment}{// First, check if the matrices and vectors are sequential}
529     MatType mat\_type\_query;
530     VecType vec\_in\_type\_query;
531     VecType vec\_out\_type\_query;
532 
533     MatGetType(mat\_seq,&mat\_type\_query);
534     VecGetType(vec\_seq\_in,&vec\_in\_type\_query);
535     VecGetType(vec\_seq\_out,&vec\_out\_type\_query);
536 
537     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(std::strcmp(mat\_type\_query,MATSEQDENSE) == 0 ,\textcolor{stringliteral}{"Matrix is not
       dense and sequential"});
538     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(std::strcmp(vec\_in\_type\_query,VECSEQ) == 0 ,\textcolor{stringliteral}{"Input vector is not
       sequential"});
539     \hyperlink{common__header_8h_a593ccc80b790b2268653fcf6597bf451}{homemade\_assert\_msg}(std::strcmp(vec\_out\_type\_query,VECSEQ) == 0 ,\textcolor{stringliteral}{"Output vector is
       not sequential"});
540 
541     \textcolor{comment}{// Get the vector dimension}
542     PetscInt vec\_dim = 0;
543     VecGetSize(vec\_seq\_in,&vec\_dim);
544 
545     \textcolor{comment}{// Get the ranks}
546     \textcolor{keywordtype}{int} rank;
547     MPI\_Comm\_rank(PETSC\_COMM\_WORLD, &rank);
548 
549     \textcolor{comment}{// Set the dummy pointer and vector}
550     PetscScalar * dummy\_seq\_array;
551     
552     \textcolor{comment}{// Do the product in the first processor}
553     \textcolor{keywordflow}{if}(rank == 0)
554     \{
555         MatMult(mat\_seq,vec\_seq\_in,vec\_seq\_out);
556         VecScale(vec\_seq\_out,a\_const);
557     \}
558 
559     \textcolor{comment}{// Sync}
560     VecGetArray(vec\_seq\_out,&dummy\_seq\_array);
561     MPI\_Bcast(dummy\_seq\_array, vec\_dim, MPIU\_SCALAR, 0, PETSC\_COMM\_WORLD);
562     MPI\_Barrier(PETSC\_COMM\_WORLD);
563     VecRestoreArray(vec\_seq\_out,&dummy\_seq\_array);
564 \}
\end{DoxyCode}
\hypertarget{namespacecarl_ada1b77b2d0f0c7274a9457ba20e16a68}{}\index{carl@{carl}!print\+\_\+input\+\_\+params@{print\+\_\+input\+\_\+params}}
\index{print\+\_\+input\+\_\+params@{print\+\_\+input\+\_\+params}!carl@{carl}}
\subsubsection[{print\+\_\+input\+\_\+params(const std\+::string \&output\+\_\+filename, libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params \&input\+\_\+params)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+input\+\_\+params (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{output\+\_\+filename, }
\item[{{\bf libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+params} \&}]{input\+\_\+params}
\end{DoxyParamCaption}
)}\label{namespacecarl_ada1b77b2d0f0c7274a9457ba20e16a68}


Function used to generate a solver input file from \char`\"{}input\+\_\+params\char`\"{}. 



Definition at line 67 of file libmesh\+\_\+solve\+\_\+linear\+\_\+system\+\_\+input\+\_\+parser.\+cpp.


\begin{DoxyCode}
68                                                                 \{
69 
70     std::ofstream output\_file(output\_filename);
71 
72     output\_file << \textcolor{stringliteral}{"SysMatrix "} << input\_params.sys\_matrix\_file << std::endl;
73     output\_file << \textcolor{stringliteral}{"SysRHSVector "} << input\_params.sys\_rhs\_vec\_file << std::endl;
74     output\_file << \textcolor{stringliteral}{"OutputBase "} << input\_params.output\_base << std::endl;
75 
76     output\_file << \textcolor{stringliteral}{"SysEps "} << input\_params.sys\_eps << std::endl;
77     output\_file << \textcolor{stringliteral}{"SysIterDiv "} << input\_params.sys\_iter\_div << std::endl;
78 
79     \textcolor{keywordflow}{if}(input\_params.bUseRBVectors)
80     \{
81         output\_file << \textcolor{stringliteral}{"RBVectorBase "} << input\_params.path\_to\_rb\_vectors << std::endl;
82         output\_file << \textcolor{stringliteral}{"NbOfRBVectors "} << input\_params.nb\_of\_rb\_vectors << std::endl;
83     \}
84 
85     output\_file.close();
86 \};
\end{DoxyCode}
\hypertarget{namespacecarl_acf412e8527bfd67e81b80b71bf3bb479}{}\index{carl@{carl}!print\+\_\+matrix@{print\+\_\+matrix}}
\index{print\+\_\+matrix@{print\+\_\+matrix}!carl@{carl}}
\subsubsection[{print\+\_\+matrix(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+Coupling\+Test\+Matrix)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{Coupling\+Test\+Matrix}
\end{DoxyParamCaption}
)}\label{namespacecarl_acf412e8527bfd67e81b80b71bf3bb479}


Definition at line 104 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
105 \{
106     libMesh::Real accumulator = 0;
107     \textcolor{keyword}{const} libMesh::Parallel::Communicator& MatrixComm =  CouplingTestMatrix.comm();
108 
109     std::cout << \textcolor{stringliteral}{"| M\_i,j : "} << CouplingTestMatrix.m() << \textcolor{stringliteral}{" x "} << CouplingTestMatrix.n() << std::endl;
110 
111     \textcolor{keywordtype}{int} nodes = MatrixComm.size();
112 
113     PetscInt local\_M, local\_N;
114     MatGetLocalSize(CouplingTestMatrix.mat(),&local\_M,&local\_N);
115 
116     \textcolor{keywordtype}{bool} bPrintOnTerminal = CouplingTestMatrix.m() < 101 && CouplingTestMatrix.n() < 101 && nodes > 1;
117     \textcolor{keywordflow}{if}(bPrintOnTerminal)
118     \{
119         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < CouplingTestMatrix.m(); ++iii)
120         \{
121             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} jjj = 0; jjj < CouplingTestMatrix.n(); ++jjj)
122             \{
123                 std::cout << \textcolor{stringliteral}{" "} << CouplingTestMatrix(iii,jjj);
124             \}
125             std::cout << std::endl;
126         \}
127     \}
128 
129     libMesh::PetscVector<libMesh::Number> dummy\_vec(MatrixComm,CouplingTestMatrix.n(),local\_N);
130     MatGetRowSum(CouplingTestMatrix.mat(),dummy\_vec.vec());
131 
132     VecSum(dummy\_vec.vec(),&accumulator);
133     std::cout << \textcolor{stringliteral}{"|"} << std::endl;
134     std::cout << \textcolor{stringliteral}{"| Sum( M\_i,j ) = "} << accumulator << std::endl << std::endl;
135 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a074f0090ce9738ac74ffc852f11f9126}{}\index{carl@{carl}!print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum@{print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum}}
\index{print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum@{print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum}!carl@{carl}}
\subsubsection[{print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+Coupling\+Test\+Matrix, const std\+::string name\+\_\+base)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+matrix\+\_\+col\+\_\+line\+\_\+sum (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{Coupling\+Test\+Matrix, }
\item[{const std\+::string}]{name\+\_\+base}
\end{DoxyParamCaption}
)}\label{namespacecarl_a074f0090ce9738ac74ffc852f11f9126}


Definition at line 137 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
138 \{
139     libMesh::PetscVector<libMesh::Number> col\_sum(CouplingTestMatrix.comm(),CouplingTestMatrix.m());
140     libMesh::PetscVector<libMesh::Number> row\_sum(CouplingTestMatrix.comm(),CouplingTestMatrix.n());
141 
142     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < CouplingTestMatrix.m(); ++iii)
143     \{
144         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} jjj = 0; jjj < CouplingTestMatrix.n(); ++jjj)
145         \{
146             col\_sum.add(iii,CouplingTestMatrix(iii,jjj));
147             row\_sum.add(jjj,CouplingTestMatrix(iii,jjj));
148         \}
149     \}
150 
151 \textcolor{comment}{// Print MatLab debugging output? Variable defined at "carl\_headers.h"}
152 \textcolor{preprocessor}{#ifdef PRINT\_MATLAB\_DEBUG}
153     col\_sum.print\_matlab(name\_base + \textcolor{stringliteral}{"\_col.m"});
154     row\_sum.print\_matlab(name\_base + \textcolor{stringliteral}{"\_row.m"});
155 \textcolor{preprocessor}{#endif}
156 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a8ab4aecb3273c14a472f00cc892f95a0}{}\index{carl@{carl}!print\+\_\+matrix\+\_\+dim@{print\+\_\+matrix\+\_\+dim}}
\index{print\+\_\+matrix\+\_\+dim@{print\+\_\+matrix\+\_\+dim}!carl@{carl}}
\subsubsection[{print\+\_\+matrix\+\_\+dim(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+Coupling\+Test\+Matrix, bool b\+Detailed=false)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+matrix\+\_\+dim (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{Coupling\+Test\+Matrix, }
\item[{bool}]{b\+Detailed = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a8ab4aecb3273c14a472f00cc892f95a0}


Definition at line 165 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
166 \{
167     std::cout << \textcolor{stringliteral}{"| M\_i,j  : "} << CouplingTestMatrix.m() << \textcolor{stringliteral}{" x "} << CouplingTestMatrix.n() << std::endl;
168 \textcolor{comment}{//  if(bDetailed)}
169 \textcolor{comment}{//  \{}
170         MatInfo temp\_info;
171         MatGetInfo(CouplingTestMatrix.mat(),MAT\_LOCAL,&temp\_info);
172         std::cout << \textcolor{stringliteral}{"| LOCAL  : memory = "} << temp\_info.memory << std::endl;
173         std::cout << \textcolor{stringliteral}{"|          non-zeros used = "} << (100.*temp\_info.nz\_used)/temp\_info.nz\_allocated << \textcolor{stringliteral}{"
       % "} << std::endl;
174 
175 \textcolor{comment}{//      int non\_zeros = temp\_info.nz\_used;}
176 \textcolor{comment}{//      std::vector<int> all\_temp\_info;}
177 \textcolor{comment}{//      CouplingTestMatrix.comm().gather(0,non\_zeros,all\_temp\_info);}
178 
179 \textcolor{comment}{//      if(CouplingTestMatrix.comm().rank() == 0)}
180 \textcolor{comment}{//      \{}
181 \textcolor{comment}{//          std::cout << " | ";}
182 \textcolor{comment}{//          for(unsigned int iii = 0; iii < CouplingTestMatrix.comm().size(); ++iii)}
183 \textcolor{comment}{//          \{}
184 \textcolor{comment}{//              std::cout << all\_temp\_info[iii] << " ";}
185 \textcolor{comment}{//          \}}
186 \textcolor{comment}{//          std::cout << std::endl << std::endl;}
187 \textcolor{comment}{//      \}}
188 
189         MatGetInfo(CouplingTestMatrix.mat(),MAT\_GLOBAL\_SUM,&temp\_info);
190         std::cout << \textcolor{stringliteral}{"| GLOBAL : memory = "} << temp\_info.memory << std::endl;
191         std::cout << \textcolor{stringliteral}{"|          non-zeros used = "} << (100.*temp\_info.nz\_used)/temp\_info.nz\_allocated << \textcolor{stringliteral}{"
       % "} << std::endl;
192         std::cout << \textcolor{stringliteral}{"|          total nb. of non-zeros used = "} << temp\_info.nz\_used << std::endl;
193         std::cout << \textcolor{stringliteral}{"|          total nb. of non-zeros allocated = "} << temp\_info.nz\_allocated << 
      std::endl;
194         std::cout << \textcolor{stringliteral}{"|          sparsity = "} << (100.*temp\_info.nz\_used)/(CouplingTestMatrix.m() * 
      CouplingTestMatrix.n()) << \textcolor{stringliteral}{" % "} << std::endl;
195 
196         MatGetInfo(CouplingTestMatrix.mat(),MAT\_GLOBAL\_MAX,&temp\_info);
197         std::cout << \textcolor{stringliteral}{"| MAX    : memory = "} << temp\_info.memory << std::endl;
198         std::cout << \textcolor{stringliteral}{"|          non-zeros used = "} << (100.*temp\_info.nz\_used)/temp\_info.nz\_allocated << \textcolor{stringliteral}{"
       % "} << std::endl << std::endl;
199     \textcolor{comment}{//\}}
200 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a090760429d54397a47cdf55a73dcf078}{}\index{carl@{carl}!print\+\_\+matrix\+\_\+info@{print\+\_\+matrix\+\_\+info}}
\index{print\+\_\+matrix\+\_\+info@{print\+\_\+matrix\+\_\+info}!carl@{carl}}
\subsubsection[{print\+\_\+matrix\+\_\+info(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+Input\+Matrix, std\+::ostream \&os=lib\+Mesh\+::out)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+matrix\+\_\+info (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{Input\+Matrix, }
\item[{std\+::ostream \&}]{os = {\ttfamily libMesh\+:\+:out}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a090760429d54397a47cdf55a73dcf078}


Definition at line 202 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
203 \{
204     \textcolor{keyword}{const} libMesh::Parallel::Communicator& WorldComm = InputMatrix.comm();
205 
206     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rank = WorldComm.rank();
207     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nodes = WorldComm.size();
208 
209     MatInfo local\_info;
210     MatInfo global\_info;
211     MatGetInfo(InputMatrix.mat(),MAT\_LOCAL,&local\_info);
212     MatGetInfo(InputMatrix.mat(),MAT\_LOCAL,&global\_info);
213 
214     \textcolor{comment}{// Set up local variables}
215     \textcolor{keywordtype}{int} l\_nz\_used = local\_info.nz\_used;
216     \textcolor{keywordtype}{int} l\_nz\_allocated = local\_info.nz\_allocated;
217     \textcolor{keywordtype}{int} l\_memory = local\_info.memory;
218 
219     \textcolor{keywordtype}{int} l\_n = -1;
220     \textcolor{keywordtype}{int} l\_m = -1;
221 
222     \textcolor{keywordtype}{double} accumulator\_n = 0;
223     \textcolor{keywordtype}{double} accumulator\_m = 0;
224 
225     MatGetLocalSize(InputMatrix.mat(),&l\_n,&l\_m);
226 
227     std::vector<int>    full\_nz\_used;
228     std::vector<int>    full\_nz\_allocated;
229     std::vector<int>    full\_memory;
230 
231     std::vector<int>    full\_n;
232     std::vector<int>    full\_m;
233 
234     \textcolor{keywordflow}{if}(rank == 0)
235     \{
236         full\_nz\_used.resize(nodes,0);
237         full\_nz\_allocated.resize(nodes,0);
238         full\_memory.resize(nodes,0);
239         full\_n.resize(nodes,0);
240         full\_m.resize(nodes,0);
241     \}
242 
243     WorldComm.gather(0,l\_nz\_used,full\_nz\_used);
244     WorldComm.gather(0,l\_nz\_allocated,full\_nz\_allocated);
245     WorldComm.gather(0,l\_memory,full\_memory);
246     WorldComm.gather(0,l\_n,full\_n);
247     WorldComm.gather(0,l\_m,full\_m);
248 
249     \textcolor{keywordflow}{if}(rank == 0)
250     \{
251         os << \textcolor{stringliteral}{"# rank \(\backslash\)t local\_n \(\backslash\)t local\_m \(\backslash\)t start\_n \(\backslash\)t start\_m \(\backslash\)t nz\_alloc \(\backslash\)t nz\_used \(\backslash\)t memory  "} << 
      std::endl;
252         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < nodes; ++iii)
253         \{
254             os  << iii << \textcolor{stringliteral}{" \(\backslash\)t "}
255                 << full\_n[iii] << \textcolor{stringliteral}{" \(\backslash\)t "}
256                 << full\_m[iii] << \textcolor{stringliteral}{" \(\backslash\)t "}
257                 << accumulator\_n << \textcolor{stringliteral}{" \(\backslash\)t "}
258                 << accumulator\_m << \textcolor{stringliteral}{" \(\backslash\)t "}
259                 << full\_nz\_allocated[iii] << \textcolor{stringliteral}{" \(\backslash\)t "}
260                 << full\_nz\_used[iii] << \textcolor{stringliteral}{" \(\backslash\)t "}
261                 << full\_memory[iii] << std::endl;
262             accumulator\_n += full\_n[iii];
263             accumulator\_m += full\_m[iii];
264         \}
265     \}
266 
267     WorldComm.barrier();
268 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a3c2be3b1f2d9ee68d43525da24e1751b}{}\index{carl@{carl}!print\+\_\+matrix\+\_\+matlab@{print\+\_\+matrix\+\_\+matlab}}
\index{print\+\_\+matrix\+\_\+matlab@{print\+\_\+matrix\+\_\+matlab}!carl@{carl}}
\subsubsection[{print\+\_\+matrix\+\_\+matlab(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+Coupling\+Test\+Matrix, const std\+::string name\+\_\+base)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+matrix\+\_\+matlab (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{Coupling\+Test\+Matrix, }
\item[{const std\+::string}]{name\+\_\+base}
\end{DoxyParamCaption}
)}\label{namespacecarl_a3c2be3b1f2d9ee68d43525da24e1751b}


Definition at line 158 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
159 \{
160     std::cout << \textcolor{stringliteral}{"| M\_i,j : "} << CouplingTestMatrix.m() << \textcolor{stringliteral}{" x "} << CouplingTestMatrix.n() << std::endl;
161 
162     CouplingTestMatrix.print\_matlab(name\_base);
163 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a2405b7b44a0806d66bced8d0905dcb04}{}\index{carl@{carl}!print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}}
\index{print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}!carl@{carl}}
\subsubsection[{print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector(lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+vec, const std\+::string \&filename)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+\+P\+E\+T\+S\+C\+\_\+vector (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&}]{input\+\_\+vec, }
\item[{const std\+::string \&}]{filename}
\end{DoxyParamCaption}
)}\label{namespacecarl_a2405b7b44a0806d66bced8d0905dcb04}
\hypertarget{namespacecarl_a87ce5fcb102a26f69dbef740667eb08b}{}\index{carl@{carl}!print\+\_\+stats\+\_\+to\+\_\+file@{print\+\_\+stats\+\_\+to\+\_\+file}}
\index{print\+\_\+stats\+\_\+to\+\_\+file@{print\+\_\+stats\+\_\+to\+\_\+file}!carl@{carl}}
\subsubsection[{print\+\_\+stats\+\_\+to\+\_\+file(std\+::vector$<$ double $>$ \&vec\+\_\+data, const std\+::string filename)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::print\+\_\+stats\+\_\+to\+\_\+file (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$ \&}]{vec\+\_\+data, }
\item[{const std\+::string}]{filename}
\end{DoxyParamCaption}
)}\label{namespacecarl_a87ce5fcb102a26f69dbef740667eb08b}


Definition at line 126 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
127 \{
128     std::ofstream output\_stream(filename,std::ofstream::app);
129     libMesh::StatisticsVector<double> statistics\_vec(vec\_data.size(),0);
130     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < vec\_data.size(); ++iii)
131     \{
132         statistics\_vec[iii] = vec\_data[iii];
133     \}
134 
135     output\_stream   << statistics\_vec.minimum() << \textcolor{stringliteral}{" "}
136                     << statistics\_vec.maximum() << \textcolor{stringliteral}{" "}
137                     << statistics\_vec.mean() << \textcolor{stringliteral}{" "}
138                     << statistics\_vec.median() << \textcolor{stringliteral}{" "}
139                     << statistics\_vec.stddev() << std::endl;
140 
141     output\_stream.close();
142 \};
\end{DoxyCode}
\hypertarget{namespacecarl_aeceaf9a878847b9ea2f623aa51e3b392}{}\index{carl@{carl}!read\+\_\+local\+\_\+intersection\+\_\+tables@{read\+\_\+local\+\_\+intersection\+\_\+tables}}
\index{read\+\_\+local\+\_\+intersection\+\_\+tables@{read\+\_\+local\+\_\+intersection\+\_\+tables}!carl@{carl}}
\subsubsection[{read\+\_\+local\+\_\+intersection\+\_\+tables(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const std\+::string \&intersection\+\_\+local\+\_\+table\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::read\+\_\+local\+\_\+intersection\+\_\+tables (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const std\+::string \&}]{intersection\+\_\+local\+\_\+table\+\_\+\+Filename, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{local\+\_\+intersection\+\_\+pairs\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map}
\end{DoxyParamCaption}
)}\label{namespacecarl_aeceaf9a878847b9ea2f623aa51e3b392}


Definition at line 546 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
552 \{
553     \textcolor{keywordtype}{int} nbOfIntersections = -1;
554     \textcolor{keywordtype}{int} nbOfInterElems = -1;
555 
556     \textcolor{comment}{// Declare a few auxiliary variables}
557     \textcolor{keywordtype}{int} temp\_interID = -1;
558     \textcolor{keywordtype}{int} temp\_idxA = -1;
559     \textcolor{keywordtype}{int} temp\_idxB = -1;
560     \textcolor{keywordtype}{int} temp\_idxI = -1;
561     \textcolor{keywordtype}{int} temp\_nbOfInter = -1;
562     \textcolor{keywordtype}{int} temp\_dummy = -1;
563 
564     \textcolor{keywordtype}{int} interIdx = 0;
565 
566     \textcolor{comment}{// Do the file reading}
567     std::ifstream intersection\_full\_file(intersection\_local\_table\_Filename);
568 
569     intersection\_full\_file >> nbOfIntersections >> nbOfInterElems >> temp\_dummy;
570 
571     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections; ++iii)
572     \{
573         \textcolor{comment}{// For each line, read ...}
574 
575         \textcolor{comment}{// ... the inter ID, A and B's elements, and the number of I's elements ...}
576         intersection\_full\_file  >> temp\_interID
577                                 >> temp\_idxA >> temp\_idxB
578                                 >> temp\_nbOfInter;
579 
580         local\_intersection\_pairs\_map[temp\_interID] = std::pair<int,int>(temp\_idxA,temp\_idxB);
581 
582         \textcolor{comment}{// ... and all of I's elements}
583         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} jjj = 0; jjj < temp\_nbOfInter; ++jjj)
584         \{
585             intersection\_full\_file >> temp\_idxI;
586             local\_intersection\_meshI\_to\_inter\_map[temp\_idxI] = temp\_interID;
587             ++interIdx;
588         \}
589     \}
590     intersection\_full\_file.close();
591 
592     WorldComm.barrier();
593 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ac9086ba3b6072efdbafaaa5ae53927de}{}\index{carl@{carl}!read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}}
\index{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}!carl@{carl}}
\subsubsection[{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix(\+Mat input\+\_\+mat, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=\+P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{Mat}]{input\+\_\+mat, }
\item[{const std\+::string \&}]{filename, }
\item[{M\+P\+I\+\_\+\+Comm}]{comm = {\ttfamily PETSC\+\_\+COMM\+\_\+WORLD}}
\end{DoxyParamCaption}
)}\label{namespacecarl_ac9086ba3b6072efdbafaaa5ae53927de}


Definition at line 439 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
441 \{
442 
443     PetscViewer    viewer;
444     PetscViewerBinaryOpen(comm,filename.c\_str(),FILE\_MODE\_READ,&viewer);
445     MatLoad(input\_mat,viewer);
446 
447     PetscViewerDestroy(&viewer);
448 \}
\end{DoxyCode}
\hypertarget{namespacecarl_ade169f15d51d4644e74276d155002f22}{}\index{carl@{carl}!read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}}
\index{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}!carl@{carl}}
\subsubsection[{read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+mat, const std\+::string \&filename)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::read\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{input\+\_\+mat, }
\item[{const std\+::string \&}]{filename}
\end{DoxyParamCaption}
)}\label{namespacecarl_ade169f15d51d4644e74276d155002f22}


Definition at line 450 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
452 \{
453     \hyperlink{namespacecarl_ac9086ba3b6072efdbafaaa5ae53927de}{read\_PETSC\_matrix}(input\_mat.mat(),filename,input\_mat.comm().get());
454 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a4d0e2c60b0765dc8182c95362c5d329a}{}\index{carl@{carl}!read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}}
\index{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}!carl@{carl}}
\subsubsection[{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector(lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+vec, const std\+::string \&filename)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&}]{input\+\_\+vec, }
\item[{const std\+::string \&}]{filename}
\end{DoxyParamCaption}
)}\label{namespacecarl_a4d0e2c60b0765dc8182c95362c5d329a}


Definition at line 377 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
379 \{
380     \hyperlink{namespacecarl_a4d0e2c60b0765dc8182c95362c5d329a}{read\_PETSC\_vector}(input\_vec.vec(),filename,input\_vec.comm().get());
381 \};
\end{DoxyCode}
\hypertarget{namespacecarl_afa5184a7f34cda31fcafd0bae53a17bd}{}\index{carl@{carl}!read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}}
\index{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}!carl@{carl}}
\subsubsection[{read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector(\+Vec input\+\_\+vec, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=\+P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::read\+\_\+\+P\+E\+T\+S\+C\+\_\+vector (
\begin{DoxyParamCaption}
\item[{Vec}]{input\+\_\+vec, }
\item[{const std\+::string \&}]{filename, }
\item[{M\+P\+I\+\_\+\+Comm}]{comm = {\ttfamily PETSC\+\_\+COMM\+\_\+WORLD}}
\end{DoxyParamCaption}
)}\label{namespacecarl_afa5184a7f34cda31fcafd0bae53a17bd}


Definition at line 367 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
369 \{
370     PetscViewer    viewer;
371     PetscViewerBinaryOpen(comm,filename.c\_str(),FILE\_MODE\_READ,&viewer);
372     VecLoad(input\_vec,viewer);
373 
374     PetscViewerDestroy(&viewer);
375 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a8b8d75f4ab54390f3e7c607ed4f0cf19}{}\index{carl@{carl}!reduced\+\_\+system\+\_\+init@{reduced\+\_\+system\+\_\+init}}
\index{reduced\+\_\+system\+\_\+init@{reduced\+\_\+system\+\_\+init}!carl@{carl}}
\subsubsection[{reduced\+\_\+system\+\_\+init(\+Sys \&system\+\_\+input)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sys $>$ void carl\+::reduced\+\_\+system\+\_\+init (
\begin{DoxyParamCaption}
\item[{Sys \&}]{system\+\_\+input}
\end{DoxyParamCaption}
)}\label{namespacecarl_a8b8d75f4ab54390f3e7c607ed4f0cf19}


Definition at line 74 of file common\+\_\+functions.\+h.


\begin{DoxyCode}
75 \{
76     libMesh::DofMap& system\_dof\_map = system\_input.get\_dof\_map();
77     libMesh::MeshBase& system\_mesh = system\_input.get\_mesh();
78     
79     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_of\_variable\_groups = system\_input.n\_variable\_groups();
80     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vg=0; vg<nb\_of\_variable\_groups; vg++)
81     \{
82         system\_dof\_map.add\_variable\_group(system\_input.variable\_group(vg));
83     \}
84 
85     system\_dof\_map.distribute\_dofs(system\_mesh);
86     system\_input.reinit\_constraints();
87     system\_dof\_map.prepare\_send\_list();
88     system\_dof\_map.compute\_sparsity(system\_mesh);
89 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ad1869df8fcc16b806a4c0b262922672f}{}\index{carl@{carl}!repartition\+\_\+system\+\_\+meshes@{repartition\+\_\+system\+\_\+meshes}}
\index{repartition\+\_\+system\+\_\+meshes@{repartition\+\_\+system\+\_\+meshes}!carl@{carl}}
\subsubsection[{repartition\+\_\+system\+\_\+meshes(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, lib\+Mesh\+::\+Mesh \&mesh\+\_\+input, lib\+Mesh\+::\+Mesh \&mesh\+\_\+intersect, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+pairs\+\_\+map, bool b\+Use\+Second=true)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::repartition\+\_\+system\+\_\+meshes (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{lib\+Mesh\+::\+Mesh \&}]{mesh\+\_\+input, }
\item[{lib\+Mesh\+::\+Mesh \&}]{mesh\+\_\+intersect, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{local\+\_\+intersection\+\_\+pairs\+\_\+map, }
\item[{bool}]{b\+Use\+Second = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{namespacecarl_ad1869df8fcc16b806a4c0b262922672f}


Definition at line 753 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
759 \{
760     std::vector<double> mesh\_input\_weights;
761     mesh\_input\_weights.resize(mesh\_input.n\_elem(),0);
762 
763     \textcolor{comment}{// Nb. of intersections associated to each elem of mesh\_intersect}
764     std::vector<int>    inter\_per\_elem(mesh\_intersect.n\_elem());
765 
766     std::unordered\_map<int,std::pair<int,int> >::const\_iterator inter\_pairsIt =
767             local\_intersection\_pairs\_map.begin();
768     \textcolor{keyword}{const} std::unordered\_map<int,std::pair<int,int> >::const\_iterator end\_inter\_pairsIt =
769             local\_intersection\_pairs\_map.end();
770     \textcolor{keywordflow}{for}( ; inter\_pairsIt != end\_inter\_pairsIt; ++inter\_pairsIt)
771     \{
772         \textcolor{keyword}{const} std::pair<int,int>& dummy\_pair = inter\_pairsIt->second;
773 
774         \textcolor{keywordflow}{if}(bUseSecond)
775         \{
776             ++inter\_per\_elem[dummy\_pair.first];
777         \}
778         \textcolor{keywordflow}{else}
779         \{
780             ++inter\_per\_elem[dummy\_pair.second];
781         \}
782     \}
783 
784     inter\_pairsIt = local\_intersection\_pairs\_map.begin();
785     \textcolor{keywordflow}{for}( ; inter\_pairsIt != end\_inter\_pairsIt; ++inter\_pairsIt)
786     \{
787         \textcolor{keyword}{const} std::pair<int,int>& dummy\_pair = inter\_pairsIt->second;
788 
789         \textcolor{keywordflow}{if}(bUseSecond)
790         \{
791             mesh\_input\_weights[dummy\_pair.second] += inter\_per\_elem[dummy\_pair.first];
792         \}
793         \textcolor{keywordflow}{else}
794         \{
795             mesh\_input\_weights[dummy\_pair.first] += inter\_per\_elem[dummy\_pair.second];
796         \}
797     \}
798 
799     WorldComm.sum(mesh\_input\_weights);
800 
801     \textcolor{comment}{// Basic partitioning}
802     libMesh::MeshBase::const\_element\_iterator           mesh\_inputIt =
803             mesh\_input.elements\_begin();
804     \textcolor{keyword}{const} libMesh::MeshBase::const\_element\_iterator     end\_mesh\_inputIt =
805             mesh\_input.elements\_end();
806     \textcolor{keywordflow}{for}( ; mesh\_inputIt != end\_mesh\_inputIt; ++mesh\_inputIt )
807     \{
808         \textcolor{keyword}{const} libMesh::Elem* elem\_input = *mesh\_inputIt;
809         \textcolor{keywordtype}{int} idxinput = elem\_input->id();
810 
811         mesh\_input\_weights[idxinput] += elem\_input->n\_nodes();
812     \}
813 
814     libMesh::ErrorVector dummy\_input\_error(mesh\_input.n\_elem());
815     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < mesh\_input.n\_elem(); ++iii)
816         dummy\_input\_error[iii] = mesh\_input\_weights[iii];
817 
818     libMesh::Partitioner * dummy\_partitioner\_input = mesh\_input.partitioner().get();
819     dummy\_partitioner\_input->attach\_weights(&dummy\_input\_error);
820     mesh\_input.partition();
821 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a995bb6a3c01d8cede8268c2f39ce0768}{}\index{carl@{carl}!set\+\_\+equivalence\+\_\+tables@{set\+\_\+equivalence\+\_\+tables}}
\index{set\+\_\+equivalence\+\_\+tables@{set\+\_\+equivalence\+\_\+tables}!carl@{carl}}
\subsubsection[{set\+\_\+equivalence\+\_\+tables(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+A\+\_\+to\+\_\+\+A, std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+R\+\_\+\+B\+\_\+to\+\_\+\+B)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+equivalence\+\_\+tables (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+R\+\_\+\+A\+\_\+to\+\_\+\+A, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+R\+\_\+\+B\+\_\+to\+\_\+\+B}
\end{DoxyParamCaption}
)}\label{namespacecarl_a995bb6a3c01d8cede8268c2f39ce0768}


Definition at line 306 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
315 \{
316     \textcolor{keywordtype}{int} rank = WorldComm.rank();
317 
318     \textcolor{comment}{//  While the equivalence tables are saved as unordered maps, it's easier to}
319     \textcolor{comment}{// save them as vectors at first, broadcast them, and them reconvert to maps}
320     std::vector<int> dummy\_equivalence\_table\_A;
321     std::vector<int> dummy\_equivalence\_table\_B;
322 
323     \textcolor{keywordtype}{int} nbOfRestricted\_A\_Elems = -1;
324     \textcolor{keywordtype}{int} nbOfRestricted\_B\_Elems = -1;
325 
326     \textcolor{comment}{// Read files with proc 0}
327     \textcolor{keywordflow}{if}(rank == 0)
328     \{
329         \textcolor{keywordtype}{int} temp\_RX = -1;
330         \textcolor{keywordtype}{int} temp\_X = -1;
331 
332         std::ifstream equivalence\_A\_file(equivalence\_table\_A\_Filename);
333 
334         equivalence\_A\_file >> nbOfRestricted\_A\_Elems;
335         dummy\_equivalence\_table\_A.resize(2*nbOfRestricted\_A\_Elems);
336 
337         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_A\_Elems; ++iii)
338         \{
339             equivalence\_A\_file  >> temp\_RX
340                                 >> temp\_X;
341 
342             dummy\_equivalence\_table\_A[2*iii] = temp\_RX;
343             dummy\_equivalence\_table\_A[2*iii + 1] = temp\_X;
344         \}
345         equivalence\_A\_file.close();
346 
347         std::ifstream equivalence\_B\_file(equivalence\_table\_B\_Filename);
348 
349         equivalence\_B\_file >> nbOfRestricted\_B\_Elems;
350         dummy\_equivalence\_table\_B.resize(2*nbOfRestricted\_B\_Elems);
351 
352         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_B\_Elems; ++iii)
353         \{
354             equivalence\_B\_file  >> temp\_RX
355                                 >> temp\_X;
356 
357             dummy\_equivalence\_table\_B[2*iii] = temp\_RX;
358             dummy\_equivalence\_table\_B[2*iii + 1] = temp\_X;
359         \}
360         equivalence\_B\_file.close();
361     \}
362 
363     \textcolor{comment}{// Broadcast the sizes and resize on other procs}
364     WorldComm.broadcast(nbOfRestricted\_A\_Elems);
365     WorldComm.broadcast(nbOfRestricted\_B\_Elems);
366 
367     \textcolor{keywordflow}{if}(rank != 0)
368     \{
369         dummy\_equivalence\_table\_A.resize(2*nbOfRestricted\_A\_Elems);
370         dummy\_equivalence\_table\_B.resize(2*nbOfRestricted\_B\_Elems);
371     \}
372 
373     WorldComm.barrier();
374 
375     WorldComm.broadcast(dummy\_equivalence\_table\_A);
376     WorldComm.broadcast(dummy\_equivalence\_table\_B);
377 
378     \textcolor{comment}{// Convert back to unoredered maps}
379     equivalence\_table\_A\_to\_R\_A.reserve(nbOfRestricted\_A\_Elems);
380     equivalence\_table\_B\_to\_R\_B.reserve(nbOfRestricted\_B\_Elems);
381 
382     equivalence\_table\_R\_A\_to\_A.reserve(nbOfRestricted\_A\_Elems);
383     equivalence\_table\_R\_B\_to\_B.reserve(nbOfRestricted\_B\_Elems);
384 
385     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_A\_Elems; ++iii)
386     \{
387         equivalence\_table\_R\_A\_to\_A[dummy\_equivalence\_table\_A[2*iii]] =
388                 dummy\_equivalence\_table\_A[2*iii + 1];
389         equivalence\_table\_A\_to\_R\_A[dummy\_equivalence\_table\_A[2*iii + 1]] =
390                 dummy\_equivalence\_table\_A[2*iii];
391     \}
392 
393     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfRestricted\_B\_Elems; ++iii)
394     \{
395         equivalence\_table\_R\_B\_to\_B[dummy\_equivalence\_table\_B[2*iii]] =
396                 dummy\_equivalence\_table\_B[2*iii + 1];
397         equivalence\_table\_B\_to\_R\_B[dummy\_equivalence\_table\_B[2*iii + 1]] =
398                 dummy\_equivalence\_table\_B[2*iii];
399     \}
400 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a0fef8616ca5e61709ef9a013c8a2ee43}{}\index{carl@{carl}!set\+\_\+full\+\_\+intersection\+\_\+tables@{set\+\_\+full\+\_\+intersection\+\_\+tables}}
\index{set\+\_\+full\+\_\+intersection\+\_\+tables@{set\+\_\+full\+\_\+intersection\+\_\+tables}!carl@{carl}}
\subsubsection[{set\+\_\+full\+\_\+intersection\+\_\+tables(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const std\+::string \&intersection\+\_\+full\+\_\+table\+\_\+\+Filename, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&full\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+full\+\_\+intersection\+\_\+tables (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const std\+::string \&}]{intersection\+\_\+full\+\_\+table\+\_\+\+Filename, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{full\+\_\+intersection\+\_\+pairs\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{full\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map}
\end{DoxyParamCaption}
)}\label{namespacecarl_a0fef8616ca5e61709ef9a013c8a2ee43}


Definition at line 437 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
443 \{
444     \textcolor{keywordtype}{int} rank = WorldComm.rank();
445 
446     \textcolor{comment}{//  While the equivalence tables are saved as unordered maps, it's easier to}
447     \textcolor{comment}{// save them as vectors at first, broadcast them, and them reconvert to maps}
448     std::vector<int> dummy\_intersections\_IDs;
449     std::vector<int> dummy\_intersection\_pairs\_table;
450     std::vector<int> dummy\_all\_intersections\_table;
451     std::vector<int> dummy\_intersections\_sizes\_table;
452 
453     \textcolor{keywordtype}{int} nbOfIntersections = -1;
454     \textcolor{keywordtype}{int} nbOfInterElems = -1;
455 
456     \textcolor{comment}{// Declare a few auxiliary variables}
457     \textcolor{keywordtype}{int} temp\_interID = -1;
458     \textcolor{keywordtype}{int} temp\_idxA = -1;
459     \textcolor{keywordtype}{int} temp\_idxB = -1;
460     \textcolor{keywordtype}{int} temp\_idxI = -1;
461     \textcolor{keywordtype}{int} temp\_nbOfInter = -1;
462 
463     \textcolor{keywordtype}{int} interIdx = 0;
464 
465     \textcolor{comment}{// Do the file reading job on proc 0}
466     \textcolor{keywordflow}{if}(rank == 0)
467     \{
468         std::ifstream intersection\_full\_file(intersection\_full\_table\_Filename);
469 
470         intersection\_full\_file >> nbOfIntersections >> nbOfInterElems;
471 
472         dummy\_intersections\_IDs.resize(nbOfIntersections);
473         dummy\_intersection\_pairs\_table.resize(2*nbOfIntersections);
474         dummy\_all\_intersections\_table.resize(nbOfInterElems);
475         dummy\_intersections\_sizes\_table.resize(nbOfIntersections);
476 
477         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections; ++iii)
478         \{
479             \textcolor{comment}{// For each line, read ...}
480 
481             \textcolor{comment}{// ... the inter ID, A and B's elements, and the number of I's elements ...}
482             intersection\_full\_file  >> temp\_interID
483                                     >> temp\_idxA >> temp\_idxB
484                                     >> temp\_nbOfInter;
485 
486             dummy\_intersections\_IDs[iii]              = temp\_interID;
487             dummy\_intersection\_pairs\_table[2*iii]     = temp\_idxA;
488             dummy\_intersection\_pairs\_table[2*iii + 1] = temp\_idxB;
489             dummy\_intersections\_sizes\_table[iii]      = temp\_nbOfInter;
490 
491             \textcolor{comment}{// ... and all of I's elements}
492             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} jjj = 0; jjj < temp\_nbOfInter; ++jjj)
493             \{
494                 intersection\_full\_file >> temp\_idxI;
495                 dummy\_all\_intersections\_table[interIdx] = temp\_idxI;
496 
497                 ++interIdx;
498             \}
499         \}
500         intersection\_full\_file.close();
501     \}
502 
503     \textcolor{comment}{// Broadcast the sizes and resize on other procs}
504     WorldComm.broadcast(nbOfIntersections);
505     WorldComm.broadcast(nbOfInterElems);
506 
507     \textcolor{keywordflow}{if}(rank != 0)
508     \{
509         dummy\_intersections\_IDs.resize(nbOfIntersections);
510         dummy\_intersection\_pairs\_table.resize(2*nbOfIntersections);
511         dummy\_all\_intersections\_table.resize(nbOfInterElems);
512         dummy\_intersections\_sizes\_table.resize(nbOfIntersections);
513     \}
514 
515     WorldComm.barrier();
516 
517     WorldComm.broadcast(dummy\_intersections\_IDs);
518     WorldComm.broadcast(dummy\_intersection\_pairs\_table);
519     WorldComm.broadcast(dummy\_all\_intersections\_table);
520     WorldComm.broadcast(dummy\_intersections\_sizes\_table);
521 
522     full\_intersection\_pairs\_map.reserve(nbOfIntersections);
523     full\_intersection\_meshI\_to\_inter\_map.reserve(nbOfInterElems);
524 
525     interIdx = 0;
526 
527     \textcolor{comment}{// Convert the vectors to maps}
528     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections; ++iii)
529     \{
530         temp\_interID    = dummy\_intersections\_IDs[iii];
531         temp\_idxA       = dummy\_intersection\_pairs\_table[2*iii];
532         temp\_idxB       = dummy\_intersection\_pairs\_table[2*iii + 1];
533 
534         full\_intersection\_pairs\_map[temp\_interID] = std::pair<int,int>(temp\_idxA,temp\_idxB);
535 
536         temp\_nbOfInter  = dummy\_intersections\_sizes\_table[iii];
537         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} jjj = 0; jjj < temp\_nbOfInter; ++jjj)
538         \{
539             temp\_idxI   = dummy\_all\_intersections\_table[interIdx];
540             full\_intersection\_meshI\_to\_inter\_map[temp\_idxI] = temp\_interID;
541             ++interIdx;
542         \}
543     \}
544 \};
\end{DoxyCode}
\hypertarget{namespacecarl_ab4df2c3a7c53c68fc2628569f4b4bd17}{}\index{carl@{carl}!set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists@{set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists}}
\index{set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists@{set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists}!carl@{carl}}
\subsubsection[{set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const std\+::string \&intersection\+\_\+global\+\_\+table\+\_\+\+Filename, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+system\+\_\+to\+\_\+mediator, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+mediator\+\_\+to\+\_\+system, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&inter\+\_\+mediator\+\_\+\+A, std\+::unordered\+\_\+multimap$<$ int, int $>$ \&inter\+\_\+mediator\+\_\+\+B)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+global\+\_\+mediator\+\_\+system\+\_\+intersection\+\_\+lists (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const std\+::string \&}]{intersection\+\_\+global\+\_\+table\+\_\+\+Filename, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+system\+\_\+to\+\_\+mediator, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+mediator\+\_\+to\+\_\+system, }
\item[{std\+::unordered\+\_\+multimap$<$ int, int $>$ \&}]{inter\+\_\+mediator\+\_\+\+A, }
\item[{std\+::unordered\+\_\+multimap$<$ int, int $>$ \&}]{inter\+\_\+mediator\+\_\+\+B}
\end{DoxyParamCaption}
)}\label{namespacecarl_ab4df2c3a7c53c68fc2628569f4b4bd17}


Definition at line 683 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
691 \{
692     \textcolor{comment}{// First, do the reading work on proc. 0}
693     \textcolor{keywordtype}{int} rank = WorldComm.rank();
694     \textcolor{keywordtype}{int} nodes = WorldComm.size();
695 
696     \textcolor{keywordtype}{int}                 temp\_interID;
697     std::vector<int>    temp\_idxA;
698     std::vector<int>    temp\_idxB;
699 
700     \textcolor{keywordtype}{int} nbOfIntersections = -1;
701     \textcolor{keywordtype}{int} nbOfInterElems = -1;
702 
703     std::string dummy\_data;
704 
705     \textcolor{keywordflow}{if}(rank == 0)
706     \{
707         std::ifstream intersection\_full\_file(intersection\_global\_table\_Filename);
708         intersection\_full\_file >> nbOfIntersections >> nbOfInterElems;
709 
710         temp\_idxA.resize(nbOfIntersections);
711         temp\_idxB.resize(nbOfIntersections);
712 
713         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections; ++iii)
714         \{
715             intersection\_full\_file  >> temp\_interID
716                                     >> temp\_idxA[iii] >> temp\_idxB[iii];
717             intersection\_full\_file.ignore(std::numeric\_limits<std::streamsize>::max(), \textcolor{charliteral}{'\(\backslash\)n'});
718         \}
719         intersection\_full\_file.close();
720     \}
721 
722     \textcolor{keywordflow}{if}(nodes > 1)
723     \{
724         WorldComm.broadcast(nbOfIntersections);
725 
726         \textcolor{keywordflow}{if}(rank != 0)
727         \{
728             temp\_idxA.resize(nbOfIntersections);
729             temp\_idxB.resize(nbOfIntersections);
730         \}
731         WorldComm.broadcast(temp\_idxA);
732         WorldComm.broadcast(temp\_idxB);
733     \}
734 
735     inter\_mediator\_A.reserve(nbOfIntersections);
736     inter\_mediator\_B.reserve(nbOfIntersections);
737 
738     \textcolor{keywordtype}{int} mediator\_idx;
739     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nbOfIntersections; ++iii)
740     \{
741         mediator\_idx = equivalence\_table\_system\_to\_mediator.at(temp\_idxA[iii]);
742         inter\_mediator\_B.emplace(std::make\_pair(mediator\_idx, temp\_idxB[iii]));
743     \}
744 
745     \textcolor{keywordtype}{int} system\_idx;
746     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iii = 0; iii < equivalence\_table\_system\_to\_mediator.size(); ++iii)
747     \{
748         system\_idx = equivalence\_table\_mediator\_to\_system.at(iii);
749         inter\_mediator\_A.emplace(std::make\_pair(iii, system\_idx));
750     \}
751 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a880bd07cae964f085e21e5ac75ede10d}{}\index{carl@{carl}!set\+\_\+intersection\+\_\+tables@{set\+\_\+intersection\+\_\+tables}}
\index{set\+\_\+intersection\+\_\+tables@{set\+\_\+intersection\+\_\+tables}!carl@{carl}}
\subsubsection[{set\+\_\+intersection\+\_\+tables(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const lib\+Mesh\+::\+Mesh \&mesh\+\_\+intersection, const std\+::string \&intersection\+\_\+full\+\_\+table\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+intersection\+\_\+tables (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const lib\+Mesh\+::\+Mesh \&}]{mesh\+\_\+intersection, }
\item[{const std\+::string \&}]{intersection\+\_\+full\+\_\+table\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{full\+\_\+intersection\+\_\+pairs\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{full\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map}
\end{DoxyParamCaption}
)}\label{namespacecarl_a880bd07cae964f085e21e5ac75ede10d}


Definition at line 595 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
609 \{
610     \textcolor{comment}{//  Start by reading and broadcasting the global intersection table}
611     std::unordered\_map<int,int> full\_intersection\_meshI\_to\_inter\_map;
612     \hyperlink{namespacecarl_a0fef8616ca5e61709ef9a013c8a2ee43}{set\_full\_intersection\_tables}(WorldComm,intersection\_full\_table\_Filename,
613             full\_intersection\_pairs\_map,full\_intersection\_meshI\_to\_inter\_map);
614 
615     \textcolor{comment}{// Set up the restricted intersection pairs table}
616     \hyperlink{namespacecarl_a17eb70b3f2c2574e7b3085108205e38c}{set\_restricted\_intersection\_pairs\_table}(
      full\_intersection\_pairs\_map,
617         equivalence\_table\_A\_to\_R\_A,equivalence\_table\_B\_to\_R\_B,
618         full\_intersection\_restricted\_pairs\_map);
619 
620     \textcolor{comment}{// Build in each processor its own intersection table}
621     libMesh::MeshBase::const\_element\_iterator       elemIt  = mesh\_intersection.active\_local\_elements\_begin
      ();
622     \textcolor{keyword}{const} libMesh::MeshBase::const\_element\_iterator end\_elemIt = mesh\_intersection.
      active\_local\_elements\_end();
623     \textcolor{keywordtype}{int} local\_nbOfInters = mesh\_intersection.n\_active\_local\_elem();
624     local\_intersection\_meshI\_to\_inter\_map.reserve(local\_nbOfInters);
625 
626     \textcolor{comment}{// Some dummy indexes used}
627     \textcolor{keywordtype}{int} idxI\_table = -1;
628     \textcolor{keywordtype}{int} interID = -1;
629 
630     \textcolor{keywordflow}{for}( ; elemIt != end\_elemIt; ++ elemIt)
631     \{
632         \textcolor{keyword}{const} libMesh::Elem* elem = *elemIt;
633         idxI\_table  = elem->id();
634         interID     = full\_intersection\_meshI\_to\_inter\_map[idxI\_table];
635         local\_intersection\_meshI\_to\_inter\_map[idxI\_table] = interID;
636     \}
637 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a8d1c90daac3238ed5d53465740e072b3}{}\index{carl@{carl}!set\+\_\+local\+\_\+intersection\+\_\+tables@{set\+\_\+local\+\_\+intersection\+\_\+tables}}
\index{set\+\_\+local\+\_\+intersection\+\_\+tables@{set\+\_\+local\+\_\+intersection\+\_\+tables}!carl@{carl}}
\subsubsection[{set\+\_\+local\+\_\+intersection\+\_\+tables(const lib\+Mesh\+::\+Parallel\+::\+Communicator \&\+World\+Comm, const lib\+Mesh\+::\+Mesh \&mesh\+\_\+intersection, const std\+::string \&intersection\+\_\+local\+\_\+table\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, const std\+::string \&equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&local\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map, std\+::unordered\+\_\+map$<$ int, int $>$ \&local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+local\+\_\+intersection\+\_\+tables (
\begin{DoxyParamCaption}
\item[{const lib\+Mesh\+::\+Parallel\+::\+Communicator \&}]{World\+Comm, }
\item[{const lib\+Mesh\+::\+Mesh \&}]{mesh\+\_\+intersection, }
\item[{const std\+::string \&}]{intersection\+\_\+local\+\_\+table\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+\+Filename, }
\item[{const std\+::string \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+\+Filename, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{local\+\_\+intersection\+\_\+pairs\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{local\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map, }
\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{local\+\_\+intersection\+\_\+mesh\+I\+\_\+to\+\_\+inter\+\_\+map}
\end{DoxyParamCaption}
)}\label{namespacecarl_a8d1c90daac3238ed5d53465740e072b3}


Definition at line 639 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
653 \{
654     \textcolor{comment}{//  Start by reading and broadcasting the global intersection table}
655     std::unordered\_map<int,int> full\_intersection\_meshI\_to\_inter\_map;
656     \hyperlink{namespacecarl_aeceaf9a878847b9ea2f623aa51e3b392}{read\_local\_intersection\_tables}(WorldComm,
      intersection\_local\_table\_Filename,
657             local\_intersection\_pairs\_map,full\_intersection\_meshI\_to\_inter\_map);
658 
659     \textcolor{comment}{// Set up the restricted intersection pairs table}
660     \hyperlink{namespacecarl_a17eb70b3f2c2574e7b3085108205e38c}{set\_restricted\_intersection\_pairs\_table}(
      local\_intersection\_pairs\_map,
661         equivalence\_table\_A\_to\_R\_A,equivalence\_table\_B\_to\_R\_B,
662         local\_intersection\_restricted\_pairs\_map);
663 
664     \textcolor{comment}{// Build in each processor its own intersection table}
665     libMesh::MeshBase::const\_element\_iterator       elemIt  = mesh\_intersection.active\_local\_elements\_begin
      ();
666     \textcolor{keyword}{const} libMesh::MeshBase::const\_element\_iterator end\_elemIt = mesh\_intersection.
      active\_local\_elements\_end();
667     \textcolor{keywordtype}{int} local\_nbOfInters = mesh\_intersection.n\_active\_local\_elem();
668     local\_intersection\_meshI\_to\_inter\_map.reserve(local\_nbOfInters);
669 
670     \textcolor{comment}{// Some dummy indexes used}
671     \textcolor{keywordtype}{int} idxI\_table = -1;
672     \textcolor{keywordtype}{int} interID = -1;
673 
674     \textcolor{keywordflow}{for}( ; elemIt != end\_elemIt; ++ elemIt)
675     \{
676         \textcolor{keyword}{const} libMesh::Elem* elem = *elemIt;
677         idxI\_table  = elem->id();
678         interID     = full\_intersection\_meshI\_to\_inter\_map[idxI\_table];
679         local\_intersection\_meshI\_to\_inter\_map[idxI\_table] = interID;
680     \}
681 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a17eb70b3f2c2574e7b3085108205e38c}{}\index{carl@{carl}!set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table@{set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table}}
\index{set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table@{set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table}!carl@{carl}}
\subsubsection[{set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table(const std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+pairs\+\_\+map, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, const std\+::unordered\+\_\+map$<$ int, int $>$ \&equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&full\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+restricted\+\_\+intersection\+\_\+pairs\+\_\+table (
\begin{DoxyParamCaption}
\item[{const std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{full\+\_\+intersection\+\_\+pairs\+\_\+map, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+A\+\_\+to\+\_\+\+R\+\_\+\+A, }
\item[{const std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{equivalence\+\_\+table\+\_\+\+B\+\_\+to\+\_\+\+R\+\_\+\+B, }
\item[{std\+::unordered\+\_\+map$<$ int, std\+::pair$<$ int, int $>$ $>$ \&}]{full\+\_\+intersection\+\_\+restricted\+\_\+pairs\+\_\+map}
\end{DoxyParamCaption}
)}\label{namespacecarl_a17eb70b3f2c2574e7b3085108205e38c}


Definition at line 402 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
407 \{
408     \textcolor{comment}{// "Resize" the final output}
409     intersection\_restricted\_pairs\_map.reserve(equivalence\_table\_A\_to\_R\_A.size());
410 
411     \textcolor{keywordtype}{int} interID = -1;
412     \textcolor{keywordtype}{int} idxA = -1;
413     \textcolor{keywordtype}{int} idxB = -1;
414 
415     \textcolor{keywordtype}{int} idxRA = -1;
416     \textcolor{keywordtype}{int} idxRB = -1;
417 
418     std::unordered\_map<int,std::pair<int,int> >::const\_iterator mapIt =
419             intersection\_pairs\_map.begin();
420     std::unordered\_map<int,std::pair<int,int> >::const\_iterator end\_mapIt =
421             intersection\_pairs\_map.end();
422 
423     \textcolor{keywordflow}{for}( ; mapIt != end\_mapIt; ++mapIt)
424     \{
425         interID = mapIt->first;
426         idxA    = mapIt->second.first;
427         idxB    = mapIt->second.second;
428 
429         idxRA   = equivalence\_table\_A\_to\_R\_A.at(idxA);
430         idxRB   = equivalence\_table\_B\_to\_R\_B.at(idxB);
431 
432         intersection\_restricted\_pairs\_map[interID] =
433                 std::pair<int,int>(idxRA,idxRB);
434     \}
435 \}
\end{DoxyCode}
\hypertarget{namespacecarl_aab1c0aca80d848937579e63a21c9a270}{}\index{carl@{carl}!set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx@{set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx}}
\index{set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx@{set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx}!carl@{carl}}
\subsubsection[{set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx(std\+::string \&filename, int \&domain\+\_\+\+Idx\+\_\+\+B\+I\+G, int \&nb\+\_\+of\+\_\+domain\+\_\+\+Idx\+\_\+micro, std\+::vector$<$ int $>$ \&domain\+\_\+\+Idx\+\_\+micro, std\+::vector$<$ int $>$ \&domain\+\_\+\+Idx\+\_\+coupling)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::set\+\_\+weight\+\_\+function\+\_\+domain\+\_\+idx (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{filename, }
\item[{int \&}]{domain\+\_\+\+Idx\+\_\+\+B\+I\+G, }
\item[{int \&}]{nb\+\_\+of\+\_\+domain\+\_\+\+Idx\+\_\+micro, }
\item[{std\+::vector$<$ int $>$ \&}]{domain\+\_\+\+Idx\+\_\+micro, }
\item[{std\+::vector$<$ int $>$ \&}]{domain\+\_\+\+Idx\+\_\+coupling}
\end{DoxyParamCaption}
)}\label{namespacecarl_aab1c0aca80d848937579e63a21c9a270}


Definition at line 4 of file mesh\+\_\+tables.\+cpp.


\begin{DoxyCode}
10 \{
11     std::ifstream dataF(filename);
12 
13     \textcolor{comment}{// Buffer string}
14     std::string bufferLine;
15     std::stringstream   dataBuffer;
16 
17     \textcolor{comment}{// Read info until the file ends}
18     \textcolor{keywordflow}{while}(std::getline(dataF,bufferLine))
19     \{
20         \textcolor{keywordflow}{if}(bufferLine.compare(\textcolor{stringliteral}{"$MacroDomainIdx"})==0)
21         \{
22             dataF >> domain\_Idx\_BIG;
23         \}
24 
25         \textcolor{keywordflow}{if}(bufferLine.compare(\textcolor{stringliteral}{"$NbOfMicroDomainIdx"})==0)
26         \{
27             dataF >> nb\_of\_domain\_Idx;
28 
29             domain\_Idx\_micro.resize(nb\_of\_domain\_Idx);
30             domain\_Idx\_coupling.resize(nb\_of\_domain\_Idx);
31         \}
32 
33         \textcolor{keywordflow}{if}(bufferLine.compare(\textcolor{stringliteral}{"$MicroDomainIdxs"})==0)
34         \{
35             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nb\_of\_domain\_Idx; ++iii )
36             \{
37                 dataF >> domain\_Idx\_micro[iii];
38             \}
39         \}
40 
41         \textcolor{keywordflow}{if}(bufferLine.compare(\textcolor{stringliteral}{"$CouplingDomainIdxs"})==0)
42         \{
43             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} iii = 0; iii < nb\_of\_domain\_Idx; ++iii )
44             \{
45                 dataF >> domain\_Idx\_coupling[iii];
46             \}
47         \}
48     \}
49 
50     dataF.close();
51 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a728a8e1963352c97d71b9c3dec0c2244}{}\index{carl@{carl}!solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C@{solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C}}
\index{solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C@{solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C}!carl@{carl}}
\subsubsection[{solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&\+A, lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&b, lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&x, K\+S\+P \&ksp, P\+C \&pc)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::solve\+\_\+linear\+\_\+\+P\+E\+T\+S\+C (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{A, }
\item[{lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&}]{b, }
\item[{lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&}]{x, }
\item[{K\+S\+P \&}]{ksp, }
\item[{P\+C \&}]{pc}
\end{DoxyParamCaption}
)}\label{namespacecarl_a728a8e1963352c97d71b9c3dec0c2244}


Definition at line 270 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
274 \{
275     \textcolor{comment}{/*}
276 \textcolor{comment}{     *          Solve the system A*x = b using PETSc's linear solver, using a}
277 \textcolor{comment}{     *      Krilov method, with the linear solver context "ksp" and}
278 \textcolor{comment}{     *      preconditioner "pc".}
279 \textcolor{comment}{     */}
280 
281     \textcolor{comment}{// Set up inital variables}
282 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a3e28e30c4315c39fbddd46af79018d51}{}\index{carl@{carl}!voigt\+\_\+index\+\_\+converter@{voigt\+\_\+index\+\_\+converter}}
\index{voigt\+\_\+index\+\_\+converter@{voigt\+\_\+index\+\_\+converter}!carl@{carl}}
\subsubsection[{voigt\+\_\+index\+\_\+converter(int aaa, int bbb)}]{\setlength{\rightskip}{0pt plus 5cm}int carl\+::voigt\+\_\+index\+\_\+converter (
\begin{DoxyParamCaption}
\item[{int}]{aaa, }
\item[{int}]{bbb}
\end{DoxyParamCaption}
)}\label{namespacecarl_a3e28e30c4315c39fbddd46af79018d51}


Definition at line 93 of file common\+\_\+functions.\+cpp.


\begin{DoxyCode}
94 \{
95     \textcolor{keywordflow}{if}(aaa == bbb)
96     \{
97         \textcolor{comment}{// 00 -> 0, 11 -> 1, 22 -> 2}
98         \textcolor{keywordflow}{return} aaa;
99     \}
100     \textcolor{keywordflow}{else}
101     \{
102         \textcolor{comment}{// 12, 21 -> 3}
103         \textcolor{comment}{// 02, 20 -> 4}
104         \textcolor{comment}{// 01, 10 -> 5}
105         \textcolor{keywordtype}{int} sum = aaa + bbb;
106 
107         \textcolor{keywordflow}{if}(sum == 3)
108         \{
109             \textcolor{keywordflow}{return} 3;
110         \}
111         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(sum == 2)
112         \{
113             \textcolor{keywordflow}{return} 4;
114         \}
115         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(sum == 1)
116         \{
117             \textcolor{keywordflow}{return} 5;
118         \}
119     \}
120 
121     std::cerr << \textcolor{stringliteral}{"Bad indexes! "} << aaa << \textcolor{stringliteral}{" "} << bbb << std::endl;
122     \hyperlink{common__header_8h_a05d65d26b911668ac90085745dca71f6}{homemade\_error\_msg}(\textcolor{stringliteral}{" You shouldn't be here! (voigt\_index\_converter)"});
123     \textcolor{keywordflow}{return} -1;
124 \};
\end{DoxyCode}
\hypertarget{namespacecarl_a431936850bf5712121d8399ddbd76aa8}{}\index{carl@{carl}!write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}}
\index{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}!carl@{carl}}
\subsubsection[{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix(\+Mat input\+\_\+mat, const std\+::string \&filename, int rank, M\+P\+I\+\_\+\+Comm comm=\+P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D, int dim=1)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{Mat}]{input\+\_\+mat, }
\item[{const std\+::string \&}]{filename, }
\item[{int}]{rank, }
\item[{M\+P\+I\+\_\+\+Comm}]{comm = {\ttfamily PETSC\+\_\+COMM\+\_\+WORLD}, }
\item[{int}]{dim = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a431936850bf5712121d8399ddbd76aa8}


Definition at line 415 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
417 \{
418     PetscViewer    viewer;
419     PetscViewerBinaryOpen(comm,filename.c\_str(),FILE\_MODE\_WRITE,&viewer);
420     MatView(input\_mat,viewer);
421 
422     PetscViewerDestroy(&viewer);
423 
424     \textcolor{comment}{// Hack to guarantee the proper matrix division without forcing libMesh's --enable-blocked-storage}
425     \textcolor{keywordflow}{if}(rank == 0)
426     \{
427         std::ofstream mat\_info(filename + \textcolor{stringliteral}{".info"});
428         mat\_info << \textcolor{stringliteral}{"-matload\_block\_size "} << std::to\_string(dim) << std::endl;
429         mat\_info.close();
430     \}
431 \}
\end{DoxyCode}
\hypertarget{namespacecarl_aa6ac21d50301de8b7b50b23b4e4600e3}{}\index{carl@{carl}!write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}}
\index{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix}!carl@{carl}}
\subsubsection[{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix(lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+mat, const std\+::string \&filename, int dim=1)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Matrix$<$ lib\+Mesh\+::\+Number $>$ \&}]{input\+\_\+mat, }
\item[{const std\+::string \&}]{filename, }
\item[{int}]{dim = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{namespacecarl_aa6ac21d50301de8b7b50b23b4e4600e3}


Definition at line 433 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
435 \{
436     \hyperlink{namespacecarl_a431936850bf5712121d8399ddbd76aa8}{write\_PETSC\_matrix}(input\_mat.mat(),filename,input\_mat.comm().rank(),input\_mat.comm().
      get(),dim);
437 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a1f15b2a953f4af7763e81b5f86505d6d}{}\index{carl@{carl}!write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B}}
\index{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B}!carl@{carl}}
\subsubsection[{write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B(\+Mat input\+\_\+mat, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=\+P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::write\+\_\+\+P\+E\+T\+S\+C\+\_\+matrix\+\_\+\+M\+A\+T\+L\+A\+B (
\begin{DoxyParamCaption}
\item[{Mat}]{input\+\_\+mat, }
\item[{const std\+::string \&}]{filename, }
\item[{M\+P\+I\+\_\+\+Comm}]{comm = {\ttfamily PETSC\+\_\+COMM\+\_\+WORLD}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a1f15b2a953f4af7763e81b5f86505d6d}


Definition at line 356 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
357 \{
358     PetscViewer    viewer;
359     PetscViewerCreate(comm,&viewer);
360     PetscViewerASCIIOpen(comm,filename.c\_str(),&viewer);
361     PetscViewerPushFormat (viewer,PETSC\_VIEWER\_ASCII\_MATLAB);
362     MatView(input\_mat,viewer);
363 
364     PetscViewerDestroy(&viewer);
365 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a1632084ec1f296b63559648cc9c2047f}{}\index{carl@{carl}!write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}}
\index{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}!carl@{carl}}
\subsubsection[{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector(lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&input\+\_\+vec, const std\+::string \&filename, int dim=1)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector (
\begin{DoxyParamCaption}
\item[{lib\+Mesh\+::\+Petsc\+Vector$<$ lib\+Mesh\+::\+Number $>$ \&}]{input\+\_\+vec, }
\item[{const std\+::string \&}]{filename, }
\item[{int}]{dim = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a1632084ec1f296b63559648cc9c2047f}


Definition at line 338 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
340 \{
341     \hyperlink{namespacecarl_a1632084ec1f296b63559648cc9c2047f}{write\_PETSC\_vector}(input\_vec.vec(),filename,input\_vec.comm().rank(),input\_vec.comm().
      get(),dim);
342 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a228d257ed2972e42a0468d2d82eb93f9}{}\index{carl@{carl}!write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}}
\index{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector}!carl@{carl}}
\subsubsection[{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector(\+Vec input\+\_\+vec, const std\+::string \&filename, int rank, M\+P\+I\+\_\+\+Comm comm=\+P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D, int dim=1)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector (
\begin{DoxyParamCaption}
\item[{Vec}]{input\+\_\+vec, }
\item[{const std\+::string \&}]{filename, }
\item[{int}]{rank, }
\item[{M\+P\+I\+\_\+\+Comm}]{comm = {\ttfamily PETSC\+\_\+COMM\+\_\+WORLD}, }
\item[{int}]{dim = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a228d257ed2972e42a0468d2d82eb93f9}


Definition at line 320 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
322 \{
323     PetscViewer    viewer;
324     PetscViewerBinaryOpen(comm,filename.c\_str(),FILE\_MODE\_WRITE,&viewer);
325     VecView(input\_vec,viewer);
326 
327     PetscViewerDestroy(&viewer);
328 
329     \textcolor{comment}{// Hack to guarantee the proper vector division without forcing libMesh's --enable-blocked-storage}
330     \textcolor{keywordflow}{if}(rank == 0)
331     \{
332         std::ofstream vec\_info(filename + \textcolor{stringliteral}{".info"});
333         vec\_info << \textcolor{stringliteral}{"-vecload\_block\_size "} << std::to\_string(dim) << std::endl;
334         vec\_info.close();
335     \}
336 \}
\end{DoxyCode}
\hypertarget{namespacecarl_a25d36e4c1615382a1832d73c716599db}{}\index{carl@{carl}!write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B}}
\index{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B@{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B}!carl@{carl}}
\subsubsection[{write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B(\+Vec input\+\_\+vec, const std\+::string \&filename, M\+P\+I\+\_\+\+Comm comm=\+P\+E\+T\+S\+C\+\_\+\+C\+O\+M\+M\+\_\+\+W\+O\+R\+L\+D)}]{\setlength{\rightskip}{0pt plus 5cm}void carl\+::write\+\_\+\+P\+E\+T\+S\+C\+\_\+vector\+\_\+\+M\+A\+T\+L\+A\+B (
\begin{DoxyParamCaption}
\item[{Vec}]{input\+\_\+vec, }
\item[{const std\+::string \&}]{filename, }
\item[{M\+P\+I\+\_\+\+Comm}]{comm = {\ttfamily PETSC\+\_\+COMM\+\_\+WORLD}}
\end{DoxyParamCaption}
)}\label{namespacecarl_a25d36e4c1615382a1832d73c716599db}


Definition at line 344 of file P\+E\+T\+S\+C\+\_\+matrix\+\_\+operations.\+cpp.


\begin{DoxyCode}
346 \{
347     PetscViewer    viewer;
348     PetscViewerCreate(comm,&viewer);
349     PetscViewerASCIIOpen(comm,filename.c\_str(),&viewer);
350     PetscViewerPushFormat (viewer,PETSC\_VIEWER\_ASCII\_MATLAB);
351     VecView(input\_vec,viewer);
352 
353     PetscViewerDestroy(&viewer);
354 \}
\end{DoxyCode}
