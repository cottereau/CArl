// The libMesh Finite Element Library.
// Copyright (C) 2002-2020 Benjamin S. Kirk, John W. Peterson, Roy H. Stogner

// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.

// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



// <h1>FEMSystem Example 3 - Unsteady Linear Elasticity with
// FEMSystem</h1>
// \author Paul Bauman
// \date 2015
//
// This example shows how to solve the three-dimensional transient
// linear elasticity equations using the DifferentiableSystem class framework.
// This is just Systems of Equations Example 6 recast.

// C++ includes
#include "libmesh_assemble_lin_homogeneous.h"

#define x_scaling 1.3
//std::string path_to_file(int argc, char ** argv);

// Bring in everything from the libMesh namespace
using namespace libMesh;

// Read material param from file
void read_material(std::string file_name, material_params& mat);

// The main program.
int main (int argc, char ** argv)
{

  // [USER] Fixed boundary pressure
  const boundary_id_type pressure_boundary = pressure_boundary_id;
  
  // Initialize libMesh.
  LibMeshInit init (argc, argv);
  // Do performance log?
  const bool MASTER_bPerfLog_carl_libmesh = true;
  libMesh::PerfLog perf_log("Main program", MASTER_bPerfLog_carl_libmesh);

  // libMesh's C++ / MPI communicator wrapper
  libMesh::Parallel::Communicator& WorldComm = init.comm();

  // Number of processors and processor rank.
  int rank = WorldComm.rank();
  int nodes = WorldComm.size();

  // This example requires a linear solver package.
  libmesh_example_requires(libMesh::default_solver_package() != INVALID_SOLVER_PACKAGE,
                           "--enable-petsc, --enable-trilinos, or --enable-eigen");

  // This example requires 3D calculations
  libmesh_example_requires(LIBMESH_DIM > 2, "3D support");

  // We use Dirichlet boundary conditions here
#ifndef LIBMESH_ENABLE_DIRICHLET
  libmesh_example_requires(false, "--enable-dirichlet");
#endif

  // Parse the input file
  GetPot command_line(argc, argv);
  //
  // File parser
  GetPot field_parser;

  std::string input_filename;
  if (command_line.search(1,"-i")) {
    input_filename = command_line.next(input_filename);
    field_parser.parse_input_file(input_filename, "#", "\n", " \t\n");
  } else {
    field_parser = command_line;
  }

  libmesh_assemble_input_params input_params;
  get_input_params(field_parser,input_params);

  // Read in parameters from the input file
  const Real deltat           = input_params.deltat;
  unsigned int n_timesteps    = input_params.n_timesteps;

  #ifdef LIBMESH_HAVE_EXODUS_API
   const unsigned int write_interval    = input_params.write_interval;
  #endif

  // Initialize the cantilever mesh
  const unsigned int dim = 3;

  // Make sure libMesh was compiled for 3D
  libmesh_example_requires(dim == LIBMESH_DIM, "3D support");

  perf_log.push("Meshes - Parallel","Read files:");
  libMesh::Mesh system_mesh(WorldComm, dim);
  system_mesh.read(input_params.mesh_file);
  system_mesh.prepare_for_use();

  libMesh::Mesh mesh_weight(WorldComm, dim);
  mesh_weight.allow_renumbering(false);
  mesh_weight.read(input_params.mesh_weight_file);
  mesh_weight.prepare_for_use();

  perf_log.pop("Meshes - Parallel","Read files:");
  system_mesh.print_info();

  // Let's add some node and edge boundary conditions.
  // Each processor should know about each boundary condition it can
  // see, so we loop over all elements, not just local elements.
  
  int cmin_x = 0;
  int cmax_z = 0;
  for (const auto & elem : system_mesh.element_ptr_range())
    {
      unsigned int side_min_x = 0;
      unsigned int side_max_x = 0;
      unsigned int side_min_y = 0;
      unsigned int side_max_y = 0;
      unsigned int side_min_z = 0;
      unsigned int side_max_z = 0; 

      bool found_side_min_x = false;
      bool found_side_max_x = false;
      bool found_side_min_y = false;
      bool found_side_max_y = false;
      bool found_side_min_z = false;
      bool found_side_max_z = false;

      int side_number = 0;

      for (auto side : elem->side_index_range())
        {
          // if (system_mesh.get_boundary_info().has_boundary_id(elem, side, boundary_id_max_x))
          //   {
          //     side_max_x = side;
          //     found_side_max_x = true;
          //     side_number++;
          //   }

            if(system_mesh.get_boundary_info().has_boundary_id(elem, side, boundary_id_min_x))
            {
              side_min_x = side;
              found_side_min_x = true;
              side_number++;
            }

            //if (system_mesh.get_boundary_info().has_boundary_id(elem, side, boundary_id_max_y))
            //{
            //  side_max_y = side;
            //  found_side_max_y = true;
            //  side_number++;
            //}

            //if (system_mesh.get_boundary_info().has_boundary_id(elem, side, boundary_id_min_y))
            //{
            //  side_min_y = side;
            //  found_side_min_y = true;
            //  side_number++;
            //}

            //if (system_mesh.get_boundary_info().has_boundary_id(elem, side, boundary_id_min_z))
            //{
            //  side_min_z = side;
            //  found_side_min_z = true;
            //  side_number++;
            //}

            if (system_mesh.get_boundary_info().has_boundary_id(elem, side, boundary_id_max_z))
            {
              side_max_z = side;
              found_side_max_z = true;
              side_number++;
            }

            
        }
        
        // std::cout<<"[!][has_boundary_id] side_number :"<<side_number<<"\n";

        // If elem hase sides on pressure boundaries
        if(found_side_min_x)
          for(auto e : elem->edge_index_range())
            if(elem->is_edge_on_side(e, side_min_x))
              {
                system_mesh.get_boundary_info().add_edge(elem, e, edge_boundary_id);
                cmin_x++;
              }

        // If elem hase sides on pressure boundaries
        if(found_side_max_z)
          for(auto e : elem->edge_index_range())
            if(elem->is_edge_on_side(e, side_max_z))
              {
                system_mesh.get_boundary_info().add_edge(elem, e, pressure_boundary_id);
                cmax_z++;
              }
    }

    std::cout<<"[!][number of minx edge] : "<<cmin_x<<"\n";
    std::cout<<"[!][number of maxz edge] : "<<cmax_z<<"\n";

// Print MatLab debugging output? Variable defined at "carl_headers.h"
// #ifdef PRINT_MATLAB_DEBUG
//   elasticity_system.matrix->print_matlab(input_params.output_base + "_sys_mat.m");
//   elasticity_system.rhs->print_matlab(input_params.output_base + "_sys_rhs_vec.m");
// #endif

  // Create an equation systems object.
  EquationSystems equation_systems (system_mesh);

  // Declare the system "Navier-Stokes" and its variables.
  ElasticitySystem & elasticity_system =
    equation_systems.add_system<ElasticitySystem> ("Linear Elasticity");

  //ImplicitSystem & es = dynamic_cast<ImplicitSystem &>( system );
  //set_clamped_border(es, fixed_bound_id);
  //system = dynamic_cast<ElasticitySystem>(& es);

  // Defining material parameter form de system_mesh
  material_params material;
  read_material(input_params.physical_params_file,material);
  // Material parameters
  elasticity_system.setRho(material.rho);
  elasticity_system.setYoungModulus(material.young_modulus);
  elasticity_system.setPoissonRatio(material.poisson_ratio);

  // Solve this as a time-dependent or steady syste
  GetPot infile("fem_system_ex3.in");
  infile.parse_command_line(argc,argv);
  std::string time_solver = infile("time_solver","DIE!");

  ExplicitSystem * v_system;
  ExplicitSystem * a_system;

      // Create ExplicitSystem to help output velocity
      v_system = &equation_systems.add_system<ExplicitSystem> ("Velocity");
      v_system->add_variable("u_vel", FIRST, LAGRANGE);
      v_system->add_variable("v_vel", FIRST, LAGRANGE);
      v_system->add_variable("w_vel", FIRST, LAGRANGE);

      // Create ExplicitSystem to help output acceleration
      a_system = &equation_systems.add_system<ExplicitSystem> ("Acceleration");
      a_system->add_variable("u_accel", FIRST, LAGRANGE);
      a_system->add_variable("v_accel", FIRST, LAGRANGE);
      a_system->add_variable("w_accel", FIRST, LAGRANGE);

      elasticity_system.time_solver = libmesh_make_unique<NewmarkSolver>(elasticity_system);
  

  equation_systems.init ();//->lance la methode init_data() de ElasticitySystem
   //une methode qui contient les reference de toutes les methodes collect√©e

  // std::cout<<"[!][Number of DOF]"<<system.get_dof_map().n_dofs()<<"\n";
  // std::cout<<"[!][info]"<<system.get_dof_map().get_info()<<"\n";

  // const std::vector<dof_id_type>& dof_id_type_vector = system.get_dof_map().get_send_list(); 
  // std::cout<<"[!][size] : size of dof_type_vector : "<<dof_id_type_vector.size()<<"\n";



  // for(int i=0;i<dof_id_type_vector.size(); i++)
  //   {
  //     std::cout<<"[dof]["<<i<<"] : "<<dof_id_type_vector[i]<<"\n";
  //   }

  BoundaryInfo& bd = system_mesh.get_boundary_info();
  const std::set< boundary_id_type > & side_id_type =  bd.get_side_boundary_ids ();
  std::set< boundary_id_type>::iterator it;
  std::cout<<"[!][number of side id type]"<<side_id_type.size()<<"\n";
   for(it=side_id_type.begin(); it!=side_id_type.end(); it++)
    std::cout<<"[!][side_boundary_ids]"<<*it<<"\n";

  //system.set_clamped_border(boundary_id_min_x);

  // Set the time stepping options
  elasticity_system.deltat = deltat;

  // And the nonlinear solver options
  DiffSolver & solver = *(elasticity_system.time_solver->diff_solver().get());
  solver.quiet = input_params.solver_quiet;
  solver.verbose = !solver.quiet;
  solver.max_nonlinear_iterations = input_params.max_nonlinear_iterations;
  solver.relative_step_tolerance = input_params.relative_step_tolerance;
  solver.relative_residual_tolerance = input_params.relative_residual_tolerance;
  solver.absolute_residual_tolerance = input_params.absolute_residual_tolerance;

  // And the linear solver options
  solver.max_linear_iterations = input_params.max_linear_iterations;
  solver.initial_linear_tolerance = input_params.initial_linear_tolerance;

  // Print information about the system to the screen.
  //printf(">>>>[fem_system_ex3]execution de la commande equation_systems.print_info()\n");
  equation_systems.print_info();

  // If we're using EulerSolver or Euler2Solver, and we're using EigenSparseLinearSolver,
  // then we need to reset the EigenSparseLinearSolver to use SPARSELU because BICGSTAB
  // chokes on the Jacobian matrix we give it and Eigen's GMRES currently doesn't work.

/*  NewtonSolver * newton_solver = dynamic_cast<NewtonSolver *>( &solver );
  if( newton_solver &&
      (time_solver == std::string("euler") || time_solver == std::string("euler2") ) )
    {
#ifdef LIBMESH_HAVE_EIGEN_SPARSE
      LinearSolver<Number> & linear_solver = newton_solver->get_linear_solver();
      EigenSparseLinearSolver<Number> * eigen_linear_solver =
        dynamic_cast<EigenSparseLinearSolver<Number> *>(&linear_solver);

      if( eigen_linear_solver )
        eigen_linear_solver->set_solver_type(SPARSELU);
#endif
    }*/

  // if( time_solver == std::string("newmark") )
  //   {
      NewmarkSolver * newmark = cast_ptr<NewmarkSolver*>(elasticity_system.time_solver.get());
      newmark->compute_initial_accel();

      // Copy over initial velocity and acceleration for output.
      // Note we can do this because of the matching variables/FE spaces
      *(v_system->solution) = elasticity_system.get_vector("_old_solution_rate");
      *(a_system->solution) = elasticity_system.get_vector("_old_solution_accel");
    // }

#ifdef LIBMESH_HAVE_EXODUS_API
  // Output initial state
  {
    std::ostringstream file_name;

    // We write the file in the ExodusII format.
    file_name << std::string("out.")+time_solver+std::string(".e-s.")
              << std::setw(3)
              << std::setfill('0')
              << std::right
              << 0;

    ExodusII_IO(system_mesh).write_timestep(file_name.str(),
                                     equation_systems,
                                     1, // This number indicates how many time steps
                                        // are being written to the file
                                     elasticity_system.time);
  }
#endif // #ifdef LIBMESH_HAVE_EXODUS_API

  // Now we begin the timestep loop to compute the time-accurate
  // solution of the equations.
  for (unsigned int t_step=0; t_step != n_timesteps; ++t_step)
    {
      // A pretty update message
      libMesh::out << "\n\nSolving time step "
                   << t_step
                   << ", time = "
                   << elasticity_system.time
                   << std::endl;

 /*[!]*/ elasticity_system.solve(); //-> lance la fonction ElasticitySystem::init_data
      // Advance to the next timestep in a transient problem
 /*[!]*/ elasticity_system.time_solver->advance_timestep();//->lance la fonction ElasticitySystem::side_time_derivative
 /*[!]*/                                        //->lance la fonction ElasticitySystem::element_time_derivative                

      // Copy over updated velocity and acceleration for output.
      // Note we can do this because of the matching variables/FE spaces


      // if( time_solver == std::string("newmark") )
      //   {
          *(v_system->solution) = elasticity_system.get_vector("_old_solution_rate");
          *(a_system->solution) = elasticity_system.get_vector("_old_solution_accel");
        // }

#ifdef LIBMESH_HAVE_EXODUS_API
      // Write out this timestep if we're requested to
      if ((t_step+1)%write_interval == 0)
        {
          std::ostringstream file_name;

          // We write the file in the ExodusII format.
          file_name << std::string("out.")+time_solver+std::string(".e-s.")
                    << std::setw(3)
                    << std::setfill('0')
                    << std::right
                    << t_step+1;

          ExodusII_IO(system_mesh).write_timestep(file_name.str(),
                                           equation_systems,
                                           1, // This number indicates how many time steps
                                              // are being written to the file
                                           elasticity_system.time);
        }
#endif // #ifdef LIBMESH_HAVE_EXODUS_API
    }

    // Print MatLab debugging output? Variable defined at "carl_headers.h"
#ifdef PRINT_MATLAB_DEBUG
  elasticity_system.matrix->print_matlab(input_params.output_base + "_sys_mat.m");
  elasticity_system.rhs->print_matlab(input_params.output_base + "_sys_rhs_vec.m");
#endif

//  // Export matrix and vector
//  libMesh::PetscMatrix<libMesh::Number> * temp_mat_ptr = libMesh::cast_ptr<libMesh::PetscMatrix<libMesh::Number> * >(elasticity_system.matrix);
//  libMesh::PetscVector<libMesh::Number> * temp_vec_ptr = libMesh::cast_ptr<libMesh::PetscVector<libMesh::Number> * >(elasticity_system.rhs);
//
//  carl::write_PETSC_matrix(*temp_mat_ptr, input_params.output_base + "_sys_mat.petscmat");
//  carl::write_PETSC_vector(*temp_vec_ptr, input_params.output_base + "_sys_rhs_vec.petscvec");
//
//  // If needed, print rigid body vectors
//  if(input_params.bCalculateRBVectors)
//  {
//    MatNullSpace nullsp_sys;
//    build_rigid_body_vectors(elasticity_system,nullsp_sys);
//    write_rigid_body_vectors(nullsp_sys,input_params.output_base,WorldComm.rank());
//    MatNullSpaceDestroy(&nullsp_sys);
//  }

  // All done.
  //
  return 0;
}



void read_material(std::string file_name, material_params& mat){
  
  
  if(!file_name.empty())
    {
      std::ifstream ifs(file_name);
      ifs>>mat.rho>>mat.young_modulus>>mat.poisson_ratio;
    }
  else
    printf("[!] no file passed");
}


