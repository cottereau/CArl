/*
 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "../CArlFreeFemMacros.idp"

// --- Program

// - Preamble

// Define system constants
real tgv = 10^30;
real alphaEps = 10^-2;		// alpha epsilon constant

// LATIN parameters
int			LATINIters = 10^4;
real		LATINTol = 1e-2;
real		LATINRelax = 0.8;
real[int]	LATINIndex(LATINIters);
real		normTol = 1e-14;

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("-meshA","");
string InputB = getARGV("-meshB","");
string InputIntersection = getARGV("-meshInter","");

// Create mesh objects
mesh3 ThA = readmesh3(InputA);
mesh3 ThB = readmesh3(InputB);
mesh3 ThI = readmesh3(InputIntersection);

// Create the functional spaces
fespace VhA(ThA,[P1,P1,P1]);	// Model A
fespace VhB(ThB,[P1,P1,P1]);	// Model B

VhA [uxA,uyA,uzA],[vxA,vyA,vzA];
VhB [uxB,uyB,uzB],[vxB,vyB,vzB];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;
func fAZ = 0;

func fBX = 0;
func fBY = 0;
func fBZ = 0;

// Boundary conditions
int  boundAIdx1 = 318;
func boundAX1   = 0;
func boundAY1   = 0;
func boundAZ1   = 0;

int  boundBIdx1 = 314;
//func boundBX1   = 0;
//func boundBY1   = 0.05 * (z - 0.5);
//func boundBZ1   = -0.05 * (y - 0.5);
func boundBX1	= 0.038625*z;
func boundBY1	= 0;
func boundBZ1 	= -0.0061125*z;
//func boundBX1	= 0;
//func boundBY1	= 0;
//func boundBZ1 	= 0.15;

// Physical constants
real lambdaA = 1;
real muA = 1;

real lambdaB = 1;
real muB = 1;

// - Create the alpha mask
string InputAlphaMask = getARGV("-alphaMask","");
mesh3 ThAlpha = readmesh3(InputAlphaMask);
fespace VhAlpha(ThAlpha,P0);

/*
 *		Create a "reg" function that returns, for a given point, the geometric
 * 	region defined in the "InputAlphaMask" file.
 */
VhAlpha reg=region; // Remember, it's a P0 function!

/*
 * 		Identify the region indices.
 */
int idxA =reg(0.5,0.5,0.5);
int idxB =reg(2.5,0.5,0.5);
int idxI =reg(1.5,0.5,0.5);

/*
 * 		Region identifying functions
 */
VhAlpha isInA = (region==idxA);
VhAlpha isInB = (region==idxB);
VhAlpha isInI = (region==idxI);

func alphaA		= 0 + isInA + 0.5*isInI + alphaEps*isInB;
func alphaB		= 0 + alphaEps*isInA + 0.5*isInI + isInB;

// - Main models

// Set up weak formulations
/*
 * 		Note: 	when using "varf" and "matrix" to build the matrices, the first
 * 				argument is associated to the solution, while the second defines
 * 				the functional space of the test functions.
 */

// Matrices
// Using the LamÃ©'s system definition given by FreeFem++ docs
varf vStiffA([uxA,uyA,uzA],[vxA,vyA,vzA]) = int3d(ThA)(
						alphaA*2*muA*Stiffness3D(uxA,uyA,uzA,vxA,vyA,vzA)
						+ alphaA*lambdaA*Div3D(uxA,uyA,uzA)*Div3D(vxA,vyA,vzA)
						)
						+ on(boundAIdx1,uxA=boundAX1,uyA=boundAY1,uzA=boundAZ1);

varf vStiffB([uxB,uyB,uzB],[vxB,vyB,vzB]) = int3d(ThB)(
						alphaB*2*muB*Stiffness3D(uxB,uyB,uzB,vxB,vyB,vzB)
						+ alphaB*lambdaB*Div3D(uxB,uyB,uzB)*Div3D(vxB,vyB,vzB)
						)
						+ on(boundBIdx1,uxB=boundBX1,uyB=boundBY1,uzB=boundBZ1);

matrix MA = vStiffA(VhA,VhA,tgv=tgv);
matrix MB = vStiffB(VhB,VhB,tgv=tgv);

// Vectors
varf vForceA([dummyAX,dummyAY,dummyAZ],[vxA,vyA,vzA]) =
						- int3d(ThA)( fAX*vxA + fAY*vyA + fAZ*vzA)
						+ on(boundAIdx1,dummyAX=boundAX1,dummyAY=boundAY1,dummyAZ=boundAZ1);

varf vForceB([dummyBX,dummyBY,dummyBZ],[vxB,vyB,vzB]) =
						- int3d(ThB)( fBX*vxB + fBY*vyB + fBZ*vzB)
						+ on(boundBIdx1,dummyBX=boundBX1,dummyBY=boundBY1,dummyBZ=boundBZ1);

real[int] FA = vForceA(0,VhA,tgv=tgv);
real[int] FB = vForceB(0,VhB,tgv=tgv);

// - Couplings

// Set up constants
real kappa = 1;
real eee   = 1;

// Set up weak formulations
varf vCoupling([ux,uy,uz],[vx,vy,vz]) = int3d(ThI)
									( kappa/(eee*eee)*Mass3D(ux,uy,uz,vx,vy,vz)
									+ kappa*Stiffness3D(ux,uy,uz,vx,vy,vz) );

// Build the coupling matrices
matrix CA = vCoupling(VhA,VhA,tgv=tgv);
matrix CB = vCoupling(VhB,VhA,tgv=tgv);

CompactLines(CA);
CompactLines(CB);
// - Projections

// Set up weak formulations
varf vProject([ux,uy,uz],[vx,vy,vz]) = int3d(ThI)
							( kappa/(eee*eee)*Mass3D(ux,uy,uz,vx,vy,vz)
							+ kappa*Stiffness3D(ux,uy,uz,vx,vy,vz) );

// Mediator space coupling
matrix CI = vProject(VhA,VhA,tgv=tgv);

CompactLines(CI);
CompactCols(CI);

// - LATIN !
// Do some asserts (just to be sure)
assert(MA.n==MA.m);
assert(MB.n==MB.m);
assert(CI.n==CI.m);

assert(CA.n==CI.n);
assert(CA.m==MA.m);

assert(CB.n==CI.n);
assert(CB.m==MB.m);

// Dimension constants (for ease of use)
int nA = MA.n;
int nB = MB.n;
int nI = CI.n;

// Projectors (using full lumping method)
matrix PA = CA;
matrix PB = CB;
real[int]	lumpedCI(nI);

FullLumpingCI(CI,lumpedCI);
FullLumpingProjection(lumpedCI,PA);
FullLumpingProjection(lumpedCI,PB);

// Search constants
real k = 2.5;
real kuA = k; real kuB = k; real kdA = k; real kdB = k;

// Vectors
real[int] solA(nA);		// solutions
real[int] solB(nB);		//

real[int] wA(nI);    	// projections
real[int] wB(nI);   	//

real[int] auxA(nI);    	// auxiliar vectors
real[int] auxB(nI);   	//

real[int] phiA(nI); 	// Lagrange multiplier fields
real[int] phiB(nI);  	//

real[int] forceA(nA);	// external forces
real[int] forceB(nB);	//

real[int] solAOld(nA);		// old versions
real[int] solBOld(nB);		//
real[int] phiAOld(nI); 		//
real[int] phiBOld(nI);  	//

real[int] phiADiff(nI);		//
real[int] phiBDiff(nI);		//
real[int] phiASum(nI);		//
real[int] phiBSum(nI);		//

// Matrices
matrix HA = (CA'*PA);
       HA = kdA*HA + MA;

matrix HB = (CB'*PB);
       HB = kdB*HB + MB;

set(HA,solver=UMFPACK);
set(HB,solver=UMFPACK);

// Initializations
forceA = FA;
forceB = FB;

solA = HA^-1*forceA;
solB = HB^-1*forceB;

wA = PA*solA;
wB = PB*solB;

phiA = -kdA*wA;
phiB = -kdB*wB;

// Iterate!
int iterCount = -1;
real LATINConv = 1 + LATINTol;

real normDiff, normSum;

while ( LATINConv > LATINTol && iterCount < LATINIters-1)
{
	++iterCount;

	// Coupled stage
	auxA = kuA*wA - phiA;
	auxB = kuB*wB - phiB;

	wA = auxA + auxB;
	wA = 1/(kuA+kuB)*wA;
	wB = wA;

	phiA = kuA*wA - auxA;
	phiB = kuB*wB - auxB;

	// Uncoupled stage
	auxA = - kdA*wA - phiA;
	auxB = - kdB*wB - phiB;

	solAOld = solA;
	solBOld = solB;

	forceA = CA'*auxA;
	forceA = FA - forceA;

	forceB = CB'*auxB;
	forceB = FB - forceB;

	solA = HA^-1*forceA;
	solB = HB^-1*forceB;

	wA = PA*solA;
	wB = PB*solB;

	phiAOld = phiA;
	phiBOld = phiB;

	phiA = - kdA*wA - auxA;
	phiB = - kdB*wB - auxB;

	// Relaxation
	solA = LATINRelax*solA + (1 - LATINRelax)*solAOld;
	solB = LATINRelax*solB + (1 - LATINRelax)*solBOld;

	// Convergence
	phiADiff = phiA - phiAOld;
	phiBDiff = phiB - phiBOld;

	phiASum = phiA + phiAOld;
	phiBSum = phiB + phiBOld;

	normDiff = sqrt(pow(phiADiff.l2,2) + pow(phiBDiff.l2,2));
	normSum = sqrt(pow(phiASum.l2,2)  + pow(phiBSum.l2,2));

	if(normSum < normTol)
	{
		break;
	}
	else
	{
		LATINConv = 2*normDiff/normSum;
		LATINIndex[iterCount] = LATINConv;
	}
}

// Print solution!

/*		!!!	The two expressions below are NOT equivalent (i.e. uxA[] != uyA[])
 * 			It seems like FreeFem++ overloads the 'operator=' for vectorial
 * 			F.E. spaces. [uxA,uyA] are linked by their declaration, and the
 * 			operations 'uxA[] = solA' and 'uyA[] = solA' projects the X and Y
 * 			elements of the solutions onto uxA and uyA;
 */

uxA[] = solA;
uyA[] = solA;
uzA[] = solA;

uxB[] = solB;
uyB[] = solB;
uzB[] = solB;

// Prepare to plot
real coef = 10;

mesh3 ThASol = movemesh3(ThA,transfo=[x+coef*uxA,y+coef*uyA,z+coef*uzA]);
mesh3 ThBSol = movemesh3(ThB,transfo=[x+coef*uxB,y+coef*uyB,z+coef*uzB]);

savemesh(ThASol,"output/deformed_A_lumping.mesh");
savemesh(ThBSol,"output/deformed_B_lumping.mesh");

// Plot tolerance
ofstream toleranceFile("output/FE3DLatin_tol_lumping.dat");
for (int iii = 0; iii <= iterCount; iii++)
{
	toleranceFile <<  iii + 1 << " " << LATINIndex[iii] << endl;
}

ofstream gnuplotFile("output/FE3DLatin_tol.gplot");
gnuplotFile	<< "set term eps" << endl
			<< "set output \"output/CArl_tol_lumping.eps\" " << endl
			<< "set title \"LATIN tolerance (lumping)\"" << endl
			<< "set xrange [1:]" << endl
		    << "set xlabel \"Iteration\"" << endl
			<< "set ylabel \"Tolerance\"" << endl
			<< "plot \"output/FE3DLatin_tol_lumping.dat\" w lp lc 1 notitle" << endl
			<< "set output \"output/CArl_tol_lumping_zoom.eps\" " << endl
			<< "set title \"LATIN tolerance (lumping - zoom)\"" << endl
			<< "set xrange [1:10]" << endl
			<< "replot" << endl
			<< "quit" << endl;
