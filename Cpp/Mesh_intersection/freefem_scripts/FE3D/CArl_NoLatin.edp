/*
 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "../CArlFreeFemMacros.idp"

// --- Program

// - Preamble

// Define system constants
real tgv = 10^30;
real alphaEps = 10^-2;		// alpha epsilon constant

// LATIN parameters
int			LATINIters = 10^2;
real		LATINTol = 1e-2;
real		LATINRelax = 0.8;
real[int]	LATINIndex(LATINIters);

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("-meshA","");
string InputB = getARGV("-meshB","");
string InputIntersection = getARGV("-meshInter","");

// Create mesh objects
mesh3 ThA = readmesh3(InputA);
mesh3 ThB = readmesh3(InputB);
mesh3 ThI = readmesh3(InputIntersection);

// Create the functional spaces
fespace VhA(ThA,[P1,P1,P1]);	// Model A
fespace VhB(ThB,[P1,P1,P1]);	// Model B

VhA [uxA,uyA,uzA],[vxA,vyA,vzA];
VhB [uxB,uyB,uzB],[vxB,vyB,vzB];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;
func fAZ = 0;

func fBX = 0;
func fBY = 0;
func fBZ = 0;

// Boundary conditions
int  boundAIdx1 = 318;
func boundAX1   = 0;
func boundAY1   = 0;
func boundAZ1   = 0;

int  boundBIdx1 = 314;
real alpha = -pi/20;
func boundBX1   = 0;
func boundBY1   = cos(alpha) * (y - 0.5) - sin(alpha) * (z - 0.5) + 0.5;
func boundBZ1   = sin(alpha) * (y - 0.5) - cos(alpha) * (z - 0.5) + 0.5;

// Physical constants
real lambdaA = 1;
real muA = 1;

real lambdaB = 1;
real muB = 1;

// - Create the alpha mask
string InputAlphaMask = getARGV("-alphaMask","");
mesh3 ThAlpha = readmesh3(InputAlphaMask);
fespace VhAlpha(ThAlpha,P0);

/*
 *		Create a "reg" function that returns, for a given point, the geometric
 * 	region defined in the "InputAlphaMask" file.
 */
VhAlpha reg=region; // Remember, it's a P0 function!

/*
 * 		Identify the region indices.
 */
int idxA =reg(0.5,0.5,0.5);
int idxB =reg(0.5,2.5,0.5);
int idxI =reg(0.5,1.5,0.5);

/*
 * 		Region identifying functions
 */
VhAlpha isInA = (region==idxA);
VhAlpha isInB = (region==idxB);
VhAlpha isInI = (region==idxI);

func alphaA		= 0 + (1 - alphaEps)*isInA + 0.5*isInI + alphaEps*isInB;
func alphaB		= 0 + alphaEps*isInA + 0.5*isInI + (1 - alphaEps)*isInB;

// - Main models

// Set up weak formulations
/*
 * 		Note: 	when using "varf" and "matrix" to build the matrices, the first
 * 				argument is associated to the solution, while the second defines
 * 				the functional space of the test functions.
 */

// Matrices
// Using the LamÃ©'s system definition given by FreeFem++ docs
varf vStiffA([uxA,uyA,uzA],[vxA,vyA,vzA]) = int3d(ThA)(
						alphaA*2*muA*Stiffness3D(uxA,uyA,uzA,vxA,vyA,vzA)
						+ alphaA*lambdaA*Div3D(uxA,uyA,uzA)*Div3D(vxA,vyA,vzA)
						)
						+ on(boundAIdx1,uxA=boundAX1,uyA=boundAY1,uzA=boundAZ1);

varf vStiffB([uxB,uyB,uzB],[vxB,vyB,vzB]) = int3d(ThB)(
						alphaB*2*muB*Stiffness3D(uxB,uyB,uzB,vxB,vyB,vzB)
						+ alphaB*lambdaB*Div3D(uxB,uyB,uzB)*Div3D(vxB,vyB,vzB)
						)
						+ on(boundBIdx1,uxB=boundBX1,uyB=boundBY1,uzB=boundBZ1);

matrix MA = vStiffA(VhA,VhA,tgv=tgv);
matrix MB = vStiffB(VhB,VhB,tgv=tgv);

// Vectors
varf vForceA([dummyX,dummyY,dummyZ],[vx,vy,vz]) =
						- int3d(ThA)( fAX*vx + fAY*vy + fAZ*vz)
						+ on(boundAIdx1,dummyX=boundAX1,dummyY=boundAY1,dummyZ=boundAZ1);

varf vForceB([dummyX,dummyY,dummyZ],[vx,vy,vz]) =
						- int3d(ThB)( fBX*vx + fBY*vy + fAZ*vz)
						+ on(boundBIdx1,dummyX=boundBX1,dummyY=boundBY1,dummyZ=boundBZ1);

real[int] FA = vForceA(0,VhA,tgv=tgv);
real[int] FB = vForceB(0,VhB,tgv=tgv);

// - Couplings

// Set up constants
real kappa = 1;
real eee   = 1;

// Set up weak formulations
varf vCoupling([ux,uy,uz],[vx,vy,vz]) = int3d(ThI)
					( kappa/(eee*eee)*Mass3D(ux,uy,uz,vx,vy,vz)
					+ kappa*Stiffness3D(ux,uy,uz,vx,vy,vz) );

// Build the coupling matrices
matrix CA = vCoupling(VhA,VhA,tgv=tgv);
matrix CB = vCoupling(VhB,VhA,tgv=tgv);

CompactLines(CA);
CompactLines(CB);
// - Projections

// Set up weak formulations
varf vProject([ux,uy,uz],[vx,vy,vz]) = int3d(ThI)
							( kappa/(eee*eee)*Mass3D(ux,uy,uz,vx,vy,vz)
							+ kappa*Stiffness3D(ux,uy,uz,vx,vy,vz) );

// Mediator space coupling
matrix CI = vProject(VhA,VhA,tgv=tgv);

CompactLines(CI);
CompactCols(CI);

matrix invCI;
InvertSparse(CI,invCI);

matrix PA = invCI*CA;
matrix PB = invCI*CB;

// - LATIN !
// Do some asserts (just to be sure)
assert(MA.n==MA.m);
assert(MB.n==MB.m);
assert(CI.n==CI.m);

assert(CA.n==CI.n);
assert(CA.m==MA.m);

assert(CB.n==CI.n);
assert(CB.m==MB.m);

// Dimension constants (for ease of use)
int nA = MA.n;
int nB = MB.n;
int nI = CI.n;

// Search constants
real k = 2.5;
real kuA = k; real kuB = k; real kdA = k; real kdB = k;

// Vectors
real[int] solA(nA);		// solutions
real[int] solB(nB);		//

real[int] wA(nI);    	// projections
real[int] wB(nI);   	//

real[int] auxA(nI);    	// auxiliar vectors
real[int] auxB(nI);   	//

real[int] phiA(nI); 	// Lagrange multiplier fields
real[int] phiB(nI);  	//

real[int] forceA(nA);	// external forces
real[int] forceB(nB);	//

real[int] solAOld(nA);		// old versions
real[int] solBOld(nB);		//
real[int] phiAOld(nI); 		//
real[int] phiBOld(nI);  	//

real[int] phiADiff(nI);		//
real[int] phiBDiff(nI);		//
real[int] phiASum(nI);		//
real[int] phiBSum(nI);		//

// Matrices
matrix HA = (CA'*PA);
       HA = kdA*HA + MA;

matrix HB = (CB'*PB);
       HB = kdB*HB + MB;

set(HA,solver=UMFPACK);
set(HB,solver=UMFPACK);

// Initializations
forceA = FA;
forceB = FB;

solA = HA^-1*forceA;
solB = HB^-1*forceB;

wA = PA*solA;
wB = PB*solB;

phiA = -kdA*wA;
phiB = -kdB*wB;

// Iterate!
int iterCount = -1;
real LATINConv = 1 + LATINTol;

while ( LATINConv > LATINTol && iterCount < LATINIters)
{
	++iterCount;

	// Coupled stage
	auxA = kuA*wA - phiA;
	auxB = kuB*wB - phiB;

	wA = auxA + auxB;
	wA = 1/(kuA+kuB)*wA;
	wB = wA;

	phiA = kuA*wA - auxA;
	phiB = kuB*wB - auxB;

	// Uncoupled stage
	auxA = - kdA*wA - phiA;
	auxB = - kdB*wB - phiB;

	solAOld = solA;
	solBOld = solB;

	forceA = CA'*auxA;
	forceA = FA - forceA;

	forceB = CB'*auxB;
	forceB = FB - forceB;

	solA = HA^-1*forceA;
	solB = HB^-1*forceB;

	wA = PA*solA;
	wB = PB*solB;

	phiAOld = phiA;
	phiBOld = phiB;

	phiA = - kdA*wA - auxA;
	phiB = - kdB*wB - auxB;

	// Relaxation
	solA = LATINRelax*solA + (1 - LATINRelax)*solAOld;
	solB = LATINRelax*solB + (1 - LATINRelax)*solBOld;

	// Convergence
	phiADiff = phiA - phiAOld;
	phiBDiff = phiB - phiBOld;

	phiASum = phiA + phiAOld;
	phiBSum = phiB + phiBOld;
	LATINConv = 2*sqrt(pow(phiADiff.l2,2) + pow(phiBDiff.l2,2)) /
			      sqrt(pow(phiASum.l2,2)  + pow(phiBSum.l2,2));

	LATINIndex[iterCount] = LATINConv;
	cout << LATINConv << endl;
}

// Print solution!

/*		!!!	The two expressions below are NOT equivalent (i.e. uxA[] != uyA[])
 * 			It seems like FreeFem++ overloads the 'operator=' for vectorial
 * 			F.E. spaces. [uxA,uyA] are linked by their declaration, and the
 * 			operations 'uxA[] = solA' and 'uyA[] = solA' projects the X and Y
 * 			elements of the solutions onto uxA and uyA;
 */

uxA[] = solA;
uyA[] = solA;

uxB[] = solB;
uyB[] = solB;

// Prepare to plot
real coef = 10;

//mesh3 ThASol = movemesh3(ThA,[x+coef*uxA,y+coef*uyA,z+coef*uzA]);
//mesh3 ThBSol = movemesh3(ThB,[x+coef*uxB,y+coef*uyB,z+coef*uzB]);

// Plot deformed mesh
plot(ThA,ThB,wait=true,ps="FE3DLatin_originalMesh.eps");
//plot(ThASol,ThBSol,wait=true,ps="FE3DLatin_deformedMesh.eps");

// Plot tolerance
ofstream toleranceFile("FE3DLatin_tol.dat");
for (int iii = 0; iii <= iterCount; iii++)
{
	toleranceFile <<  iii + 1 << " " << LATINIndex[iii] << endl;
}

ofstream gnuplotFile("FE3DLatin_tol.gplot");
gnuplotFile	<< "set term eps" << endl
			<< "set output \"CArl_tol.eps\" " << endl
			<< "set title \"LATIN tolerance (inverse)\"" << endl
			<< "set xrange [1:]" << endl
		    << "set xlabel \"Iteration\"" << endl
			<< "set ylabel \"Tolerance\"" << endl
			<< "plot \"FE3DLatin_tol.dat\" w lp lc 1 notitle" << endl
			<< "quit" << endl;






















/*






 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "CArlFreeFemMacros.idp"

// --- Program

// - Preamble

// Define system constants
real tgv = 10^30;			// tres grande valeur
real alphaEps = 10^-2;		// alpha epsilon constant

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("-meshA","");
string InputB = getARGV("-meshB","");
string InputIntersection = getARGV("-meshInter","");

// Create mesh objects
mesh ThA = readmesh(InputA);
mesh ThB = readmesh(InputB);
mesh ThI = readmesh(InputIntersection);

// Create the functional spaces
fespace VhA(ThA,[P1,P1]);	// Model A
fespace VhB(ThB,[P1,P1]);	// Model B

VhA [uxA,uyA],[vxA,vyA];
VhB [uxB,uyB],[vxB,vyB];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;

func fBX = 0;
func fBY = 0;

// Boundary conditions
int  boundAIdx1 = 10;
func boundAX1   = 0;
func boundAY1   = 0;

int  boundBIdx1 = 10;
func boundBX1   = 0.038625*(y);
func boundBY1   = -0.0061125*(y);

// Physical constants
real lambdaA = 1;
real muA = 1;

real lambdaB = 1;
real muB = 1;

// - Create the alpha mask
string InputAlphaMask = getARGV("-alphaMask","");
mesh ThAlpha = readmesh(InputAlphaMask);
fespace VhAlpha(ThAlpha,P0);

/*
 *		Create a "reg" function that returns, for a given point, the geometric
 * 	region defined in the "InputAlphaMask" file.
 */
VhAlpha reg=region; // Remember, it's a P0 function!

/*
 * 		Identify the region indices.
 */
int idxA =reg(0.5,0.5);
int idxB =reg(2.5,0.5);
int idxI =reg(1.5,0.5);

/*
 * 		Region identifying functions
 */
VhAlpha isInA = (region==idxA);
VhAlpha isInB = (region==idxB);
VhAlpha isInI = (region==idxI);

func alphaA		= 0 + (1 - alphaEps)*isInA + 0.5*isInI + alphaEps*isInB;
func alphaB		= 0 + alphaEps*isInA + 0.5*isInI + (1 - alphaEps)*isInB;

// - Main models

// Set up weak formulations
/*
 * 		Note: 	when using "varf" and "matrix" to build the matrices, the first
 * 				argument is associated to the solution, while the second defines
 * 				the functional space of the test functions.
 */

// Matrices
// Using the LamÃ©'s system definition given by FreeFem++ docs
varf vStiffA([uxA,uyA],[vxA,vyA]) = int2d(ThA)(
						alphaA*2*muA*Stiffness2D(uxA,uyA,vxA,vyA)
						+ alphaA*lambdaA*Div2D(uxA,uyA)*Div2D(vxA,vyA)
						)
						+ on(10,uxA=boundAX1,uyA=boundAY1);

varf vStiffB([uxB,uyB],[vxB,vyB]) = int2d(ThB)(
						alphaB*2*muB*Stiffness2D(uxB,uyB,vxB,vyB)
						+ alphaB*lambdaB*Div2D(uxB,uyB)*Div2D(vxB,vyB)
						)
						+ on(10,uxB=boundBX1,uyB=boundBY1);

matrix MA = vStiffA(VhA,VhA,tgv=tgv);
matrix MB = vStiffB(VhB,VhB,tgv=tgv);

// Vectors
varf vForceA([dummyX,dummyY],[vx,vy]) =
						- int2d(ThA)( alphaA * (fAX*vx + fAY*vy) )
						+ on(10,dummyX=boundAX1,dummyY=boundAY1);

varf vForceB([dummyX,dummyY],[vx,vy]) =
						- int2d(ThB)( alphaB * (fBX*vx + fBY*vy) )
						+ on(10,dummyX=boundBX1,dummyY=boundBY1);

real[int] FA = vForceA(0,VhA,tgv=tgv);
real[int] FB = vForceB(0,VhB,tgv=tgv);

// - Couplings

// Set up constants
real kappa = 1;
real eee   = 1;

// Set up weak formulations
varf vCoupling([ux,uy],[vx,vy]) = int2d(ThI)
	( kappa/(eee*eee)*Mass2D(ux,uy,vx,vy) + kappa*Stiffness2D(ux,uy,vx,vy) );

// Build the coupling matrices
matrix CA = vCoupling(VhA,VhA,tgv=tgv);
matrix CB = vCoupling(VhB,VhA,tgv=tgv);

// Compact the lines
int[int] III(1), JJJ(1); real[int] Val(1);
CompactLines(CA);
CompactLines(CB);

// Test if the number of lines of the couplings is the same
assert(CA.n==CB.n);

// Assemble the final matrix and vector
matrix CAt =  CA';
CB = -CB;
matrix CBt =  CB';
matrix M	= [[ MA ,   0 ,  CAt ],
		       [  0 ,  MB ,  CBt ],
			   [ CA ,  CB ,   0  ]
			  ];

real[int] F(M.n);
for(int iii = 0; iii < MA.n; ++ iii)
{
	F[iii] = FA[iii];
}
for(int iii = 0; iii < MB.n; ++ iii)
{
	F[MA.n + iii] = FB[iii];
}

// Solve (direct)
set(M,solver=UMFPACK,nbiter=10000);
real[int] sol = M^-1*F;

// Extract solution
real[int] solA(MA.n);
real[int] solB(MB.n);

for(int iii = 0; iii < MA.n; ++iii)
{
	solA[iii] = sol[iii];
}
for(int iii = 0; iii < MB.n; ++iii)
{
	solB[iii] = sol[MA.n + iii];
}

/*		!!!	The two expressions below are NOT equivalent (i.e. uxA[] != uyA[])
 * 			It seems like FreeFem++ overloads the 'operator=' for vectorial
 * 			F.E. spaces. [uxA,uyA] are linked by their declaration, and the
 * 			operations 'uxA[] = solA' and 'uyA[] = solA' projects the X and Y
 * 			elements of the solutions onto uxA and uyA;
 */

uxA[] = solA;
uyA[] = solA;

uxB[] = solB;
uyB[] = solB;

// Prepare to plot
real coef = 10;

mesh ThASol = movemesh(ThA,[x+coef*uxA,y+coef*uyA]);
mesh ThBSol = movemesh(ThB,[x+coef*uxB,y+coef*uyB]);

// Plot deformed mesh
plot(ThA,ThB,wait=true,ps="FE2D_originalMesh.eps");
plot(ThASol,ThBSol,wait=true,ps="FE2D_deformedMesh.eps");
