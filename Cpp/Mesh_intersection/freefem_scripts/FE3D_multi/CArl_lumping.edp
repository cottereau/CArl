/*
 * 		Prototype of a CArl implementation using FreeFem++
 *
 *		To do lists
 *
 * 		----	Needs some more reading and testing before implementation
 * 		TODO :	Different solvers (sparse, parallel?)
 *		TODO :	Connecting to METIS (needed if the solver is parallel?)
 *
 * 		----	Long(ish) term
 * 		TODO :	Set up a file reading interface
 * 		TODO :	Read the model parameters from a file
 *
 */

// --- Includes and loads
include "../CArlFreeFemMacros.idp"

// --- Program

// - Preamble

// --- "Defines" for the boundary conditions
int BoundIDMinZ = 1;
int BoundIDMinY = 2;
int BoundIDMaxX = 3;
int BoundIDMaxY = 4;
int BoundIDMinX = 5;
int BoundIDMaxZ = 6;

// Define system constants
real tgv = 10^30;
real alphaEps = 10^-2;		// alpha epsilon constant

// LATIN parameters
int			LATINIters = 10^2;
real		LATINTol = 1e-2;
real		LATINRelax = 0.8;
real[int]	LATINIndex(LATINIters);
real		normTol = 1e-14;

// Read arguments
/*
 * 		The functional space associated to "InputA"'s mesh will be as the "main"
 * 	space - the virtual deformations of the couplings will be associated to it.
 * 	In general, it is a good idea then to associate the coarser mesh to it.
 *
 */
string InputA = getARGV("--meshA","meshes/FE3Dlatin_cube.mesh");
string InputB = getARGV("--meshB","meshes/test__w_0_2__p_30.mesh");
string InputIntersection = getARGV("--meshInter","meshes/cube__w_0_2__p_30_intersection.mesh");

// Create mesh objects
mesh3 ThA = readmesh3(InputA);
mesh3 ThB = readmesh3(InputB);
mesh3 ThI = readmesh3(InputIntersection);

// Create the functional spaces
fespace VhA(ThA,[P1,P1,P1]);	// Model A
fespace VhB(ThB,[P1,P1,P1]);	// Model B

VhA [uxA,uyA,uzA],[vxA,vyA,vzA];
VhB [uxB,uyB,uzB],[vxB,vyB,vzB];

// - Define the models' constants
// Load
func fAX = 0;
func fAY = 0;
func fAZ = 0;

func fBX = 0;
func fBY = 0;
func fBZ = 0;

// Boundary conditions
func boundAXMinX   = 0;
func boundAYMinX   = 0;
func boundAZMinX   = 0;

func boundAXMaxX   = 0.2;
func boundAYMaxX   = 0.99984769515639123916*y+0.01745240643728351282*z - y;
func boundAZMaxX   = -0.01745240643728351282*y+0.99984769515639123916*z - z;

// Physical constant mask
string crystalMask = getARGV("--centers","meshes/test__w_0_2__p_30_centers.dat");
string physicalParamsFile = getARGV("--parameters","meshes/test__w_0_2__p_30_physical.dat");

ifstream crystalCenters(crystalMask);
ifstream physicalParams(physicalParamsFile);

int nbOfCrystals = -1;
int nbOfParams = -1;
int dummyId = -1;

crystalCenters >> nbOfCrystals;
physicalParams >> nbOfParams;

assert(nbOfCrystals == nbOfParams);

real[int] crystalX(nbOfCrystals);
real[int] crystalY(nbOfCrystals);
real[int] crystalZ(nbOfCrystals);
int[int]  crystalIdx(nbOfCrystals);

real[int] lambdaVector(nbOfCrystals);
real[int] youngVector(nbOfCrystals);
real[int] muVector(nbOfCrystals);

real meanMuA = 0;
real meanLambdaA = 0;

real youngTemp = 0;

fespace VhCrystalDomains(ThB,P0);

cout << endl;
cout << " --> Reading crystal centers file ...";
for(int iii = 0; iii < nbOfCrystals; ++iii)
{
	crystalCenters >> crystalX[iii];
	crystalCenters >> crystalY[iii];
	crystalCenters >> crystalZ[iii];
	crystalCenters >> crystalIdx[iii];
}
cout << " finished!" << endl;

cout << " --> Reading parameters file ...";
for(int iii = 0; iii < nbOfCrystals; ++iii)
{
	physicalParams >> youngVector[iii];
	physicalParams >> muVector[iii];
	physicalParams >> dummyId;
}
cout << " finished!" << endl;

VhCrystalDomains regCrystals=region;
VhCrystalDomains[int] crystalRegions(nbOfCrystals);

VhCrystalDomains tempRandomLambda;
VhCrystalDomains tempRandomMu;

cout << " --> Generating region functions ... " << endl;
cout << "   > Idx / Mu     / E      / Lambda 1" << endl;

for(int iii = 0; iii < nbOfCrystals; ++iii)
{
	lambdaVector[iii] = lambdaF(youngVector[iii],muVector[iii]);

	crystalRegions[iii] = (region == regCrystals(crystalX[iii],crystalY[iii],crystalZ[iii]));

	tempRandomLambda = tempRandomLambda + lambdaVector[iii]*crystalRegions[iii];
	tempRandomMu = tempRandomMu + muVector[iii]*crystalRegions[iii];

	meanMuA += muVector[iii]/nbOfCrystals;
	meanLambdaA += lambdaVector[iii]/nbOfCrystals;

	cout << "   > " << crystalIdx[iii] << " " << muVector[iii] << " "
			<< youngVector[iii] << " " << lambdaVector[iii] << endl;
}
func randomLambdaB = tempRandomLambda;
func randomMuB = tempRandomMu;

cout << " --> Generating region functions ... finished!" << endl;

// - Create the alpha mask
string InputAlphaMask = getARGV("--alphaMask","meshes/FE3D_multi_mask.mesh");
mesh3 ThAlpha = readmesh3(InputAlphaMask);
fespace VhAlpha(ThAlpha,P0);

/*
 *		Create a "reg" function that returns, for a given point, the geometric
 * 	region defined in the "InputAlphaMask" file.
 */
VhAlpha regMask=region; // Remember, it's a P0 function!

/*
 * 		Identify the region indices.
 */
int idxA =regMask(1.1,0.0,0.0);
int idxB =regMask(0.0,0.0,0.0);
int idxI =regMask(0.9,0.0,0.0);

/*
 * 		Region identifying functions
 */
VhAlpha isInA = (region==idxA);
VhAlpha isInB = (region==idxB);
VhAlpha isInI = (region==idxI);

func alphaA		= 0 + isInA + 0.5*isInI + alphaEps*isInB;
func alphaB		= 0 + alphaEps*isInA + 0.5*isInI + isInB;

// - Main models

// Set up weak formulations
/*
 * 		Note: 	when using "varf" and "matrix" to build the matrices, the first
 * 				argument is associated to the solution, while the second defines
 * 				the functional space of the test functions.
 */

// Matrices
// Using the LamÃ©'s system definition given by FreeFem++ docs
varf vStiffA([uxA,uyA,uzA],[vxA,vyA,vzA]) = int3d(ThA)(
						alphaA*2*meanMuA*Stiffness3D(uxA,uyA,uzA,vxA,vyA,vzA)
						+ alphaA*meanLambdaA*Div3D(uxA,uyA,uzA)*Div3D(vxA,vyA,vzA)
						)
						+ on(BoundIDMaxX,uxA=boundAXMaxX,uyA=boundAYMaxX,uzA=boundAZMaxX)
						+ on(BoundIDMinX,uxA=boundAXMinX,uyA=boundAYMinX,uzA=boundAZMinX);

varf vStiffB([uxB,uyB,uzB],[vxB,vyB,vzB]) = int3d(ThB)(
						alphaB*2*randomMuB*Stiffness3D(uxB,uyB,uzB,vxB,vyB,vzB)
						+ alphaB*randomLambdaB*Div3D(uxB,uyB,uzB)*Div3D(vxB,vyB,vzB)
						);
//						+ on(boundBIdx1,uxB=boundBX1,uyB=boundBY1,uzB=boundBZ1);

matrix MA = vStiffA(VhA,VhA,tgv=tgv);
matrix MB = vStiffB(VhB,VhB,tgv=tgv);

// Vectors
varf vForceA([dummyAX,dummyAY,dummyAZ],[vxA,vyA,vzA]) =
						- int3d(ThA)( fAX*vxA + fAY*vyA + fAZ*vzA)
						+ on(BoundIDMaxX,dummyAX=boundAXMaxX,dummyAY=boundAYMaxX,dummyAZ=boundAZMaxX)
						+ on(BoundIDMinX,dummyAX=boundAXMinX,dummyAY=boundAYMinX,dummyAZ=boundAZMinX);
//						+ on(boundAIdx1,dummyAX=boundAX1,dummyAY=boundAY1,dummyAZ=boundAZ1);

varf vForceB([dummyBX,dummyBY,dummyBZ],[vxB,vyB,vzB]) =
						- int3d(ThB)( fBX*vxB + fBY*vyB + fBZ*vzB);
//						+ on(boundBIdx1,dummyBX=boundBX1,dummyBY=boundBY1,dummyBZ=boundBZ1);

real[int] FA = vForceA(0,VhA,tgv=tgv);
real[int] FB = vForceB(0,VhB,tgv=tgv);

// - Couplings

// Set up constants
real kappa = meanLambdaA;
real eee   = 0.2;

// Set up weak formulations
varf vCoupling([ux,uy,uz],[vx,vy,vz]) = int3d(ThI)
									( kappa/(eee*eee)*Mass3D(ux,uy,uz,vx,vy,vz)
									+ kappa*Stiffness3D(ux,uy,uz,vx,vy,vz) );

// Build the coupling matrices
matrix CA = vCoupling(VhA,VhA,tgv=tgv);
matrix CB = vCoupling(VhB,VhA,tgv=tgv);

cout << "  -- Compacting CA lines" << endl;
CompactLines(CA);
cout << "  -- Compacting CB lines" << endl;
CompactLines(CB);

ofstream compactedAFile("output/compacted_A.dat");
compactedAFile << CA << endl;

ofstream compactedBFile("output/compacted_B.dat");
compactedBFile << CB << endl;


// - Projections

// Set up weak formulations
varf vProject([ux,uy,uz],[vx,vy,vz]) = int3d(ThI)
							( kappa/(eee*eee)*Mass3D(ux,uy,uz,vx,vy,vz)
							+ kappa*Stiffness3D(ux,uy,uz,vx,vy,vz) );

// Mediator space coupling
matrix CI = vProject(VhA,VhA,tgv=tgv);

cout << "  -- Compacting CI lines" << endl;
CompactLines(CI);
cout << "  -- Compacting CI columns" << endl;
CompactCols(CI);

// - LATIN !
// Do some asserts (just to be sure)
assert(MA.n==MA.m);
assert(MB.n==MB.m);
assert(CI.n==CI.m);

assert(CA.n==CI.n);
assert(CA.m==MA.m);

assert(CB.n==CI.n);
assert(CB.m==MB.m);

// Dimension constants (for ease of use)
int nA = MA.n;
int nB = MB.n;
int nI = CI.n;

// Projectors (using full lumping method)
matrix PA = CA;
matrix PB = CB;
real[int]	lumpedCI(nI);

FullLumpingCI(CI,lumpedCI);
FullLumpingProjection(lumpedCI,PA);
FullLumpingProjection(lumpedCI,PB);

// Search constants
real k = 2.5;
real kuA = k; real kuB = k; real kdA = k; real kdB = k;

// Vectors
real[int] solA(nA);		// solutions
real[int] solB(nB);		//

real[int] wA(nI);    	// projections
real[int] wB(nI);   	//

real[int] auxA(nI);    	// auxiliar vectors
real[int] auxB(nI);   	//

real[int] phiA(nI); 	// Lagrange multiplier fields
real[int] phiB(nI);  	//

real[int] forceA(nA);	// external forces
real[int] forceB(nB);	//

real[int] solAOld(nA);		// old versions
real[int] solBOld(nB);		//
real[int] phiAOld(nI); 		//
real[int] phiBOld(nI);  	//

real[int] phiADiff(nI);		//
real[int] phiBDiff(nI);		//
real[int] phiASum(nI);		//
real[int] phiBSum(nI);		//

// Matrices
matrix HA = (CA'*PA);
       HA = kdA*HA + MA;

matrix HB = (CB'*PB);
       HB = kdB*HB + MB;

set(HA,solver=UMFPACK);
set(HB,solver=UMFPACK);

// Initializations
forceA = FA;
forceB = FB;

solA = HA^-1*forceA;
solB = HB^-1*forceB;

wA = PA*solA;
wB = PB*solB;

phiA = -kdA*wA;
phiB = -kdB*wB;

// Iterate!
int iterCount = -1;
real LATINConv = 1 + LATINTol;

real normDiff, normSum;

while ( LATINConv > LATINTol && iterCount < LATINIters-1)
{
	++iterCount;

	// Coupled stage
	auxA = kuA*wA - phiA;
	auxB = kuB*wB - phiB;

	wA = auxA + auxB;
	wA = 1/(kuA+kuB)*wA;
	wB = wA;

	phiA = kuA*wA - auxA;
	phiB = kuB*wB - auxB;

	// Uncoupled stage
	auxA = - kdA*wA - phiA;
	auxB = - kdB*wB - phiB;

	solAOld = solA;
	solBOld = solB;

	forceA = CA'*auxA;
	forceA = FA - forceA;

	forceB = CB'*auxB;
	forceB = FB - forceB;

	solA = HA^-1*forceA;
	solB = HB^-1*forceB;

	wA = PA*solA;
	wB = PB*solB;

	phiAOld = phiA;
	phiBOld = phiB;

	phiA = - kdA*wA - auxA;
	phiB = - kdB*wB - auxB;

	// Relaxation
	solA = LATINRelax*solA + (1 - LATINRelax)*solAOld;
	solB = LATINRelax*solB + (1 - LATINRelax)*solBOld;

	// Convergence
	phiADiff = phiA - phiAOld;
	phiBDiff = phiB - phiBOld;

	phiASum = phiA + phiAOld;
	phiBSum = phiB + phiBOld;

	normDiff = sqrt(pow(phiADiff.l2,2) + pow(phiBDiff.l2,2));
	normSum = sqrt(pow(phiASum.l2,2) + pow(phiBSum.l2,2));

	if(normSum < normTol)
	{
		break;
	}
	else
	{
		LATINConv = 2*normDiff/normSum;
		LATINIndex[iterCount] = LATINConv;
	}
}

// Print solution!

/*		!!!	The two expressions below are NOT equivalent (i.e. uxA[] != uyA[])
 * 			It seems like FreeFem++ overloads the 'operator=' for vectorial
 * 			F.E. spaces. [uxA,uyA] are linked by their declaration, and the
 * 			operations 'uxA[] = solA' and 'uyA[] = solA' projects the X and Y
 * 			elements of the solutions onto uxA and uyA;
 */

uxA[] = solA;
uyA[] = solA;
uzA[] = solA;

uxB[] = solB;
uyB[] = solB;
uzB[] = solB;

// Prepare to plot
real coef = 10;

mesh3 ThASol = movemesh3(ThA,transfo=[x+coef*uxA,y+coef*uyA,z+coef*uzA]);
mesh3 ThBSol = movemesh3(ThB,transfo=[x+coef*uxB,y+coef*uyB,z+coef*uzB]);

savemesh(ThASol,"output/deformed_A_lumping.mesh");
savemesh(ThBSol,"output/deformed_B_lumping.mesh");

// Plot tolerance
ofstream toleranceFile("output/FE3DLatin_tol_lumping.dat");
for (int iii = 0; iii <= iterCount; iii++)
{
	toleranceFile <<  iii + 1 << " " << LATINIndex[iii] << endl;
}

ofstream gnuplotFile("output/FE3DLatin_tol.gplot");
gnuplotFile	<< "set term eps" << endl
			<< "set output \"output/CArl_tol_lumping.eps\" " << endl
			<< "set title \"LATIN tolerance (lumping)\"" << endl
			<< "set xrange [1:]" << endl
		    << "set xlabel \"Iteration\"" << endl
			<< "set ylabel \"Tolerance\"" << endl
			<< "plot \"output/FE3DLatin_tol_lumping.dat\" w lp lc 1 notitle" << endl
			<< "set output \"output/CArl_tol_lumping_zoom.eps\" " << endl
			<< "set title \"LATIN tolerance (lumping - zoom)\"" << endl
			<< "set xrange [1:10]" << endl
			<< "replot" << endl
			<< "quit" << endl;
