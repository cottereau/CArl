<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CArl: CArl-Dyn-CG Solver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CArl
   </div>
   <div id="projectbrief">Code Arlequin / C++ implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cpp_dynamic__c_g_usage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CArl-Dyn-CG Solver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_dyn_cg_cpp_dynamic_usage"></a>
Usage</h1>
<h2><a class="anchor" id="subsec_dyn_cg_cpp_dynamic_workflow"></a>
Workflow</h2>
<p>The C++ implementation of the dynamic-Arlequin method follows the algorithms presented in ref. <b>TO_INSERT</b>. The same as the static code, and it is roughly divided into four parts:</p>
<ol type="1">
<li>the mesh intersection search</li>
<li>the coupling matrices assembly</li>
<li>(after preparation of external solvers), the interpolation matrix,<em>i.e</em>. \(H\), calculation, .</li>
<li>the time-dependent coupled system solver.</li>
</ol>
<p>The first two steps use the same code as in the static solver, and are implemented in the <a class="el" href="_c_arl__build__intersections_8cpp.html">CArl_build_intersections</a> and <a class="el" href="_c_arl__assemble__coupling_8cpp.html">CArl_assemble_coupling</a>, respectivelly. Their corresponding pages contain the documentation of the input parameters.</p>
<p>Before the third step, the preparation of external solver must be done, as the mass matrix,<em>i.e</em>. \(M\), is needed in the calculation of interpolation matrix. The calculation of interpolation matrix is implemented in the <a class="el" href="_c_arl__build__interpolation_8cpp.html">CArl_build_interpolation</a>. The corresponding page give the documentation of input parameters. Even though in matrix \(H=\alpha_1 C_1 M_1^{-1} C_1^T+\alpha_2 C_2 M_2^{-1} C_2^T \), the inversion of matrix is needed and could only be done sequentially. We still choose to invert the matrix here as this matrix will be widely used in the forth step. As a result, this step requires a bigger memory allocation and may take a longer time.</p>
<p>The time-dependent coupled system solver use a completely different method from the static FETI method. The detail of this method is presented in ref <b>TO_INSERT</b>. To allow the usage of external solvers in a non-intrusive way, the implementation is broken down into several <code>CArl_loop_dyn_***</code> binaries. Before calling the time-dependent coupled system solver, the user still has to do some preliminary operations involving the external solvers, including configuring the input file (with the documentation given in <a class="el" href="_c_arl__loop__dyn__setup_8cpp.html">CArl_loop_dyn_setup</a>)and preparing their input parameter files. After that, if the user is using a scheduler program such as SLURM, he only has to launch the <a class="el" href="_c_arl__loop__dyn__setup_8cpp.html">CArl_loop_dyn_setup</a> binary. The output of the coupled system solver is several vector in the PETSc binary format, which is detailledly explained in <a class="el" href="cpp_dynamic__d_i_usage.html#subsec_dyn_cpp_output">Output file</a></p>
<p>Up to now, we don't accept the usage of other scheduler program except SLURM. THIS PART IS NOT STILL IMPLEMENTED* If the user is not using a scheduler, the <a class="el" href="_c_arl__loop__dyn__setup_8cpp.html">CArl_loop_dyn_setup</a> binary will still take care of preparing the other binaries' input files, but the user will have to launch them by hand! Each binary will still return the command that the user has to run, but due to this limitation, the usage of a scheduler is highly recomended. This limitation is due to the fact that <code>mpirun</code> cannot be called recursively in the same shell.</p>
<p>As the dynamic code will do a finite difference method in time domain, the time steps for the coupled objects are different. In order to simpify the notation, we require that</p>
<ol type="1">
<li>the domain with the longer time step \( \Delta T \) is named as object A.</li>
<li>the domain with the smaller time step \( \Delta t \) is named as object B.</li>
<li>\( \Delta T \) is the integer multiple of \( \Delta t \), <code>i.e</code>. \( \Delta T= n \Delta t, n \in \mathbb{N} \).</li>
</ol>
<p>The figure below presents a workflow for using the C++ version of CArl. The page <a class="el" href="cpp_dynamic.html">CArl dynamic</a> examples shows, in detailed steps, how to run a simple test case using external solvers based on the libMesh library. Finally, a more detailed description of the role of each <code>CArl_loop_dyn_***</code> binaries is presented in the section sec_dyn_cpp_implementation.</p>
<div class="image">
<img src="CArl_dyn_structure_all.png" alt="CArl_dyn_structure_all.png"/>
<div class="caption">
Workflow of the C++ version of CArl Dynamic</div></div>
<h2><a class="anchor" id="subsec_dyn_cg_cpp_input"></a>
Input file syntax</h2>
<p>All the <code>CArl_FETI_***</code>binaries take as an input a configuration file though the command line argument <code>-i</code>: </p>
<pre class="fragment">./CArl_FETI_*** -i [input file]
</pre><p>These input files contain parameters such as file paths, output folders, configuration parameters and Boolean flags. They are case-sensitive, and the symbol <code>#</code> is used to comment a single line.</p>
<p>Most of the parameters follow a <code>ParameterName [value]</code> format: </p>
<pre class="fragment"># Cluster scheduler type
ClusterSchedulerType LOCAL

# Path to the base script file
ScriptFile scripts/common_script.sh
</pre><p>Since a space separates the <code>ParameterName</code> and the <code>[value]</code>, values containing spaces must be enclosed in `' '`: </p>
<pre class="fragment"># Command used for the external solver for the system A
ExtSolverA 'mpirun -n 4 ./libmesh_solve_linear_system -i '
</pre><p>A description of each file and its parameters can be found at the documentation pages of the corresponding <code>CArl_loop_dyn_***</code> binaries.</p>
<h2><a class="anchor" id="subsec_dyn_cg_cpp_output"></a>
Output file</h2>
<p>In the work folder of this code, a result folder, a scrath folder and a <code>coupled_solution</code> folder will be created:</p>
<ul>
<li>In the scratch folder will store some values gotten during the calculation and will be updated progressively.</li>
<li><p class="startli">In the result folder, we can get the vector solved with FEM (means before multiplying with base function). The result will be stored in <code>.petscvec</code> format and in <code>.m</code> format. The nomination is like <code>quantity_object_NoOfTime</code>:</p>
<ul>
<li>quantity: <code>disp</code> for displacement vector, <code>acc</code> for acceleration vector and <code>speed</code> for speed vector.</li>
<li>object: <code>A</code> for the bigger time step object, <code>B</code> for the smaller time step object.</li>
<li>NoOfTime: specifies the number of time step, <em>i.e.</em> \( \frac{t}{\Delta t} \)</li>
</ul>
<p class="startli">For example, if we have <code>disp_B_3</code>, it means the displacement of B at the moment \( 3\Delta t\).</p>
</li>
<li>In the <code>coupled_solution</code> folder, we can get the final coupled solution applied on the geometry (means after multiplication with base function). This is done according to the external solver configuration. And you will get the result in <code>sol_object_NoOfTime.e</code> format. This is able to be visualised in mesh generator such as ParaView.</li>
</ul>
<h1><a class="anchor" id="sec_dyn_cg_cpp_implementation"></a>
Implementation of the Dynamic solver</h1>
<p>This section enters in some details of the implementation of the dynamic solver, and as such reading the refs. TO_INSERT beforehand is highly recommended.</p>
<p>As said above, our implementation of the dynamic algortihm is broken down into several <code>CArl_loop_dyn_***</code> binaries. The "break points" correspont to the operations of the dynamic algorithm where the solutions of the external solvers are needed. Before closing, each one of these binaries executes a script which first submits the jobs for the external solver, and then calls the appropriate <code>CArl_loop_dyn_***</code> binary to continue the algortihm. This approach allows a non-intrusive usaage of the external solvers: the user only has to worry to save the data to be sent from the <code>CArl_loop_dyn_***</code> binaries and the external solvers in the appropriate format. It also avoids wasting cluster resources with idling jobs.</p>
<p>The figure below shows the structure of the FETI solver. It proceeds in the following manner:</p>
<div class="image">
<img src="CArl_dyn_structure_dyn_solver.png" alt="CArl_dyn_structure_dyn_solver.png"/>
<div class="caption">
Structure of the CArl Dynamic solver</div></div>
<ol type="1">
<li><p class="startli"><b>Setup</b>:</p>
<ol type="a">
<li><a class="el" href="_c_arl__loop__dyn__setup_8cpp.html">CArl_loop_dyn_setup</a> first create the result and scrtach folder, then generates the input parameter files for the other binaries and several execution scripts. More precisely, these execution scripts contain:<ul>
<li>External solver execution script, such as <code>ext_solver_Afree_acc.sh</code> and so on (shown in the figure with blue background, 5 in total).</li>
<li>Dynamic code execution script, such as <code>inner_ope_Afree.sh</code> and so on (shown in the figure with yellow background, 7 in total)</li>
<li>general execution script to chain other execution script, such as <code>Afree.sh</code> and so on (shown in the figure with white background, 5 in total)</li>
</ul>
</li>
</ol>
<p class="startli">Next, it initializes the file <code>iteration_progression.txt</code> to save the progression of time loop. Finally, it generates all the force vector in the folder <code>scratch/force_A</code> for <code>scratch/force_B</code> and prepares the initial right hand side vector \( rhs_i (0)= F_i (0), i= A,B \), as the initial displacement is 0 *(up to now, no pre-defined non-null displacement is supported)*.</p>
<p class="startli">At the end of this step, it will launch <code>Afree.sh</code> to begin the first outer loop.</p>
</li>
<li><p class="startli"><b>Outer loop</b>:</p>
<p class="startli">Outer loop calculate the accelration, speed and displacement of A, <em>i.e.</em> the object with bigger time step \( \Delta T \).</p>
<ol type="a">
<li>The <code>Afree.sh</code> script launch two exection scripts:<ol type="i">
<li>The <code>ext_solver_Afree_acc.sh</code> script which runs the external solver to get the A free acceleration \( \ddot{U}^A_{free} \)</li>
<li>The <code>inner_ope_Afree.sh</code> script which launches <a class="el" href="_c_arl__loop__dyn___afree_8cpp.html">CArl_loop_dyn_Afree</a> to get the free speed and displacement by Newmark method, as well as to launch <code>Bfree.sh</code> to go into the inner loop discribed below.</li>
</ol>
</li>
<li>After the inner loop, the <code>Alink.sh</code> script is launched:<ol type="i">
<li>The <code>prepare_Alink.sh</code> launches <a class="el" href="_c_arl__loop__dyn__pre___alink_8cpp.html">CArl_loop_dyn_pre_Alink</a> to do the multiplication \( C^A \Lambda (T) \) and saved as \( rhs^A_{link} \)</li>
<li>The <code>ext_solver_Alink.sh</code> runs the external solver to get A link acceleration \( \ddot{U}^A_{free} \)</li>
<li>The <code>inner_ope_Alink.sh</code> script launches <a class="el" href="_c_arl__loop__dyn___alink_8cpp.html">CArl_loop_dyn_Alink</a> to get the link speed and displacement by Newmark method, and to add free and link terme to get final displacement (or speed/acceleration). At the end of <a class="el" href="_c_arl__loop__dyn___alink_8cpp.html">CArl_loop_dyn_Alink</a>, it will read <code>iteration_progression.txt</code> to see the progression of outer loop:<ul>
<li>if it's smaller than the total outer loop (<em>i.e.</em> time smaller than total time), it will modify the <code>iteration_progression.txt</code> (<code>outer_prog+=1</code>) and launch 'Afree.sh' to begin a new outer loop.</li>
<li>if it's equal to total outer loop, it will stop the code and we can get the result.</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p class="startli"><b>Inner loop</b>:</p>
<p class="startli">Inner loop calculate the accelration, speed and displacement of B, <em>i.e.</em> the object with smaller time step \( \Delta t \). The first loop is automatically launched by <a class="el" href="_c_arl__loop__dyn___afree_8cpp.html">CArl_loop_dyn_Afree</a>.</p>
<ol type="a">
<li>The <code>Bfree.sh</code> script launch two exection scripts:<ol type="i">
<li>The <code>ext_solver_Bfree_acc.sh</code> script which runs the external solver to get the B free acceleration \( \ddot{U}^B_{free} \)</li>
<li>The <code>inner_ope_Bfree.sh</code> script which launches <a class="el" href="_c_arl__loop__dyn___bfree_8cpp.html">CArl_loop_dyn_Bfree</a> to get the free speed and displacement by Newmark method, as well as to launch <code>coupling.sh</code>.</li>
</ol>
</li>
<li>The <code>coupling.sh</code> aims at calculating the interpolation vector \( \Lambda \). It's processed by 3 steps:<ol type="i">
<li>The <code>setup_interpolation.sh</code> launches CArl_loop_dyn_inter to calculate \( rhs_{inter} = - ( C^A\ddot{U}^A_{free} (t)+C^B \ddot{U}^B_{free} (t)) \) with \( \ddot{U}^A_{free} (t) \) gotten by interpolation at the time step \( \Delta T \).</li>
<li>The <code>ext_solver_coupling.sh</code> launches external solver to solve \( H\Lambda (t)=rhs_{inter} \).</li>
<li>The <code>prepare_Blink.sh</code> launches <a class="el" href="_c_arl__loop__dyn__pre___blink_8cpp.html">CArl_loop_dyn_pre_Blink</a> to do the multiplication \( C^B \Lambda (t) \) and saved as \( rhs^B_{link} \). At the end of this code, it launches <code>Blink.sh</code>.</li>
</ol>
</li>
<li>Then, the <code>Blink.sh</code> script is launched:<ol type="i">
<li>The <code>ext_solver_Blink.sh</code> runs the external solver to get B link acceleration \( \ddot{U}^B_{free} \)</li>
<li>The <code>inner_ope_Blink.sh</code> script launches <a class="el" href="_c_arl__loop__dyn___blink_8cpp.html">CArl_loop_dyn_Blink</a> to get the link speed and displacement by Newmark method, and to add free and link terme to get final displacement (or speed/acceleration). At the end of <a class="el" href="_c_arl__loop__dyn___blink_8cpp.html">CArl_loop_dyn_Blink</a>, it will read <code>iteration_progression.txt</code> to see the progression of inner loop:<ul>
<li>if it's smaller than the total inner loop (<em>i.e.</em> interval time smaller than bigger time step), it will modify the <code>iteration_progression.txt</code> (<code>inner_prog+=1</code>) and launch 'Bfree.sh' to begin a new inner loop.</li>
<li>if it's equal to total inner loop, it will go to outer loop and launch <code>Alink.sh</code>.</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>As said above, this process is completely automated if the scheduling software SLURM, is used: the user only has to configure and execute the <a class="el" href="_c_arl__loop__dyn__setup_8cpp.html">CArl_loop_dyn_setup</a> binary. Details about the input parameters of each binary can be found at its documentation page (linked above).</p>
<p>After all of these code, please run <a class="el" href="libmesh__assemble__lin__homogeneous____max__x__traction__dyn_8cpp.html">libmesh_assemble_lin_homogeneous__max_x_traction_dyn</a> and <a class="el" href="libmesh__assemble__lin__homogeneous____min__x__clamped__dyn_8cpp.html">libmesh_assemble_lin_homogeneous__min_x_clamped_dyn</a> manually to convert these FEM result in <code>.e</code> format. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="cpp_main.html">CArl C++</a></li><li class="navelem"><a class="el" href="cpp_dynamic.html">CArl dynamic</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
