function [ x, y, K, z, F, k ] = StiffnessMatrixComsol( model )
% STIFFNESSMATRIXComsol to construct the basic stiffness matrix and force 
% vector by calling Comsol
%
% syntax: [ x, y, K, z, F ] = StiffnessMatrixHomeFE( model )
%
%  fem : structure define by Comsol
%
%  output: the format is that of sparse matrices. The matrix of stiffness
%          and the vector of force are such that, schematically:
%               Stiffness( x, y ) = K
%               Force( z ) = F
%
% copyright: Laboratoire MSSMat, Ecole Centrale Paris - CNRS UMR 8579
% contact: regis.cottereau@ecp.fr

% C. Zaccardi 07/2010

% constants
X = model.mesh.X ;
T = model.mesh.T ;
model.property = model.alpha*1 ;
model.load = model.alpha*1 ;

% COMSOL Multiphysics Model M-file
% Generated by COMSOL 3.5a (COMSOL 3.5.0.603, $Date: 2008/12/03 17:02:19 $)

flclear fem

fem = model.femcomsol ;

% Application mode
equ.a = 'propalpha(x,y)' ;
equ.c = 0 ;
equ.f = 'falpha(x,y)' ;

% Functions
clear fcns
fcns = cell(1,0) ;

% for the internal energy
fcns{1}.type='interp';
fcns{1}.name='falpha';
fcns{1}.method='linear';
fcns{1}.extmethod='extrap';

% interpolation mesh
Xint = X ;
Tint = T ;

xint = unique(Xint(:,1)) ;
[a,b] = find(abs(xint(1:end-1)-xint(2:end))>10*eps) ;
xint = [xint(a,1) ; xint(end,1)] ;
nx = size(xint,1) ;

yint = unique(Xint(:,2)) ;
[a,b] = find(abs(yint(1:end-1)-yint(2:end))>10*eps) ;
yint = [yint(a,1) ; yint(end,1)] ; 
ny = size(yint,1) ;

for i1 = 1:nx
    fcns{1}.x{i1} = num2str(xint(i1,1)) ;
end
for i2 = 1:ny
    fcns{1}.y{i2} = num2str(yint(i2,1)) ;
end
% for the virtual exterior work
fcns{2}.x = fcns{1}.x ;
fcns{2}.y = fcns{1}.y ;

pt = zeros(nx*ny,2) ;

for i3 = 1:nx
    for i4 = 1:ny
        pt(i3*i4,:) = [xint(i3,1),yint(i4,1)] ;
    end
end

% [mint,inmint] = fctcte(Xint, Tint, model.property, pt,0.5*mean(model.property)) ;
% [fint,infint] = fctcte(Xint, Tint, model.load, pt,0.5*mean(model.load)) ;

for i3 = 1:nx
    for i4 = 1:ny
    logi1 = (abs(Xint(:,1)-pt(i3*i4,1))<10*eps & ...
        abs(Xint(:,2)-pt(i3*i4,2))<10*eps) ;
    
%     celltest{(i3-1)*ny+i4} = num2str(mint(i3*i4,1)) ;
    
    if any(logi1)
        [nl,nc] = find(logi1) ;
        fcns{1}.data{(i3-1)*ny+i4} = num2str(model.property(nl,1)) ;
        % for the virtual exterior work
        fcns{2}.data{(i3-1)*ny+i4} = num2str(model.load(nl,1)) ;
    else
        fcns{1}.data{(i3-1)*ny+i4} = num2str(0.5*mean(model.property)) ;
        % for the virtual exterior work
        fcns{2}.data{(i3-1)*ny+i4} = num2str(0.5*mean(model.load)) ;
    end
    end
end

% keyboard
% 
% for i3 = 1:nx
% for i4 = 1:ny
% prop(i3,i4) = str2double(fcns{1}.data{(i3-1)*ny+i4});
% fp(i3,i4) = str2double(fcns{2}.data{(i3-1)*ny+i4});
% celte(i3,i4) = str2double(celltest{(i3-1)*ny+i4});
% end
% end
% 
% for i5=1:nx
% X1(i5,1) = str2double(fcns{1}.x{i5}) ;
% X2(i5,1) = str2double(fcns{2}.x{i5}) ;
% end
% for i5=1:ny
% Y1(i5,1) = str2double(fcns{1}.y{i5}) ;
% Y2(i5,1) = str2double(fcns{2}.y{i5}) ;
% end
% mesh(X1,Y1,prop')

% for the virtual exterior work
fcns{2}.type='interp';
fcns{2}.name='falpha';
fcns{2}.method='linear';
fcns{2}.extmethod='extrap';

fem.functions = fcns;

% Multiphysics
fem=multiphysics(fem);

% Extend mesh
fem.xmesh=meshextend(fem);
nodes = xmeshinfo(fem.xmesh,'out','nodes') ;

% Extract matrix
[Kf,Nf,Lf,M] = assemble(fem,'Out',{'K','N','L','M'}) ;
K = Kf(nodes.dofs,nodes.dofs) ;
F = Lf(nodes.dofs,1) ;
N = Nf(:,nodes.dofs) ;

% Test en enlevant la ligne en trop dans la matrice N pour
% Tests/modelcomsol_helm.mat
if size(N,1)>1
N = [N(1:2,:) ; N(4:6,:) ; N(8,:) ] ;
M = [M(1:2,1) ; M(4:6,1) ; M(8,1) ] ;
end

Nbc = size(N,1) ;
Nnul = spalloc(Nbc,Nbc,Nbc*Nbc) ;
Kt = [ K , N' ; N , Nnul ] ;
Ft = [ F ; M ] ;

[ x, y, K ] = find(Kt) ;
[ z, k, F ] = find(Ft) ;

disp('warning: only dirichlet boundary conditions implemented') ;

